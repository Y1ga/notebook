### 53. 对象复用的了解、零拷贝的了解

### 54. 面向对象三大特性，并举例说明

> 封装、继承、多态

1. **封装**

- 封装是指将数据和操作数据的方法组合在一起，并对外部隐藏数据的实现细节。这样可以保证数据的安全性和完整性，防止外部代码随意访问和修改对象内部的数据。

- 举例
  - 以一个简单的银行账户类`BankAccount`为例。在 C++ 中，代码可能如下：

```cpp
     class BankAccount {
     private:
         double balance;
     public:
         BankAccount(double initialBalance) {
             balance = initialBalance;
         }
         void deposit(double amount) {
             if (amount > 0) {
                 balance += amount;
             }
         }
         void withdraw(double amount) {
             if (amount > 0 && balance >= amount) {
                 balance -= amount;
             }
         }
         double getBalance() const {
             return balance;
         }
     };
```

- 在这个例子中，`balance`是账户余额，被声明为`private`（私有成员），这意味着外部代码不能直接访问`balance`。外部代码只能通过`deposit`、`withdraw`和`getBalance`这些公共方法来间接操作或获取`balance`的值。这样就保证了账户余额数据的安全性，防止不合理的修改，例如不能直接将余额设置为负数等。
- 在 Java 中，类似的代码如下：

```java
     class BankAccount {
         private double balance;
         public BankAccount(double initialBalance) {
             balance = initialBalance;
         }
         public void deposit(double amount) {
             if (amount > 0) {
                 balance += amount;
             }
         }
         public void withdraw(double amount) {
             if (amount > 0 && balance >= amount) {
                 balance -= amount;
             }
         }
         public double getBalance() {
             return balance;
         }
     }
```

2. **继承性**

- 概念
  - 继承是一种创建新类（派生类）的方式，派生类继承了基类（父类）的属性和方法，并且可以在此基础上添加新的属性和方法或者重写基类的方法。它体现了类与类之间的层次关系，有助于代码的复用。
- 举例
  - 假设我们有一个基类`Vehicle`（交通工具），在 Python 中代码如下：

```python
     class Vehicle:
         def __init__(self, brand):
             self.brand = brand
         def move(self):
             print("The vehicle is moving.")
```

- 现在我们创建一个派生类`Car`（汽车），它继承自`Vehicle`类：

```python
     class Car(Vehicle):
         def __init__(self, brand, model):
             super().__init__(brand)
             self.model = model
         def move(self):
             print(f"The {self.brand} {self.model} car is moving.")
```

- 在这个例子中，`Car`类继承了`Vehicle`类的`brand`属性和`move`方法。通过`super().__init__(brand)`调用了基类的构造函数来初始化`brand`属性。同时，`Car`类添加了自己的`model`属性，并且重写了`move`方法，提供了更具体的移动行为描述。这样就可以复用`Vehicle`类的代码，并且在`Car`类中进行功能扩展。
- 在 C# 中，类似的继承示例如下：

```csharp
     class Vehicle
     {
         public string Brand { get; set; }
         public virtual void Move()
         {
             System.Console.WriteLine("The vehicle is moving.");
         }
     }
     class Car : Vehicle
     {
         public string Model { get; set; }
         public override void Move()
         {
             System.Console.WriteLine($"The {Brand} {Model} car is moving.");
         }
     }
```

3. **多态性**

- 概念
  - 多态是指不同的对象对同一消息（方法调用）作出不同的反应。多态性可以通过继承和方法重写来实现，也可以通过接口来实现。它使得程序具有更好的灵活性和可扩展性。
- 举例
  - 以一个图形绘制系统为例，在 Java 中，我们可以有一个`Shape`接口：

```java
     interface Shape {
         void draw();
     }
     class Circle implements Shape {
         public void draw() {
             System.out.println("Drawing a circle.");
         }
     }
     class Rectangle implements Shape {
         public void draw() {
             System.out.println("Drawing a rectangle.");
         }
     }
```

- 然后我们可以编写一个函数来绘制不同的形状：

```java
     class Main {
         public static void drawShape(Shape shape) {
             shape.draw();
         }
         public static void main(String[] args) {
             Circle circle = new Circle();
             Rectangle rectangle = new Rectangle();
             drawShape(circle);
             drawShape(rectangle);
         }
     }
```

- 在这个例子中，`drawShape`函数接受一个`Shape`类型的对象，但是在运行时，根据传入对象的实际类型（是`Circle`还是`Rectangle`），会调用相应类的`draw`方法。这就是多态性的体现，使得代码可以更加灵活地处理不同类型的对象，而不需要为每种类型的对象编写专门的绘制函数。



### 55. C++的四种强制转换 reinterpret_cast/ const_cast/ static_cast/dynamic_cast

1. **`reinterpret_cast`**
   - 概念
     - `reinterpret_cast`是一种比较底层的、**具有高度危险性**的类型转换操作符。它用于在不同类型的指针或引用之间进行转换，**这些类型之间可能没有任何关联，只是简单地重新解释了二进制数据的表示形式**。
   - 示例与应用场景
     - 例如，将一个整数指针转换为一个字符指针：

```cpp
     #include <iostream>
     int main() {
         int num = 1234;
         int* int_ptr = &num;
         char* char_ptr = reinterpret_cast<char*>(int_ptr);
         std::cout << "The first byte of the integer as a char: " << *char_ptr << std::endl;
         return 0;
     }
```

- 在这个例子中，`reinterpret_cast`将`int`类型的指针`int_ptr`转换为`char`类型的指针`char_ptr`。这种转换可能会导致一些不可预测的行为，因为它没有考虑类型的语义，只是简单地重新解释了内存中的数据。不过，在一些特定的场景下，如与底层硬件接口或处理二进制数据存储格式时可能会用到。例如，在网络编程中，当需要将网络字节序的数据转换为本地字节序时，可能会涉及这种类型的转换。但需要**谨慎使用，因为很容易产生错误**。

2. **`const_cast`**

- 概念
  - `const_cast`主要用于**去除变量的`const`或`volatile`限定符**。它的主要作用是在一些特定情况下，允许**对原本被定义为`const`的对象进行修改**，但这种操作应该谨慎使用，因为它可能会破坏数据的完整性和程序的逻辑安全性。
- 示例与应用场景
  - 假设我们有一个函数，它接受一个`const`引用参数，但在函数内部我们知道这个参数实际上是可以被修改的（虽然这种情况应该尽量避免）：

```cpp
     #include <iostream>
     void modifyValue(int& value) {
         value = 10;
     }
     int main() {
         const int const_num = 5;
         // 下面的代码通过const_cast去掉const限定符，以便调用modifyValue函数进行修改
         int& num_ref = const_cast<int&>(const_num);
         modifyValue(num_ref);
         std::cout << "The modified value: " << const_num << std::endl;
         return 0;
     }
```

- 在这个例子中，我们通过`const_cast`将`const`引用`const_num`转换为非`const`引用`num_ref`，然后调用`modifyValue`函数修改了它的值。需要注意的是，这种操作**可能会违反程序的初衷**，因为`const`对象通常被期望是不可修改的。在实际应用中，可能在一些旧代码维护或者和一些不符合`const - correct`规范的库交互时会用到这种转换，但要确保修改`const`对象是合理的。

3. **`static_cast`**

- 概念
  - `static_cast`用于在相关类型之间进行转换，这些相关类型通常是在**继承层次结构中有明确关联**的类型，或者是**基本数据类型之间的一些常规转换**。它在**编译时进行类型检查**，比`reinterpret_cast`更安全。
- 示例与应用场景
  - 在继承关系中，将派生类指针转换为基类指针：

```cpp
     #include <iostream>
     class Base {
     public:
         void baseFunction() {
             std::cout << "Base function called." << std::endl;
         }
     };
     class Derived : public Base {
     public:
         void derivedFunction() {
             std::cout << "Derived function called." << std::endl;
         }
     };
     int main() {
         Derived* derived_ptr = new Derived();
         Base* base_ptr = static_cast<Base*>(derived_ptr);
         base_ptr->baseFunction();
         // 注意：下面这行代码如果不进行正确的类型转换（如dynamic_cast）会导致错误
         // derived_ptr = static_cast<Derived*>(base_ptr);
         return 0;
     }
```

- 在这里，`static_cast`将`Derived`类的指针`derived_ptr`转换为`Base`类的指针`base_ptr`，这种转换是安全的，因为`Derived`是`Base`的派生类。**但是如果试图将`Base`指针无条件地转换回`Derived`指针，可能会导致错误，因为`base_ptr`所指向的对象可能实际上不是`Derived`类型。**`static_cast`也可以用于基本数据类型之间的转换，**如将`int`转换为`float`等**。

4. **`dynamic_cast`**

- 概念
  - `dynamic_cast`主要用于在**继承层次结构中进行安全的向下转型**（将基类指针或引用转换为派生类指针或引用）。它在运行时进行类型检查，如果转换是不合法的（即基类指针实际上并不指向期望的派生类对象），则**返回`nullptr`（对于指针）或抛出`std::bad_cast`异常（对于引用）**。
- 示例与应用场景
  - 考虑一个具有继承关系的类层次结构：

```cpp
     #include <iostream>
     #include <exception>
     class Base {
     public:
         virtual ~Base() {}
     };
     class Derived : public Base {
     public:
         void derivedFunction() {
             std::cout << "Derived function called." << std::endl;
         }
     };
     int main() {
         Base* base_ptr = new Derived();
         Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);
         if (derived_ptr) {
             derived_ptr->derivedFunction();
         } else {
             std::cout << "Invalid cast." << std::endl;
         }
         Base* base_ptr2 = new Base();
         Derived* derived_ptr2 = dynamic_cast<Derived*>(base_ptr2);
         if (derived_ptr2) {
             derived_ptr2->derivedFunction();
         } else {
             std::cout << "Invalid cast." << std::endl;
         }
         return 0;
     }
```

- 在这个例子中，首先将`Derived`类的对象地址赋给`Base`指针`base_ptr`，然后通过`dynamic_cast`将`Base`指针转换为`Derived`指针`derived_ptr`。因为实际对象是`Derived`类型，所以转换成功，可以正常调用`Derived`类的函数。而当`base_ptr2`指向一个`Base`类对象时，`dynamic_cast`会判断出转换不合法，返回`nullptr`，从而避免了对错误类型对象进行操作。这种转换在处理多态对象，需要根据对象的实际派生类型进行不同操作的场景中非常有用，如在图形绘制系统中，根据不同的图形类型（圆形、矩形等派生类）进行不同的绘制操作。

### 56.  向上转型、向下转型

1. **向上转型（Upcasting）**
   - 概念
     - 向上转型是指将**派生类（子类）的指针或引用转换为基类（父类）的指针或引用。**在面向对象编程的继承层次结构中，这是一种自然且安全的操作，因为派生类对象本身也是基类对象的一种特殊情况。向上转型通常是**隐式进行的，不需要显式的类型转换操作符**（在某些情况下也可以显式使用`static_cast`）**。这种转型是安全且自然的**
   - 示例与解释
     - 考虑以下类层次结构，有一个基类`Vehicle`和一个派生类`Car`：

```cpp
     class Vehicle {
     public:
         void start() {
             std::cout << "Vehicle is starting." << std::endl;
         }
     };
     class Car : public Vehicle {
     public:
         void drive() {
             std::cout << "Car is driving." << std::endl;
         }
     };
```

- 向上转型的示例代码如下：

```cpp
     int main() {
         Car myCar;
         Vehicle* vehiclePtr = &myCar;  // 隐式向上转型，将Car*转换为Vehicle*
         Vehicle& vehicleRef = myCar;   // 隐式向上转型，将Car&转换为Vehicle&
         vehiclePtr->start();
         vehicleRef.start();
         return 0;
     }
```

- 在这个例子中，`myCar`是`Car`类的对象。当把`&myCar`赋值给`Vehicle*`类型的`vehiclePtr`，以及把`myCar`赋值给`Vehicle&`类型的`vehicleRef`时，就发生了向上转型。这种转型是安全的，因为`Car`类继承自`Vehicle`类，`Car`对象可以被看作是`Vehicle`对象。通过基类指针或引用调用`start`函数时，调用的是基类中定义的`start`函数，这是因为在编译时，编译器只知道这个指针或引用是基类类型，它根据基类的定义来确定调用的函数。

2. **向下转型（Downcasting）**

- 概念
  - 向下转型是与向上转型相反的操作，即将**基类（父类）的指针或引用转换为派生类（子类）的指针或引用。**这种操作相对复杂且具有一定风险，因为基类指针或引用所指向的对象不一定是期望的派生类对象。如果进行不恰当的向下转型，可能会导致程序运行时错误。
- 示例与解释
  - 继续使用上面的`Vehicle`和`Car`类的例子，假设我们有一个函数，它接受一个`Vehicle*`类型的参数，并且在函数内部我们希望将其转换为`Car*`来调用`Car`类特有的`drive`函数：

```cpp
     void driveIfCar(Vehicle* vehicle) {
         Car* car = dynamic_cast<Car*>(vehicle);
         if (car) {
             car->drive();
         } else {
             std::cout << "This vehicle is not a car." << std::endl;
         }
     }
     int main() {
         Vehicle vehicle;
         Car car;
         driveIfCar(&vehicle);
         driveIfCar(&car);
         return 0;
     }
```

- 在这个例子中，`driveIfCar`函数中的`dynamic_cast<Car*>(vehicle)`就是向下转型操作。**当`vehicle`指针实际指向的是`Vehicle`类对象（而不是`Car`类对象）时，`dynamic_cast`会返回`nullptr`，这样就避免了对错误类型对象进行`drive`函数的调用。如果使用`static_cast`进行向下转型，编译器不会检查这种类型错误，可能会导致程序出现未定义行为，如访问非法内存等情况。**因此，在进行向下转型时，通常优先使用`dynamic_cast`（对于引用类型的向下转型，`dynamic_cast`会抛出`std::bad_cast`异常来指示错误）来确保转型的安全性。

### 57. C++函数调用的压栈过程

> 参数求值后（从右往左）、下一条指令地址、局部变量

示例代码

- 以下是一个简单的 C++ 程序，包含一个函数调用，用于计算两个整数的和：

```cpp
   #include <iostream>
   int add(int a, int b) {
       int result = a + b;
       return result;
   }
   int main() {
       int num1 = 3;
       int num2 = 5;
       int sum = add(num1, num2);
       std::cout << "The sum is: " << sum << std::endl;
       return 0;
   }
```

**压栈过程详细分析（假设 32 位系统，__cdecl 调用约定）**

- **函数调用前的准备**

  - 当在 C++ 中调用一个函数时，首先要**确定被调用函数的地址**。编译器在**编译阶段已经确定了每个函数的入口地址**。对于非虚函数，这个地址是固定的；而对于**虚函数，通过虚函数表（vtable）**来确定实际要调用的函数版本（取决于对象的实际类型）。

  - 另外，在调用函数之前，需要把函数的参数进行求值。例如，如果有函数调用`func(a + b, c * d)`，那么**先计算`a + b`和`c * d`的值**。

- **参数求值与压栈**
  - 在`main`函数中调用`add(num1, num2)`时，首先对**参数进行求值**。`num1`的值为`3`，`num2`的值为`5`。按照**从右到左**的顺序压栈，种顺序有助于**支持可变参数函数（如`printf`函数），因为这样可以方便地通过栈指针的移动来访问各个参数**。先将`num2`（值为`5`）压入栈中，此时栈顶元素为`5`，栈指针（ESP）减`4`（假设`int`类型占 4 个字节）。然后将`num1`（值为`3`）压入栈中，栈顶元素变为`3`，栈指针再减`4`。此时栈的情况（从栈顶到栈底）为：`3`、`5`。
  - ![image-20241006104630927](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006104630927.png)
- **返回地址压栈**
  - 在参数压栈后，**将`main`函数中`add`函数调用后的下一条指令**（即`int sum = add(num1, num2);`这一行代码后的下一条指令）的地址压入栈中。这个返回地址用于函数`add`执行完后能够正确地返回到`main`函数继续执行。假设返回地址是`0x00401020`（这是一个示例地址），此时栈的情况（从栈顶到栈底）为：`0x00401020`、`3`、`5`。
- **函数`add`局部变量空间分配**
  - 当`add`函数开始执行时，它在栈上为自己的局部变量`result`分配空间。由于`int`类型占 4 个字节，栈指针（ESP）再减`4`，用于存放`result`的值。此时栈的情况（从栈顶到栈底）为：`[未初始化的result空间]`、`0x00401020`、`3`、`5`。
- **函数`add`执行过程中的栈操作**
  - 在`add`函数内部，计算`a + b`（即`3 + 5`），结果为`8`，将这个结果存储到`result`变量对应的栈空间中。此时栈的情况（从栈顶到栈底）为：`8`、`0x00401020`、`3`、`5`。
- **函数`add`返回时的栈清理和返回操作**
  - 当`add`函数执行完毕要返回时，首先要清理栈上为局部变量`result`分配的空间。通过将栈指针（ESP）加`4`来实现，此时栈的情况（从栈顶到栈底）为：`0x00401020`、`3`、`5`。
  - 然后从栈顶获取返回地址（`0x00401020`），并将其赋给程序计数器（EIP），使得程序能够返回到`main`函数中`add`函数调用后的下一条指令继续执行。
  - 最后，由于是__cdecl 调用约定，`main`函数（调用者）负责清理栈上的参数。通过将栈指针（ESP）加`8`（因为有两个`int`类型的参数，每个占 4 字节）来清除之前压入栈中的参数。此时栈恢复到`add`函数调用前的状态，`main`函数继续执行，将`add`函数返回的值（`8`）赋给`sum`变量，并输出结果。



- **数组情况**

  ```cpp
   #include <iostream>
     void printArray(int arr[], int size) {
         for (int i = 0; i < size; ++i) {
             std::cout << arr[i] << " ";
         }
         std::cout << std::endl;
     }
     int main() {
         int myArray[] = {1, 2, 3, 4, 5};
         int size = sizeof(myArray)/sizeof(myArray[0]);
         printArray(myArray, size);
         return 0;
     }
  ```

  - 参数压栈过程
    - 在`main`函数调用`printArray(myArray, size)`时，首先对参数进行求值。`size`的值为`5`（通过`sizeof(myArray)/sizeof(myArray[0])`计算得到），`myArray`被转换为**指向数组首元素的指针**。按照从右到左的顺序压栈，先将`size`（值为`5`）压入栈中，栈指针（ESP）减`4`（假设`int`类型占 4 个字节）。然后将`myArray`（实际上是一个指针，假设其值为`0x0012FF00`，这是数组首地址）压入栈中，栈指针再减`4`。此时栈的情况（从栈顶到栈底）为：`0x0012FF00`（`myArray`的指针值）、`5`（`size`的值）。
    - 函数内部操作
      - 在`printArray`函数中，`arr`实际上是一个指针，它接收了`main`函数中`myArray`的**首地址**。`printArray`函数可以通过这个指针和`size`参数来访问数组中的元素。在循环中，`arr[i]`的操作实际上是通过指针算术运算来实现的。例如，当`i = 1`时，`arr[1]`等价于`*(arr + 1)`，即**访问`arr`所指向地址偏移`1`个`int`类型大小（**假设`int`占 4 字节，偏移量为`4`字节）后的元素。

### 58. C++将临时变量作为返回值时的处理过程

![image-20241006105202698](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006105202698.png)

### 59. C++代码有一类错误是coredump，你遇到过吗

1. **什么是 Core Dump**
   - Core Dump（核心转储）是操作系统在进程异常终止（比如段错误、非法指令等）时，将进程当时的内存状态**记录到一个文件（Core 文件）中**的过程。这个文件包含了**进程的地址空间内容，包括代码、数据、栈和寄存器状态等信息**。在 C++ 中，Core Dump 通常是由于程序**访问了非法内存地址、栈溢出、堆损坏**等错误导致的。
2. **常见导致 Core Dump 的原因及示例**
   - **访问非法内存地址（空指针解引用）**
     - **原因**：当程序试图访问一个空指针所指向的内存区域时，就会发生空指针解引用，这是导致 Core Dump 的常见原因之一。
     - **示例**：

```cpp
       #include <iostream>
       int main() {
           int* ptr = nullptr;
           std::cout << *ptr << std::endl;  // 试图解引用空指针
           return 0;
       }
```

- 在这个例子中，`ptr`是一个空指针，当试图通过`*ptr`访问其所指向的内存区域时，就会引发段错误，导致程序 Core Dump。因为空指针并不指向任何有效的内存地址，这种访问是非法的。
- **数组越界访问**
  - **原因**：在 C++ 中，数组的访问是通过索引进行的。如果索引超出了数组的有效范围，就会访问到数组边界之外的内存区域，这可能导致 Core Dump。
  - **示例**：

```cpp
       #include <iostream>
       int main() {
           int arr[5];
           for (int i = 0; i <= 5; ++i) {  // 当i = 5时，数组越界访问
               arr[i] = i;
           }
           return 0;
       }
```

- 这个程序定义了一个大小为`5`的整数数组`arr`，但是在循环中，当`i`等于`5`时，`arr[i]`的访问超出了数组的范围，会访问到数组后面的非法内存区域，从而可能导致 Core Dump。
- **栈溢出**
  - **原因**：每个函数在调用时都会在栈上分配一定的空间用于存储局部变量、函数参数和返回地址等信息。如果一个函数的**递归调用过深或者局部变量占用的空间过大**，可能会导致栈空间耗尽，从而引发栈溢出，导致 Core Dump。
  - **示例**：

```cpp
       void recursiveFunction(int n) {
           int localVariable[1000];  // 假设这个数组导致栈空间占用过大
           if (n > 0) {
               recursiveFunction(n - 1);
           }
       }
       int main() {
           recursiveFunction(10000);  // 递归深度过深，可能导致栈溢出
           return 0;
       }
```

- 在这个例子中，`recursiveFunction`函数有一个较大的局部数组`localVariable`，并且函数进行了深度递归。随着递归的进行，栈上会不断地为每个函数调用分配空间来存储局部变量和其他信息，最终可能导致栈空间不够用，引发栈溢出和 Core Dump。

- **如何调试** Core Dump 文件

使用 GDB（GNU Debugger）

在 Linux 系统下，GDB 是一个强大的调试工具。可以使用`gdb`命令来调试 Core Dump 文件。例如，如果程序生成了一个名为`core`的 Core 文件，并且可执行文件名为`myprogram`，可以通过以下命令进行调试：

```plaintext
     gdb myprogram core
```

在 GDB 中，可以使用`bt`（backtrace）命令来查看程序崩溃时的函数调用栈，帮助定位导致 Core Dump 的函数位置。还可以使用`print`命令来查看变量的值，以进一步分析程序出错的原因。例如：

```plaintext
     (gdb) bt
     #0  0x00005555555547b4 in main () at test.cpp:4
     (gdb) print ptr
     $1 = (int *) 0x0
```

上述命令显示了程序崩溃在`main`函数的`test.cpp`文件的第`4`行，并且通过`print`命令查看了`ptr`的值，发现它是一个空指针，这有助于确定是空指针解引用导致了 Core Dump。

### 60. 如何获得结构成员相对于结构开头的字节偏移量

`< stddef.h>`头文件里的offsetof宏

```cpp
#include <iostream>
#include <stddef.h>
using namespace std;

struct S {
  int x;
  char y;
  int z;
  double a;
  int b;
  int c;
};
int main() {
  cout << offsetof(S, x) << endl; // 0
  cout << offsetof(S, y) << endl; // 4
  cout << offsetof(S, z) << endl; // 8
  cout << offsetof(S, a) << endl; // 16
  cout << offsetof(S, b) << endl; // 24
  cout << offsetof(S, c) << endl; // 28
  return 0;
}
```

- 对于`offsetof(S, a)`，结果为`16`
  - `z`是`int`类型占`4`字节，之后由于`double`类型（在很多系统中占`8`字节）的对齐要求，编译器可能会在`z`和`a`之间填充`4`字节，**使得`a`从一个能被`8`整除的地址开始存储**。所以`a`的偏移量是`8 + 4 + 4 = 16`字节。
- 对于`offsetof(S, b)`，结果为`24`
  - `a`是`double`类型占`8`字节，`b`是`int`类型。由于`int`类型在很多系统中占`4`字节，且`a`之后没有填充，所以`b`的偏移量是`16+8 = 24`字节。



```cpp
#include <iostream>
#include <stddef.h>
using namespace std;
// #pragma pack(4)
struct S {
  int x;
  char y;
  char t;
  double a;
  int z;

  int b;
  int c;
};
int main() {
  cout << offsetof(S, x) << endl; // 0
  cout << offsetof(S, y) << endl; // 4
  cout << offsetof(S, t) << endl; // 5
  cout << offsetof(S, a) << endl; // 8
  cout << offsetof(S, z) << endl; // 16
  cout << offsetof(S, b) << endl; // 20
  cout << offsetof(S, c) << endl; // 24
  return 0;
}

```



### 62. 引用能否实现动态绑定，为什么

1. **动态绑定（Dynamic Binding）**：动态绑定是在运行时根据对象的实际类型来确定要调用的函数或方法。在面向对象编程中，通常是通过**虚函数（在 C++ 等语言中）和虚函数表（vtable）机制**来实现的。
2. **引用可以实现动态绑定**
   - 原因分析
     - 在 C++ 中，当通过引用调用虚函数时，会发生动态绑定。因为引用可以绑定到派生类对象，并且和指针一样，当调用虚函数时，编译器会根据引用所绑定对象的实际类型来决定调用虚函数的具体版本。
     - 例如，考虑以下代码：

```cpp
     class Base {
     public:
         virtual void virtualFunction() {
             std::cout << "Base::virtualFunction" << std::endl;
         }
     };
     class Derived : public Base {
     public:
         void virtualFunction() override {
             std::cout << "Derived::virtualFunction" << std::endl;
         }
     };
     int main() {
         Derived derived;
         Base& baseRef = derived;
         baseRef.virtualFunction(); 
         return 0;
     }
```

- 在这个例子中，`Base& baseRef = derived;`创建了一个`Base`类的引用`baseRef`，并将其绑定到`Derived`类的对象`derived`上。**当通过`baseRef`调用`virtualFunction`时，由于`virtualFunction`是虚函数，会发生动态绑定，程序会根据`baseRef`所绑定对象（即`Derived`类的对象）的实际类型来调用`Derived::virtualFunction`，**而不是`Base::virtualFunction`。这就表明引用能够实现动态绑定，其原理和通过指针实现动态绑定类似，都是基于虚函数机制，在运行时根据对象的实际类型来确定函数调用的版本。

### 63. 全局变量和局部变量区别

> 内存存放位置就不一样，全局/静态存储区跟堆/栈能一样吗我想问问了

![image-20241006112315649](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006112315649.png)

### 64. 指针加减法要注意什么

指针类型的重要性

- 指针加减法的步长是根据指针的类型来确定的。例如，对于一个`int*`指针，当进行指针加法操作（如`p + 1`，其中`p`是`int*`类型）时，**指针实际增加的字节数是`sizeof(int)`。**这是因为指针的算术运算**是以所指向的数据类型为单位进行**的。
- 假设`int`类型在当前系统中占 4 个字节，如果有一个`int*`指针`p`，其初始值为地址`0x1000`，那么`p + 1`的结果是地址`0x1004`（在十六进制下），而不是简单地将地址值加 1。这种以数据类型大小为步长的运算方式确保了指针在遍历数组等数据结构时能够正确地指向相邻的同类型元素。

![image-20241006113724364](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006113724364.png)

### 65. 怎么判断两个浮点数是否相等

1. 浮点数的存储特性导致不能直接比较
   - 浮点数在计算机中的存储是基于二进制的科学计数法形式。由于浮点数的二进制表示可能无法精确地表示某些十进制小数，这就导致了在比较两个浮点数是否相等时，不能简单地使用`==`运算符。例如，十进制的`0.1`在二进制下是一个无限循环小数，计算机在存储时只能近似表示，所以如果直接比较两个理论上应该是`0.1`的浮点数，可能会因为存储的微小差异而得到不相等的结果。
2. 比较方法一：设定精度范围（误差范围）进行比较
   - **原理**：考虑到浮点数存储的近似性，**可以设定一个合理的精度范围（误差范围）**。如果两个浮点数的差值的绝对值在这个精度范围内，就认为它们是相等的。
   - **示例（以 C++ 为例）**：

```cpp
     #include <iostream>
     #include <cmath>
     bool areEqual(double num1, double num2, double tolerance = 1e-9) {
         // 记得使用绝对值
         return std::fabs(num1 - num2) < tolerance;
     }
     int main() {
         double a = 0.1 + 0.1 + 0.1;
         double b = 0.3;
         if (areEqual(a, b)) {
             std::cout << "a and b are considered equal." << std::endl;
         } else {
             std::cout << "a and b are not equal." << std::endl;
         }
         return 0;
     }
```

- 在这个例子中，定义了一个函数`areEqual`，它接受两个浮点数`num1`和`num2`，以及一个可选的精度参数`tolerance`（默认值为`1e - 9`）。通过计算`std::fabs(num1 - num2)`（即两个浮点数差值的绝对值）并与`tolerance`比较，如果小于`tolerance`，就认为两个浮点数相等。在`main`函数中，比较了`0.1 + 0.1 + 0.1`和`0.3`这两个浮点数，由于浮点数存储的近似性，它们在计算机中的实际值可能略有差异，但通过设定精度范围，可以合理地判断它们是否相等。

### 66. 方法调用的原理（栈、汇编）

1. **高级语言中的方法调用过程概述**
   - 在高级语言（如 C++、Java 等）中，当调用一个方法（函数）时，程序会暂停当前执行流程，将控制权转移到被调用的方法，方法执行完毕后再返回原执行点继续执行。这个过程涉及到多个步骤，包括参数传递、栈帧的创建和销毁、返回地址的保存与恢复等，这些操作的底层实现与栈和汇编语言密切相关。
2. **栈在方法调用中的作用（以 C++ 为例）**
   - 参数传递
     - **栈上压入参数**：在 C++ 中，参数传递方式有多种约定（如`__cdecl`、`__stdcall`等），以常见的`__cdecl`为例，参数从右到左依次压入栈中。例如，对于函数调用`func(a, b, c)`，先将`c`压入栈，然后是`b`，最后是`a`。这些参数在栈中的存储位置为后续方法内部对参数的访问提供了基础。
     - **参数的访问方式**：在被调用方法内部，通过相对于栈帧指针（如 ESP 或 RSP 寄存器在 32 位和 64 位系统中的栈指针）的偏移量来访问参数。编译器在生成汇编代码时，会根据参数的类型和位置计算出正确的偏移量，使得方法能够正确地获取传递进来的参数。
   - 栈帧的创建与管理
     - **栈帧的概念**：栈帧是一个方法在栈上的活动记录，包含了方法的局部变量、参数（对于某些调用约定）、返回地址等信息。当一个方法被调用时，会在栈上开辟一个新的栈帧。
     - **创建栈帧的操作（汇编层面）**：首先，将当前栈指针（ESP）减去一定的值，为栈帧预留足够的空间。这个空间用于存储局部变量和其他与方法执行相关的信息。例如，在 32 位系统中，如果方法有一些局部变量，编译器会计算这些局部变量所需的总字节数，然后通过`sub esp, <字节数>`这样的汇编指令来为栈帧分配空间。
     - **栈帧中的局部变量存储**：局部变量在栈帧中通过相对于栈帧指针的偏移量来存储和访问。编译器会在生成汇编代码时，根据变量声明的顺序和类型，确定每个局部变量在栈帧中的偏移量。例如，在一个方法中有`int local1; double local2;`，编译器会安排`local1`和`local2`在栈帧中的位置，并在汇编代码中通过正确的偏移量来访问它们，如`mov eax, [ebp - 4]`（假设`local1`在相对于栈帧基址`ebp`偏移`-4`字节的位置）来获取`local1`的值。
   - 返回地址的保存与恢复
     - **保存返回地址**：在方法调用时，当前指令的下一条指令（即方法调用结束后要返回执行的指令）的地址会被压入栈中。这个返回地址的保存是通过`call`指令自动完成的。在汇编语言中，`call`指令会将下一条指令的地址（返回地址）压入栈，然后跳转到被调用方法的入口地址。
     - **恢复执行流程（返回操作）**：当方法执行完毕要返回时，会从栈顶获取返回地址，并将其赋给程序计数器（EIP 或 RIP 在 32 位和 64 位系统中），使得程序能够返回到调用点继续执行。这个过程通常通过`ret`指令来实现，`ret`指令会从栈顶弹出返回地址，并将程序控制转移到该地址。
3. **汇编语言层面的方法调用细节**
   - 函数调用指令（`call`）
     - 当在高级语言中调用一个函数时，编译器会生成`call`指令。例如，在 32 位 x86 汇编中，`call`指令的操作数是被调用函数的地址。`call`指令执行时，首先将当前的 EIP（指令指针）的值（即下一条指令的地址）压入栈中，这个地址就是返回地址。然后，EIP 被设置为被调用函数的入口地址，从而实现控制权的转移。
   - 函数返回指令（`ret`）
     - 当函数执行完毕要返回时，会执行`ret`指令。`ret`指令的作用是从栈顶弹出一个值（这个值就是之前`call`指令压入栈中的返回地址），并将 EIP 设置为这个弹出的值，使得 CPU 能够返回到调用函数的下一条指令继续执行。在有些情况下，`ret`指令还可以带有一个操作数，用于在返回时调整栈指针，以清除栈上为函数参数等预留的空间，具体取决于函数调用约定。
   - 参数传递和局部变量访问的汇编表示
     - 对于参数传递，如前面所述，以`__cdecl`调用约定为例，参数从右到左压入栈中。在汇编代码中，可以看到类似`push <参数值>`的指令来完成参数的压栈操作。对于局部变量的访问，通过相对于栈帧指针（如`ebp`或`rsp`）的偏移量来实现。例如，`mov eax, [ebp - 8]`这样的指令可能是在访问一个相对于栈帧基址偏移`-8`字节的局部变量，并将其值加载到`eax`寄存器中。

### 67. C++中的指针参数传递和引用，底层原理是什么

> 指针传递本质是值传递，引用传递传递的是真正的变量



1. **语法区别**
   - **指针参数传递**：在函数参数列表中，指针变量作为参数传递时，需要使用`*`来声明指针类型。例如，`void func(int* ptr)`，在调用函数时，需要传递变量的地址，像`int num = 5; func(&num);`。在函数内部，通过解引用指针（`*ptr`）来访问和修改所指向的变量。
   - **引用参数传递**：函数参数列表中，引用类型使用`&`来声明，如`void func(int& ref)`。在调用函数时，直接传递变量本身，如`int num = 5; func(num);`。在函数内部，使用引用名（`ref`）就如同直接使用原始变量一样，可以访问和修改它。
2. **底层原理区别**
   - 指针参数传递的底层原理
     - **内存操作层面**：当指针作为参数传递时，实际上是**将变量的内存地址复制一份传递给函数**。在 32 位系统中，这个地址占 4 个字节，在 64 位系统中占 8 个字节。例如，对于函数`void func(int* ptr)`，当调用`func(&num)`时，`&num`（`num`的地址）的值被压入栈中传递给函数。在函数内部，编译器通过这个地址来生成访问内存的机器指令，`*ptr`操作会根据存储在`ptr`中的地址去访问对应的内存位置。
     - **函数栈帧角度**：从函数栈帧来看，指针参数在栈上占用一定的空间来存储地址。每次对指针所指向内容的访问，都需要通过这个存储的地址进行间接访问。如果函数内部修改了指针的值（即改变了它所存储的地址），这不会影响到原始指针变量（在函数外部定义的那个指针），因为函数只是复制了地址的值进行操作。
   - 引用参数传递的底层原理
     - **别名机制**：引用在底层可以看作是被引用对象的别名。在编译器实现层面，引用可能是通过指针来模拟的，但在语法层面对程序员隐藏了这种间接性。当定义`int& ref = num;`时，`ref`和`num`在内存中共享相同的存储位置，编译器在处理引用时，会确保对`ref`的操作实际上就是对`num`的操作。
     - **编译器实现细节**：在函数调用过程中，对于引用参数传递，编译器可能会将引用转换为指针传递，但这种转换对程序员是透明的。例如，对于函数`void func(int& ref)`，调用`func(num)`时，编译器可能会在内部将其当作`func(&num)`来处理，不过在函数内部访问`ref`就像直接访问原始变量一样。引用参数在栈帧中可能不会像指针那样有明显的存储地址的空间占用（这取决于编译器实现），因为它本质上是和原始变量绑定在一起的。

### 68. 类如何实现只能静态分配和只能动态分配

- 静态分配

静态分配是指在程序**编译期间**就确定了内存空间的分配方式。对于变量而言，编译器在编译时就为其分配了固定的内存地址和大小，这些内存空间在程序运行的整个过程中都是固定不变的。

- 动态分配

动态分配是指在程序**运行**期间，**根据程序的实际需求动态地申请和释放内存空间**。这种分配方式允许程序更加灵活地使用内存，因为内存的分配和释放时间不是在编译阶段确定的，而是在程序运行过程中根据具体的条件和操作来决定。

**可以使用`new[]`来动态分配数组**，例如`int* arr_ptr = new int[10];`，这会在堆上为一个包含 10 个`int`元素的数组分配内存空间。释放这个数组时，需要使用`delete[]`，如`delete[] arr_ptr;`。这种动态分配数组的方式可以根据程序运行时的实际需求来确定数组的大小，而不像静态分配数组那样，数组大小必须在编译时确定。



1. **只能静态分配的类实现**
   - 原理
     - 要实现一个类只能进行静态分配，需要将**类的构造函数声明为`private`（私有）**。这样就禁止了在类的外部通过`new`操作符进行动态分配，因为`new`操作需要调用构造函数来初始化对象，而外部无法访问私有构造函数。同时，提供一个`public`（公共）的静态成员函数来返回类的静态对象，这样就只能通过这个静态函数来获取类的实例，实现静态分配。
   - **示例（以 C++ 为例）**

```cpp
     class StaticOnly {
     private:
         StaticOnly() {}  // 私有构造函数，禁止外部直接构造对象
     public:
         static StaticOnly& getInstance() {
             static StaticOnly instance;  // 静态局部变量，在第一次调用时初始化
             return instance;
         }
     };
```

- 在这个例子中，`StaticOnly`类的构造函数是私有的。外部代码不能使用`new`来创建`StaticOnly`类的对象，也不能直接调用构造函数。通过提供`getInstance`静态函数，外部代码可以获取`StaticOnly`类的唯一实例。这个实例是一个静态局部变量，在第一次调用`getInstance`函数时创建，并且在整个程序的生命周期内只创建一次。这种方式实现了类的静态分配，**并且保证了只有一个实例存在（单例模式的一种简单实现）。**
- 使用场景
  - **配置管理类**：在一个应用程序中，**配置信息**通常全局唯一。例如，一个游戏应用可能有一个`GameConfig`类来存储游戏的**屏幕分辨率、音效音量、难度级别等配置参数**。将`GameConfig`类设计为只能静态分配，确保整个游戏过程中只有一份配置信息。通过静态分配的方式，可以方便地在任何需要读取或修改配置的地方访问这个唯一的配置实例，如在游戏场景切换、角色升级等模块中获取配置参数。
  - **日志记录类**：用于记录应用程序运行过程中的各种信息，如错误信息、操作记录等。以`Logger`类为例，将其设计为只能静态分配，就可以在程序的各个部分（如不同的函数、不同的类中）方便地调用日志记录功能。这样，所有的日志记录操作都通过同一个`Logger`实例完成，保证了日志记录的一致性和集中管理。

2. **只能动态分配的类实现**

- 原理
  - 要使类只能动态分配，需要将类的**析构函数声明为`private`。**这样，当对象在栈上自动分配时（如通过定义局部变量），在对象生命周期结束时，编译器会自动调用析构函数来销毁对象，但是由于析构函数是私有的，外部无法访问，所以这种**自动销毁操作就无法进行，从而禁止了对象在栈上的静态分配**。同时，需要提供一个`public`的静态成员函数来负责销毁对象，以便正确地释放动态分配的内存。
- **示例（以 C++ 为例）**

```cpp
     class DynamicOnly {
     public:
         DynamicOnly() {}
         void destroy() {
             delete this;  // 负责销毁对象
         }
     private:
         ~DynamicOnly() {}  // 私有析构函数，禁止栈上自动分配
     };
```

- 在这个`DynamicOnly`类中，析构函数是私有的。**这意味着不能像`DynamicOnly obj;`这样在栈上创建对象，因为在对象生命周期结束时编译器无法调用私有析构函数来销毁对象**。可以通过`new`操作符来动态创建对象，**例如`DynamicOnly* ptr = new DynamicOnly();`，并且需要通过`ptr->destroy();`来手动调用`destroy`函数来释放对象所占用的内存，`destroy`函数内部通过`delete this`来实现对象的销毁。这种方式实现了类只能动态分配。**不过这种实现方式需要谨慎使用，因为`delete this`操作如果使用不当可能会导致程序出现错误，例如在对象的成员函数中使用`delete this`后，不能再访问对象的其他成员，否则会产生未定义行为。
- **对象生命周期需要精细控制的类**
  - **具有复杂初始化和清理过程的类**：例如，一个`NetworkSocket`类，用于网络通信中的套接字操作。它的初始化可能涉及到网络协议的设置、端口绑定等复杂操作，而清理过程需要正确地关闭套接字、释放相关的网络资源。将`NetworkSocket`类设计为只能动态分配，在对象创建时（通过`new`操作）可以进行完整的初始化流程，在对象销毁时（通过自定义的销毁函数）可以确保所有的网络资源都被正确地清理，避免资源泄漏和网络异常。
  - **大型数据结构类（如矩阵类）**：对于一些大型的数据结构，如`Matrix`类（用于存储和操作大型矩阵数据），如果在**栈上静态分配可能会导致栈溢出**。将其设计为只能动态分配，可以根据实际需要在堆上分配足够的内存空间来存储矩阵数据。并且，通过提供自定义的销毁函数，可以确保在不再需要矩阵对象时正确地释放内存。

### 69. 如何将某个类用作基类，为什么该类必须定义而非声明

> 需要分配内存

- **内存布局和对象大小确定**：当一个类被用作基类时，编译器需要知道基类的完整结构来确定派生类的内存布局。如果只是声明一个类，编译器只知道类的名字和它是一个类类型，但不知道类的成员变量的大小、排列顺序以及成员函数（特别是虚函数，涉及到虚函数表的布局）等信息。例如，如果基类有一个成员变量，**派生类在继承后，编译器需要知道这个成员变量在内存中的位置和大小，以便正确地安排派生类的内存布局**。如果基类没有定义，就无法确定这些信息，从而无法正确地构建派生类的对象。

### 70. #pragma push(n)

1. **未使用`#pragma pack`时 struct 的大小计算**

   - **基本规则**：在没有`#pragma pack`指令干扰的情况下，结构体的大小是其成员按照各自对齐要求（通常是成员类型大小的倍数）占用空间之和，同时考虑成员之间可能的填充字节。

   - 示例

     - 考虑结构体

       ```
       struct S1 { char c; int i; };
       ```

       - `char`类型成员`c`通常占 1 字节，它的起始地址可以是任意位置。但由于`int`类型（假设占 4 字节）成员`i`的对齐要求是 4 字节对齐，所以编译器会在`c`之后填充 3 字节，使得`i`的起始地址是 4 的倍数。这样，`S1`结构体的大小是`1 + 3 + 4 = 8`字节。

     - 再看结构体

       ```
       struct S2 { int i; double d; };
       ```

       - `int`类型（假设占 4 字节）成员`i`的起始地址是 4 的倍数，`double`类型（假设占 8 字节）成员`d`的对齐要求是 8 字节对齐，其起始地址也是 4 的倍数，所以不需要填充。结构体`S2`的大小是`4 + 8 = 12`字节。

2. **使用`#pragma pack(n)`后 struct 的大小计算**

   - **根据指定对齐值计算**：当使用`#pragma pack(n)`指令后，结构体大小的计算按照`n`字节的对齐边界进行。每个成员的起始地址是`n`和该成员自身大小（以字节为单位）中较小值的倍数。结构体的大小是最后一个成员的结束地址（考虑对齐）相对于结构体起始地址的偏移量。

   - 示例

     ```
     #pragma pack(1)
     ```

     - 考虑结构体

       ```
       struct S3 { char c; int i; };
       ```

       - 因为是按 1 字节对齐，成员之间不需要填充，结构体大小就是成员大小之和，即`1 + 4 = 5`字节。

     ```
     #pragma pack(2)
     ```

     - 考虑结构体

       ```
       struct S4 { char c; int i; };
       ```

       - `char`类型成员`c`占 1 字节，起始地址符合 1 字节对齐（也满足 2 字节对齐）。`int`类型成员`i`（假设占 4 字节），其起始地址需要是 2 和 4 中较小值（即 2）的倍数。所以在`c`后面填充 1 字节，使得`i`的起始地址是 2 的倍数。结构体`S4`的大小为`2 + 4 = 6`字节。

![image-20241006132420946](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006132420946.png)

```cpp
#include <iostream>
#include <stddef.h>
using namespace std;
#pragma pack(4)
struct S {
  int x;
  char y;
  char t;
  double a;
  int z;

  int b;
  int c;
};
int main() {
  cout << offsetof(S, x) << endl; // 0
  cout << offsetof(S, y) << endl; // 4
  // 是1和4的最小值
  cout << offsetof(S, t) << endl; // 5
  cout << offsetof(S, a) << endl; // 8
  cout << offsetof(S, z) << endl; // 16
  cout << offsetof(S, b) << endl; // 20
  cout << offsetof(S, c) << endl; // 24
  // 是4和8中的最小值的整数倍
  cout << sizeof(S) << endl; // 28
  return 0;
}

#include <iostream>
#include <stddef.h>
using namespace std;
struct S {
  int x;
  char y;
  char t;
  double a;
  int z;

  int b;
  int c;
};
int main() {
  cout << offsetof(S, x) << endl; // 0
  cout << offsetof(S, y) << endl; // 4
  cout << offsetof(S, t) << endl; // 5
  cout << offsetof(S, a) << endl; // 8
  cout << offsetof(S, z) << endl; // 16
  cout << offsetof(S, b) << endl; // 20
  cout << offsetof(S, c) << endl; // 24
  // 是最大值8的整数倍
  cout << sizeof(S) << endl;      // 32
  return 0;
}


#include <iostream>
#include <stddef.h>
using namespace std;
#pragma pack(4)
struct S {
  int x;
  char y;
  int z;
  double a;
  char t;
  int b;
  int c;
};
int main() {
  cout << offsetof(S, x) << endl; // 0
  cout << offsetof(S, y) << endl; // 4
  cout << offsetof(S, z) << endl; // 8
  // 是4和8的最小值
  cout << offsetof(S, a) << endl; // 12
  cout << offsetof(S, t) << endl; // 20
  cout << offsetof(S, b) << endl; // 24
  cout << offsetof(S, c) << endl; // 28
  cout << sizeof(S) << endl;      // 32
  return 0;
}

```

### 71. 函数调用过程栈的变化，返回值和参数变量哪个先入栈

1. **返回值传递方式（与栈的关系）**
   - **返回值通常不在参数入栈阶段涉及栈操作**：**返回值一般不是和参数一起入栈的**。对于返回值，不同的数据类型有不同的处理方式。
   - **简单数据类型（如`int`、`char`等）的返回值**：在大多数情况下，函数的返回值是**通过寄存器**传递的。例如，在 32 位系统中，`int`类型的返回值通常放在`EAX`寄存器中返回；在 64 位系统中，`int`类型返回值可能放在`RAX`寄存器中。这种方式比使用栈来传递返回值更快，因为**寄存器的访问速度比内存（栈是内存的一部分）快得多**。
   - **复杂数据类型（如结构体）的返回值**：如果函数返回一个较大的结构体，情况会比较复杂。一些编译器可能会**使用一个隐藏的指针参数（这个指针参数不是用户显式传递的），在调用函数之前，调用者在栈上分配一块足够大的空间用于存储返回的结构体**，然后将这个空间的指针作为隐藏参数传递给被调用函数。被调用函数将返回值填充到这个栈上的空间中。不过，这种方式也因编译器和具体实现而异。
2. **函数调用过程中栈的完整变化过程（以`__cdecl`调用为例）**
   - **参数入栈**：按照从右到左的顺序将参数压入栈中。例如，对于函数`int func(int a, int b, int c)`，如果调用`func(1, 2, 3)`，先将`3`压入栈，然后是`2`，最后是`1`。
   - **返回地址入栈**：在参数入栈后，当前指令（函数调用指令`call`）的下一条指令的地址（即函数调用结束后要返回执行的指令）会被压入栈。这是通过`call`指令自动完成的。
   - **栈帧建立**：被调用函数开始执行时，会建立自己的栈帧。这包括将栈指针`ESP`（在 32 位系统中）或`RSP`（在 64 位系统中）减去一定的值，为局部变量和其他与函数执行相关的信息预留空间。
   - **函数执行过程中的栈操作**：在函数执行期间，可能会对栈上的参数进行访问，也可能会将局部变量压入栈中。例如，如果函数中有局部变量声明，会在栈帧内为这些局部变量分配空间。
   - **返回操作**：当函数执行完毕要返回时，首先将返回值（如果是简单数据类型，通过寄存器；如果是复杂数据类型，按照前面提到的方式）准备好。然后通过`ret`指令从栈顶弹出返回地址，并将程序控制转移到该地址，同时可能会根据调用约定清理栈（在`__cdecl`调用约定下，调用者负责清理栈）。



### 72. 模板是什么？为什么模板类都是放在一个h文件中

1. **模板的基本概念**
   - 在编程领域，模板是一种用于创建通用代码的工具。它允许程序员编写可以处理多种数据类型（在 C++ 等语言中）或多种业务逻辑（在一些模板引擎中）的代码，而不必为每种可能的情况都编写重复的代码。以 C++ 为例，模板分为函数模板和类模板。
   - **函数模板**：是一种对函数的抽象，它可以用来生成针对不同类型参数的函数。例如，一个简单的函数模板可以用于交换两个变量的值，不管这两个变量是整数、浮点数还是其他类型。其语法形式大致是：`template <typename T> void swap(T& a, T& b) { T temp = a; a = b; b = temp; }`。这里的`T`是一个模板参数，它可以代表任何数据类型。当编译器在代码中遇到`swap`函数的调用时，它会根据实际传入的参数类型来确定`T`的值，然后生成相应的函数代码。
   - **类模板**：类似于函数模板，是对类的一种抽象。它允许定义一个类的框架，其中某些成员（如成员变量或成员函数）的类型可以在使用类模板时再确定。例如，一个简单的类模板可以是一个动态大小的数组类，其中数组元素的类型可以是任意的。语法上，它可能像这样：`template <typename T> class Array { T* data; int size; public: Array(int n); ~Array(); T& operator[](int index); };`。在这个类模板中，`T`是模板参数，`data`成员变量和`operator[]`等成员函数的类型都依赖于`T`。
2. **模板的用途和优势**
   - **代码复用性**：模板极大地提高了代码的复用性。通过编写通用的模板代码，程序员可以在不同的数据类型或场景下使用相同的代码逻辑。例如，在 C++ 标准库中，`std::vector`是一个类模板，它可以用来创建存储不同类型元素的动态数组，如`std::vector<int>`用于存储整数，`std::vector<double>`用于存储双精度浮点数等。这避免了为每种数据类型都编写一个类似的数组类，减少了代码量和维护成本。
   - **类型安全性**：模板在编译期间进行类型检查，确保只有合适的数据类型可以用于特定的模板实例。这与一些其他的泛型编程方法（如使用`void*`指针来实现通用代码）不同，后者可能会导致运行时的类型错误。在模板中，编译器会根据实际使用的类型来验证代码是否合法。例如，对于前面提到的`swap`函数模板，如果试图交换一个整数和一个字符串，编译器会发出错误提示，因为模板参数`T`在同一函数调用中被要求是相同的类型。
   - **灵活性和可扩展性**：模板提供了高度的灵活性。程序员可以根据具体的需求定制模板参数，甚至可以使用多个模板参数来创建更复杂的模板。而且，模板可以与其他编程特性（如继承、多态等）相结合，进一步扩展其应用范围。例如，可以创建一个继承自某个类模板的新类，或者在一个多态的场景中使用类模板来处理不同类型的对象。
3. **模板的工作原理（以 C++ 为例）**
   - **编译时实例化**：模板是一种编译期的机制。当编译器遇到模板的定义时，它并不会立即生成实际的代码。只有当模板在代码中被实例化（即具体的模板参数被确定）时，编译器才会根据模板定义和模板参数生成相应的代码。例如，当代码中出现`std::vector<int> myVector;`这样的语句时，编译器会根据`std::vector`类模板的定义和`int`这个模板参数，生成一个用于处理整数类型的`std::vector`类的代码。
   - **模板参数推导（对于函数模板）**：在函数模板的情况下，编译器可以根据函数调用时传入的实际参数类型来推导模板参数。例如，对于`swap`函数模板，如果调用`swap(x, y)`，其中`x`和`y`是整数，编译器会自动推导出`T`为`int`，然后生成一个`swap`函数的实例，其参数类型为`int&`。如果没有足够的信息来推导模板参数，或者推导的结果不唯一，程序员可能需要显式地指定模板参数。

> 放在头文件好处

1. 头文件包含模板定义的好处
   - **确保模板实例化正确进行**：将模板类放在头文件（`.h`文件）中，**当包含这个头文件的源文件需要使用模板时，编译器可以在同一个编译单元内看到模板的完整定义，从而能够正确地进行模板实例化**。例如，当一个源文件包含了一个模板类的头文件并使用了这个模板类（通过实例化模板参数），编译器可以立即根据模板定义和提供的参数生成相应的代码，不会出现因为找不到模板定义而无法实例化的情况。
   - **便于代码复用和维护**：模板类通常是为了实现通用的代码结构，将其放在头文件中可以方便其他代码使用。头文件就像是模板类的接口，其他代码只需要包含这个头文件，就可以根据需要实例化和使用模板类，这种方式符合模块化和代码复用的原则。而且，当需要修改模板类的定义时，只需要修改头文件中的内容，所有包含这个头文件的源文件在重新编译时都能够获取到更新后的模板定义，便于代码的维护。
2. 避免模板类定义和使用分离可能产生的错误示例
   - 假设模板类`TemplateClass`的定义在`.cpp`文件中，而在另一个`.cpp`文件中使用这个模板类。当编译器编译第一个`.cpp`文件时，它并不知道模板类会如何被实例化，所以不会生成具体的代码。当编译第二个`.cpp`文件时，由于找不到模板类的完整定义，编译器无法进行模板实例化。在链接阶段，链接器会发现找不到模板类实例化后的代码，从而导致链接错误。将模板类放在头文件中可以避免这种情况，因为编译器在编译包含头文件的源文件时能够看到模板类的完整定义，及时进行模板实例化并生成正确的代码。

### 73. cout和printf区别

### 74. 全局变量与static变量区别

作用域不同：静态全局变量**仅在定义该变量的源文件内生效**

### 75. static函数与普通函数的区别

1. **作用域方面的区别**
   - **普通函数**：普通函数的作用域是整个程序文件（在 C 和 C++ 中，如果函数没有被声明为`static`，默认是全局作用域）。这意味着**在一个文件中定义的普通函数可以被其他文件通过正确的声明和链接访问**。例如，在一个 C 语言项目中有`main.c`和`util.c`两个文件，如果在`util.c`中定义了一个普通函数`void utilFunction()`，可以在`main.c`中通过在`main.c`文件头部声明`extern void utilFunction();`，然后就可以在`main.c`的`main`函数或者其他函数中调用`utilFunction`。
   - **`static`函数**：`static`函数的作用域被**限制在它所在的文件内部**。**这里的限制在内部指的是非成员函数**，这是`static`函数的一个重要特性，它就像是一个文件内部的私有函数。例如，在`util.c`文件中定义了`static void staticUtilFunction()`，这个函数不能被其他文件访问，即使在其他文件中进行声明也不行。它只能在`util.c`文件内部的函数中被调用，这种限制作用域的方式有助于封装文件内部的功能，避免函数名冲突和不必要的外部访问。
2. **生命周期方面的区别**
   - **普通函数**：普通函数的生命周期是从程序开始运行到程序结束。在整个程序运行期间，函数的代码存储在内存的代码段中，随时等待被调用。只要程序在运行，函数就一直存在，它所占用的代码空间不会被释放。例如，一个复杂的图形绘制程序中有一个绘制圆形的函数，只要程序在运行，这个绘制圆形的函数的代码就一直存在于内存中，无论它是否正在被调用。
   - **`static`函数**：**`static`函数的生命周期和普通函数一样**，从程序开始运行到程序结束。因为`static`函数主要是限制了作用域，而不是生命周期。**它的代码同样存储在内存的代码段中，在程序运行期间一直存在，等待在其作用域内（即所在文件）被调用**。
3. **存储方式和链接属性方面的区别**
   - **普通函数**：普通函数在编译后，其符号（函数名）在目标文件中有**外部链接属性**（在 C 和 C++ 中默认情况）。这意味着在链接阶段，链接器可以将不同文件中的函数引用和函数定义进行连接。例如，在前面提到的`main.c`和`util.c`文件的例子中，`util.c`中的普通函数`utilFunction`在编译后的目标文件`util.o`中有外部链接属性，链接器可以根据`main.c`中的引用将其链接进来。
   - **`static`函数**：`static`函数在编译后，其符号（函数名）在目标文件中有**内部链接属性**。这使得`static`函数的符号只能在其所在的目标文件内部被解析，不能被其他目标文件引用。这种内部链接属性是通过编译器在编译阶段将`static`函数的符号标记为局部符号来实现的，从而保证了`static`函数的作用域限制在其所在文件内部。

### 76. 定义和声明的区别

> 一句话：分不分配内存空间

1. **定义（Definition）**
   - 变量定义
     - 变量定义是为变量分配存储空间并可能对其进行初始化的操作。在 C、C++ 等语言中，例如`int a = 10;`，这不仅声明了变量`a`的类型为`int`，**还为`a`分配了内存空间（通常在栈上）**，并且将其初始化为 10。**变量定义在整个程序中只能出现一次**（对于同一个变量），因为重复定义会导致编译器错误，例如在同一个作用域内多次定义`int a;`是不允许的。
     - 从内存角度看，当定义一个变量时，系统会根据变量的类型为其分配一定大小的内存空间。例如，定义一个`double`类型的变量，在 32 位系统中通常会分配 8 字节的内存空间来存储该变量的值。
   - 函数定义
     - 函数定义包含了函数体，即函数要执行的具体操作。它明确了函数的参数类型、返回值类型以及函数内部的代码逻辑。例如，在 C++ 中，`int add(int a, int b) { return a + b; }`是一个函数定义。它指定了函数名为`add`，参数是两个`int`类型的变量`a`和`b`，返回值是一个`int`类型的值，并且详细说明了函数体是将`a`和`b`相加并返回结果。
     - 函数定义在编译后会生成相应的机器指令，这些指令存储在内存的代码段中。当函数被调用时，程序会跳转到该函数对应的代码段执行相应的操作。
2. **声明（Declaration）**
   - 变量声明
     - 变量声明主要是告诉编译器变量的类型和名称，**但不会为其分配存储空间**。它的作用是**使编译器知道该变量在其他地方已经定义或者即将定义**。例如，在 C 语言中，`extern int a;`是一个变量声明。这表示变量`a`是一个`int`类型的变量，它的定义在其他地方（可能在另一个源文件中）。变量声明可以在程序中出现多次，用于在不同的文件或者不同的作用域内引用同一个变量。
     - 声明就像是给编译器一个 **“提示”**，让编译器在编译过程中知道如何处理该变量的引用。例如，在一个大型项目中，可能有多个源文件都需要使用同一个全局变量，在每个需要使用该变量的源文件中进行声明，就可以让编译器正确地处理变量的引用，而不用担心变量的具体定义位置。
   - 函数声明
     - 函数声明主要是向编译器提供函数的名称、返回值类型和参数类型的信息，但不包含函数体。例如，在 C++ 中，`int add(int, int);`是一个函数声明。它告诉编译器有一个名为`add`的函数，返回值是`int`类型，有两个`int`类型的参数。函数声明的作用是让编译器在遇到函数调用时能够检查调用是否正确，包括参数类型是否匹配、返回值是否正确处理等。
     - 与变量声明类似，**函数声明可以在多个地方出现**，方便在不同的文件或者函数中引用某个函数。例如，在一个头文件中声明一个函数，然后多个源文件可以包含这个头文件，从而在这些源文件中都可以正确地调用这个函数。而且，函数声明可以帮助编译器在编译阶段进行类型检查，避免在链接阶段才发现函数调用错误的情况。

### 77. 静态成员和普通成员的区别

静态成员**在类被加载就一直存在**，不需要实例化

静态成员变量的生命周期从**程序开始运行到程序结束**。它在程序启动时就被初始化（如果没有显式初始化，会有默认的初始化规则），并且在整个程序运行期间一直存在，因为它是被类的所有对象共享的全局资源。

### 78. ifdef endif代表什么

1. **控制代码的编译范围**

   - **避免不必要的编译**：`ifdef`和`endif`组合可以让开发者精确地控制哪些代码参与编译过程。在大型项目中，可能存在大量针对特定平台、特定配置或者特定功能模块的代码。通过使用`ifdef`，可以在不同的编译环境下，只编译需要的代码部分，从而减少编译时间和生成的可执行文件的大小。
   - **示例**：在一个同时支持图形用户界面（GUI）和命令行界面（CLI）的软件项目中，有大量分别用于 GUI 和 CLI 的代码。可以定义一个宏（如`GUI_ENABLED`），当构建 GUI 版本的软件时定义这个宏，使得`ifdef GUI_ENABLED`和`endif`之间的 GUI 相关代码被编译，而 CLI 相关代码（被`ifndef GUI_ENABLED`等条件控制）在这种情况下不被编译。

2. **区分不同版本的功能**：在软件的开发和发布过程中，不同版本可能有不同的功能集。`ifdef`和`endif`可以用于在代码中根据版本定义来控制功能的编译。

   **示例**：对于一个软件的免费版和付费版，付费版有更多高级功能。可以定义一个宏（如`PAID_VERSION`），在付费版构建时定义这个宏。然后，高级功能的代码可以放在`ifdef PAID_VERSION`和`endif`之间，这样在构建免费版时，这些高级功能代码不会被编译。

3. **避免重定义错误**：![image-20241006150616630](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006150616630.png)

### 79. 隐式转换是什么，如何消除隐式转换

![image-20241006150909152](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006150909152.png)

### 80. strcpy和memcpy的区别是什么

1. **用途场景**：适用于处理以`\0`结尾的字符串复制操作。在文本处理、字符串操作相关的程序中经常用到，比如复制用户输入的字符串、复制配置文件中的字符串等。
   - `memcpy`函数（以 C 语言为例）
     - **功能**：`memcpy`是一个更通用的内存复制函数。它从源内存地址复制指定数量的字节到目标内存地址。例如，`char dest[20]; char src[] = "Hello"; memcpy(dest, src, sizeof(src));`，这里是将`src`中的内容（长度为`sizeof(src)`字节）复制到`dest`中。
     - **用途场景**：用于**复制任何类型的内存块**，不仅仅局限于字符串。可以用于复制结构体、数组等各种数据结构。比如在网络编程中复制网络数据包，或者在图形编程中复制图像数据等。
2. **参数和行为特点方面的区别**
   - 参数类型和意义
     - **`strcpy`**：它的参数是两个字符指针（`char *`），分别指向源字符串和目标字符串。函数会自动在复制过程中寻找源字符串的结束符`\0`来确定复制的长度，直到遇到`\0`并将其也复制到目标字符串后才停止。
     - **`memcpy`**：参数是目标内存地址（`void *`）、源内存地址（`void *`）和要复制的字节数（`size_t`）。需要程序员明确指定要复制的字节数，不会自动寻找结束符`\0`。
   - 复制行为和潜在风险
     - **`strcpy`**：由于依赖`\0`来确定复制长度，如果目标字符串空间不够大，无法容纳源字符串（包括`\0`），就会导致缓冲区溢出，这是一个严重的安全隐患，可能会覆盖其他内存区域的数据，导致程序崩溃或者出现不可预期的行为。
     - **`memcpy`**：如果指定的要复制的字节数超过目标内存区域的大小，也会导致缓冲区溢出。但因为它不依赖`\0`，在复制非字符串数据（如结构体、数组等）时，更能准确地按照程序员指定的长度进行复制，只要字节数指定正确，就可以避免一些`strcpy`可能出现的问题。
3. **返回值方面的区别**
   - **`strcpy`**：通常返回目标字符串的指针，这样可以方便地进行链式调用或者在复制后对目标字符串进行其他操作。例如，`char *result = strcpy(dest, src);`，可以直接使用`result`来访问目标字符串。
   - **`memcpy`**：返回**目标内存地址的指针**，这也便于后续对复制后的内存区域进行操作。例如，`void *result = memcpy(dest, src, sizeof(src));`，同样可以通过`result`来引用复制后的目标内存区域。

### 81. 如何在不使用额外空间的情况下，交换两个数

**一、使用算术运算**

1. 利用加法和减法：
   - 假设要交换的两个数为 `a` 和 `b`。
   - 可以先将两数之和存入其中一个变量，即 `a = a + b`。
   - 然后用新的 `a` 减去原来的 `b` 赋给 `b`，即 `b = a - b`。
   - 最后用新的 `a` 减去新的 `b` 赋给 `a`，即 `a = a - b`。

1. 利用乘法和除法（仅适用于两数乘积不为 0 的情况）：
   - `a = a * b`。
   - `b = a / b`。
   - `a = a / b`。

**二、使用位运算**

1. 异或（XOR）运算：

   - 异或运算具有以下性质：任何数与自身异或结果为 0，任何数与 0 异或结果为自身。并且异或运算满足交换律和结合律。
   - `a = a ^ b`。
   - `b = a ^ b`，此时 `b` 的值为原来 `a` 的值，因为 `a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a`。
   - `a = a ^ b`，此时 `a` 的值为原来 `b` 的值，因为 `a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`。

   例如：

```c
   int a = 3, b = 7;
   a = a ^ b;
   b = a ^ b;
   a = a ^ b;
```