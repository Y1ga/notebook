### 82. C++执行int main(int argc, char* argb[)是什么意思

1. `main`函数的基本概念
   - 在 C++ 中，`main`函数是程序的入口点。当一个 C++ 程序启动时，操作系统会调用`main`函数，程序从`main`函数的第一条语句开始执行。
2. `int argc`参数
   - `argc`是一个整数（`int`类型），它代表**命令行参数的数量**。这个数量包括程序本身的名称。例如，如果在命令行中执行`./myprogram arg1 arg2`，那么`argc`的值为 3。因为有 3 个命令行参数：程序名`./myprogram`以及另外两个参数`arg1`和`arg2`。
3. `char* argv[]`参数
   - `argv`是一个字符指针数组（`char*`类型的数组）。它用于**存储命令行参数的内容**。
   - `argv[0]`通常是程序的名称（包括路径等完整信息）。在上面的例子`./myprogram arg1 arg2`中，`argv[0]`指向字符串`"./myprogram"`，`argv[1]`指向字符串`"arg1"`，`argv[2]`指向字符串`"arg2"`。
   - 可以通过索引`argv`数组来访问各个命令行参数的内容，并且可以对这些参数进行处理，比如根据不同的参数执行不同的程序功能。以下是一个简单的示例代码，用于打印命令行参数：

```cpp
#include <iostream>
int main(int argc, char* argv[])
{
    for (int i = 0; i < argc; ++i)
    {
        std::cout << "argv[" << i << "]: " << argv[i] << std::endl;
    }
    return 0;
}
```

- 当你在命令行中执行这个程序，并传递一些参数时，程序会逐个打印出这些参数的内容和它们对应的索引。

这种带有命令行参数的`main`函数形式在很多场景下非常有用，比如编写可以接受用户输入选项的工具程序，像编译器程序可以接受源文件名称和编译选项等参数，根据这些参数来执行相应的编译操作。

### 83. 如果有一个空类，会添加哪些函数

> 默认构造函数、默认析构函数、默认拷贝构造函数、默认赋值运算符

```cpp
1)  Empty(); // 缺省构造函数//
2)  Empty( const Empty& ); // 拷贝构造函数//
3)  ~Empty(); // 析构函数//
4)  Empty& operator=( const Empty& ); // 赋值运算符//

```

### 85. const char* 与string的关系

string封装了char*

```cpp
a)  string转const char* 

string s = “abc”; 

const char* c_s = s.c_str(); 

b)  const char* 转string，直接赋值即可 

const char* c_s = “abc”; 
 string s(c_s); 

c)  string 转char* 
 string s = “abc”; 
 char* c; 
 const int len = s.length(); 
 c = new char[len+1]; 
 strcpy(c,s.c_str()); 

d)  char* 转string 
 char* c = “abc”; 
 string s(c); 

e)  const char* 转char* 
 const char* cpc = “abc”; 
 char* pc = new char[strlen(cpc)+1]; 
 strcpy(pc,cpc);

f)  char* 转const char*，直接赋值即可 
 char* pc = “abc”; 
 const char* cpc = pc;

```

### 86. 如何设计一个计算仅单个子类的对象个数

定义一个static静态变量做计数器，构造函数+1；**拷贝构造函数+1；复制构造函数+1；**析构函数-1；

### 87. 什么时候用引用/指针做传入参数

![image-20241006210539753](C:\Users\furina\AppData\Roaming\Typora\typora-user-images\image-20241006210539753.png)

### 88. strcpy、sprintf与memcpy函数的不同

### 89. 哪些函数可以是虚函数

**只有非静态成员函数、析构函数**可以是

**其他的静态成员函数、普通函数、构造函数、友元函数、内联函数都不行**

### 90. 模板类和模板函数的区别是什么

![image-20241006163911214](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006163911214.png)

### 91. 模板和实现可以不可以写在一个文件里面？为什么？

1. 在 C++ 中可以将模板和实现写在一个文件里
   - **原因在于模板的编译模型**：模板是一种在编译期生成代码的机制。当编译器遇到模板定义时，它不会立即为模板生成代码，而是在实例化模板（即使用模板创建具体类型的对象，如`MyTemplate<int> obj;`）时才生成代码。
   - **包含模型（inclusion model）**：如果把模板的声明和实现分开在不同的文件中，在链接阶段可能会出现问题。因为编译器在编译模板的声明文件（通常是头文件）时，没有足够的信息来生成具体的模板代码。当它在另一个文件（实现文件）中寻找模板的实现细节时，由于模板的编译特性，可能无法正确链接。而将模板和实现写在一个文件里，在包含这个文件的地方，编译器就能够获取完整的模板信息，在需要实例化模板时顺利生成代码。
   - **示例代码**：以下是一个简单的将模板类的声明和实现放在一个`.cpp`文件（虽然通常建议放在头文件，但这里为了说明）中的例子。

```cpp
   // MyTemplate.cpp
   template<typename T>
   class MyTemplate {
   public:
       MyTemplate(T val) : value(val) {}
       T getValue() const {
           return value;
       }
   private:
       T value;
   };
   int main() {
       MyTemplate<int> obj(5);
       return obj.getValue();
   }
```

- 在这个例子中，模板类`MyTemplate`的声明和实现都在一个文件中，当在`main`函数中实例化`MyTemplate<int>`时，编译器能够顺利地生成相应的代码。

1. 不分开的缺点及一些替代方法
   - **缺点**：把模板和实现放在一个文件中可能会使代码看起来不够整洁，尤其是对于大型项目和复杂的模板代码。并且如果多个源文件都需要使用这个模板，可能会导致代码的重复包含，增加编译时间和代码体积。
   - **替代方法 - 显式实例化**：可以使用显式实例化来将模板的声明和实现分开。在模板的实现文件中，对可能用到的模板类型进行显式实例化声明。例如，在一个头文件`MyTemplate.h`中声明模板：

```cpp
   template<typename T>
   class MyTemplate {
   public:
       MyTemplate(T val) : value(val) {}
       T getValue() const;
   private:
       T value;
   };
```

- 然后在实现文件`MyTemplate.cpp`中实现模板方法并进行显式实例化：

```cpp
   #include "MyTemplate.h"
   template<typename T>
   T MyTemplate<T>::getValue() const {
       return value;
   }
   // 显式实例化
   template class MyTemplate<int>;
```

- 这样，在其他文件中包含`MyTemplate.h`头文件并使用`MyTemplate<int>`时，编译器能够正确链接到已经显式实例化的模板代码。不过这种方法需要对可能用到的所有模板类型进行显式实例化，对于模板参数类型较多的情况可能会比较繁琐。

### 92. 将字符串”hello world“从开始到打印到屏幕的全过程

![image-20241006165323172](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241006165323172.png)

### 93. C++的多继承有什么优点

1. 功能更强大的代码复用
   - 在 C++ 的多继承中，一个类可以从多个不同的基类继承属性和方法，这使得代码复用的程度更高。例如，假设有一个`Drawable`类，它提供了绘制对象的功能；还有一个`Serializable`类，用于实现对象的序列化。在 C++ 中，一个`ComplexShape`类可以同时继承自`Drawable`和`Serializable`，这样`ComplexShape`类的对象既能被绘制又能被序列化，直接复用了两个基类的功能。
   - 而在 Java 中，虽然有接口来实现类似的功能复用，但接口只能定义方法签名，没有像 C++ 多继承那样可以直接继承基类的实现部分。例如，Java 的接口不能包含成员变量（除了静态常量）和默认的方法实现（Java 8 之前），所以在某些情况下复用程度相对较低。
2. 灵活的类层次结构设计
   - C++ 的多继承允许创建更复杂和灵活的类层次结构。例如，在游戏开发中，可以有一个`Character`类，它继承自`PhysicalObject`（用于处理物理碰撞等物理属性）和`AIBehavior`（用于实现人工智能行为）。这种继承方式可以更好地模拟现实世界中对象的多种属性组合，通过多继承将不同方面的功能组合到一个类中，使得类的设计更贴近实际需求。
   - 相比之下，Java 主要通过单继承和接口实现来构建类层次结构。虽然这种方式也很灵活，但在一些需要同时继承多个具体实现类的场景下，C++ 的多继承更具优势。不过 Java 的接口机制也有其优点，如可以**实现多接口来定义多种行为规范，避免了 C++ 多继承可能带来的菱形继承等复杂问题**。

### 94. 为什么拷贝构造函数必须传引用不能传值

1. 避免无限递归调用
   - 如果拷贝构造函数的参数是按值传递的，那么在调用拷贝构造函数时，为了将实参传递给形参，就需要对实参进行拷贝。**而这个拷贝过程又会调用拷贝构造函数本身，这样就会陷入无限递归调用的状态。**
   - 例如，假设有一个类`MyClass`，如果拷贝构造函数的参数是按值传递的，像这样定义：

```cpp
   class MyClass {
   public:
       MyClass(const MyClass myObj) {
           // 拷贝操作
       }
   };
```

- 当尝试创建一个`MyClass`对象并使用另一个`MyClass`对象来初始化它时，例如`MyClass obj1; MyClass obj2 = obj1;`，在调用`MyClass`的拷贝构造函数（`MyClass(const MyClass myObj)`）时，为了将`obj1`传递给`myObj`，编译器会尝试调用拷贝构造函数来创建`myObj`，这个新的调用又会触发相同的操作，导致无限递归，最终导致栈溢出。

2. 引用传递的优势

- **效率高**：引用传递不需要像值传递那样创建一个新的对象副本。当传递一个大型对象时，值传递会带来较大的开销，因为需要复制整个对象的内容。**而引用传递只是传递对象的引用，相当于传递对象的地址，开销较小。**
- **语义合适**：拷贝构造函数的目的是创建一个新对象，这个新对象是另一个对象的副本。引用传递能够很好地实现这个目的，因为通过引用可以直接访问被引用的对象，从而进行成员的复制操作，以完成新对象的创建。例如，在正确定义的拷贝构造函数中：

```cpp
   class MyClass {
   public:
       MyClass(const MyClass& myObj) {
           // 进行成员的复制操作，例如：
           this->member1 = myObj.member1;
       }
       int member1;
   };
```

- 这里通过引用`myObj`可以方便地访问源对象的成员，并将其复制到新创建的对象中，实现了拷贝构造的功能。

### 95. 静态函数能定义为虚函数吗？

1. 没意义，又不实现多态
2. **虚函数调用关系：this->vptr->vtable->虚函数，静态函数没有this指针**

### 96. 虚函数代价

1. 带有虚函数的**类**，会产生**虚函数表**用来存储指向虚成员函数的指针
2. 带有虚函数的每一个**对象**，会有**一个指向虚表的指针**，增加对象的空间

### 97. 虚函数表、虚函数表指针创建的timing

1. **虚函数表的初始化时机**
   - **编译阶段确定虚函数表的基本结构**：在**编译阶段**，编译器会为包含虚函数的类构建虚函数表的基本框架。它会确定虚函数的地址并按照一定的顺序将其放入虚函数表中。对于基类，编译器会把基类的虚函数地址放入虚函数表；对于派生类，如果派生类重写了基类的虚函数，编译器会将派生类重写后的虚函数地址替换虚函数表中相应基类虚函数的位置。
   - **链接阶段完成虚函数表的填充（在一定程度上）**：在链接阶段，编译器和链接器一起工作来进一步完善虚函数表。特别是当涉及到多个编译单元（不同的`.cpp`文件）时，需要确保虚函数表中的函数地址能够正确地链接到实际的函数实现。例如，如果一个虚函数的实现位于另一个编译单元中，链接器会将虚函数表中的相应条目与正确的函数地址进行链接。
2. **虚函数表指针的初始化时机**
   - **对象构造时初始化虚函数表指针**：当**创建一个包含虚函数的类的对象时**，在对象的构造函数执行期间，会**初始化虚函数表指针。这个指针会被设置为指向该类对应的虚函数表**。
   - **具体过程**：在对象构造的早期阶段（通常是在执行基类构造函数之前，对于非虚继承情况），编译器会插入代码来初始化虚函数表指针。例如，在一个简单的单继承场景中，假设有基类`Base`（包含虚函数）和派生类`Derived`，当创建`Derived`类的对象时，首先会为这个对象分配内存空间，然后在执行`Derived`类的构造函数之前，会将对象中的虚函数表指针设置为指向`Derived`类的虚函数表。这个过程是由编译器自动完成的，程序员一般不需要显式地操作。
   - 对于继承情况的特殊性
     - **单继承**：在单继承场景下，派生类对象的虚函数表指针初始化相对简单。它直接指向派生类自己的虚函数表，这个虚函数表可能包含对基类虚函数的重写。例如，如果`Derived`类重写了`Base`类的某个虚函数`func`，那么`Derived`类对象的虚函数表中`func`对应的指针会指向`Derived::func`。
     - **多继承和虚继承**：在多继承和虚继承情况下，虚函数表指针的初始化会更复杂。在多继承中，可能会有多个虚函数表指针（取决于继承的层次和方式），每个指针负责管理从不同基类继承的虚函数关系。在虚继承中，虚函数表和虚函数表指针的初始化还需要考虑虚基类的因素，以确保虚基类的虚函数能够被正确地访问和重写，并且避免数据冗余和二义性等问题。

### 98.  数组和指针的区别

![image-20241006224922883](C:\Users\furina\AppData\Roaming\Typora\typora-user-images\image-20241006224922883.png)

### 99. debug和release区别

- 优化程度
  - **Debug 模式**：**几乎不进行优化或者只进行少量基本的优化**。这是为了保证程序的执行过程尽可能地接近源代码的逻辑，方便开发者调试。例如，变量的存储和访问顺序可能与源代码中的定义顺序完全一致，函数调用也会按照原始的调用方式进行，不会进行一些复杂的优化，如函数内联（将函数调用替换为函数体的代码）。
  - **Release 模式**：编译器会进行大量的优化。例如，它可能会对循环进行展开（如果这样做可以提高性能），将一些简单的函数内联到调用它的地方，对内存访问进行优化以提高缓存命中率等。这些优化措施可以显著提高程序的运行速度，但也可能会使生成的代码与原始代码在结构上有较大差异。
- 调试信息的包含与否
  - **Debug 模式**：包含完整的**调试信息**。这些信息存储在可执行文件的特定区域，调试器（如 Visual Studio 的调试器、GDB 等）可以读取这些信息来帮助开发者进行调试。例如，当程序在调试器中暂停时，开发者可以查看当前作用域内的所有变量的值，通过调用栈可以知道程序是如何到达当前执行点的，还可以设置断点来暂停程序的执行并检查程序状态。
  - **Release 模式**：通常会去除大部分调试信息，以减小可执行文件的大小。因为这些调试信息对于最终用户来说是没有用的，而且会占用一定的存储空间。不过，一些编译器也允许在 Release 模式下保留部分调试信息，例如用于生成程序崩溃时的错误报告。

### 100. strcpy与strncpy函数区别

![clickable Avatar: undefined](https://p3-flow-imagex-sign.byteimg.com/user-avatar/assets/e7b19241fb224cea967dfaea35448102_1080_1080.png~tplv-a9rns2rl98-icon-tiny.png?rk3s=98c978ad&x-expires=1729947225&x-signature=BEE5c2SIU5ZzTJYM0ilemea2oM8%3D)

C++执行int main(int argc, char* argb[)是什么意思

1. `main`函数的基本概念
   - 在 C++ 中，`main`函数是程序的入口点。当一个 C++ 程序启动时，操作系统会调用`main`函数，程序从`main`函数的第一条语句开始执行。
2. `int argc`参数
   - `argc`是一个整数（`int`类型），它代表命令行参数的数量。这个数量包括程序本身的名称。例如，如果在命令行中执行`./myprogram arg1 arg2`，那么`argc`的值为 3。因为有 3 个命令行参数：程序名`./myprogram`以及另外两个参数`arg1`和`arg2`。
3. `char* argv[]`参数
   - `argv`是一个字符指针数组（`char*`类型的数组）。它用于存储命令行参数的内容。
   - `argv[0]`通常是程序的名称（包括路径等完整信息）。在上面的例子`./myprogram arg1 arg2`中，`argv[0]`指向字符串`"./myprogram"`，`argv[1]`指向字符串`"arg1"`，`argv[2]`指向字符串`"arg2"`。
   - 可以通过索引`argv`数组来访问各个命令行参数的内容，并且可以对这些参数进行处理，比如根据不同的参数执行不同的程序功能。以下是一个简单的示例代码，用于打印命令行参数：

```cpp
#include <iostream>
int main(int argc, char* argv[])
{
    for (int i = 0; i < argc; ++i)
    {
        std::cout << "argv[" << i << "]: " << argv[i] << std::endl;
    }
    return 0;
}
```

- 当你在命令行中执行这个程序，并传递一些参数时，程序会逐个打印出这些参数的内容和它们对应的索引。

这种带有命令行参数的`main`函数形式在很多场景下非常有用，比如编写可以接受用户输入选项的工具程序，像编译器程序可以接受源文件名称和编译选项等参数，根据这些参数来执行相应的编译操作。

命令行参数是啥

1. 定义
   - 命令行参数是在启动程序时，通过命令行（也称为终端或控制台）传递给程序的信息。这些参数可以用来控制程序的行为，提供程序运行所需的数据等。
2. 举例说明
   - 考虑一个简单的文本处理程序，比如一个程序用于统计文本文件中的单词数量。在命令行中执行这个程序时，可以把要处理的文本文件名作为命令行参数传递给程序。例如，在 Linux 系统下，如果程序名为`wordcount`，文本文件名为`document.txt`，可以在终端中输入`./wordcount document.txt`。这里的`document.txt`就是一个命令行参数。
   - 再比如，很多编程语言的编译器也是通过命令行参数来工作的。以 C++ 编译器`g++`为例，在命令行输入`g++ -o myprogram mysource.cpp`。其中，`-o myprogram`和`mysource.cpp`都是命令行参数。`-o myprogram`告诉编译器将编译后的可执行文件命名为`myprogram`，`mysource.cpp`则是要编译的源文件的名字。
3. 作用
   - **配置程序行为**：命令行参数可以让用户在启动程序时就指定程序的某些运行方式。比如，一个图形处理程序可能有命令行参数来指定输出图像的分辨率、颜色模式等。
   - **数据输入**：可以作为程序的输入数据。例如，一个数据排序程序可以接受一个包含待排序数据的文件名作为命令行参数，程序读取文件中的数据并进行排序。
   - **程序选择功能**：帮助程序决定执行哪一部分功能。例如，一个备份工具程序可能有命令行参数来选择是进行全量备份还是增量备份。

### 101. 什么情况用指针当参数，什么时候用引用

1. 指针作为参数
   - 情况一：需要在函数内部动态分配内存时
     - 例如，当你想要在一个函数中创建一个动态数组，并将其返回给调用者。下面是一个简单的函数，用于创建一个包含`n`个整数的动态数组：

```cpp
       int* createArray(int n)
       {
           int* arr = new int[n];
           return arr;
       }
```

- 在这里，`arr`是一个指针，通过`new`操作符在堆上分配了足够的空间来存储`n`个整数。函数返回这个指针，使得调用者可以访问这个动态分配的数组。
- 情况二：可能传递空值（`nullptr`）时
  - 考虑一个函数，它用于在一个字符串数组中查找某个特定的字符串。如果没有找到，返回`nullptr`。

```cpp
       char* findString(char* strings[], int n, const char* target)
       {
           for (int i = 0; i < n; ++i)
           {
               if (strcmp(strings[i], target) == 0)
               {
                   return strings[i];
               }
           }
           return nullptr;
       }
```

- 在这个函数中，`strings`是一个指针数组，`target`是要查找的字符串。函数可以返回`nullptr`来表示没有找到目标字符串，这种灵活性在很多情况下是很有用的。
- 情况三：需要遍历数组或链表等数据结构时
  - 以遍历一个链表为例，链表节点通常是通过指针来连接的。

```cpp
       struct ListNode
       {
           int val;
           ListNode* next;
       };
       void printList(ListNode* head)
       {
           ListNode* current = head;
           while (current!= nullptr)
           {
               std::cout << current->val << " ";
               current = current->next;
           }
       }
```

- 这里的`head`是链表的头节点指针，通过遍历`next`指针来访问链表中的每个节点，直到遇到`nullptr`（表示链表的末尾）。

1. 引用作为参数
   - 情况一：避免拷贝大型对象时
     - 当传递的对象比较大，如大型的结构体或者包含大量数据的类对象时，使用引用可以避免不必要的拷贝操作，提高程序的效率。例如，有一个`Matrix`类表示矩阵，在一个函数中需要对矩阵进行转置操作：

```cpp
       class Matrix
       {
       public:
           int rows;
           int cols;
           int** data;
       };
       void transpose(Matrix& m)
       {
           int** newData = new int[m.cols][m.rows];
           for (int i = 0; i < m.rows; ++i)
           {
               for (int j = 0; j < m.cols; ++j)
               {
                   newData[j][i] = m.data[i][j];
               }
           }
           // 释放原矩阵数据内存并更新成员变量等操作
       }
```

- 如果使用值传递，每次调用`transpose`函数时都需要拷贝整个`Matrix`对象，这会消耗大量的时间和内存。而使用引用传递，只需要传递对象的引用，不需要进行拷贝。
- 情况二：需要修改原始对象时
  - 假设要编写一个函数来更新一个学生的成绩记录。

```cpp
       class Student
       {
       public:
           std::string name;
           double grade;
       };
       void updateGrade(Student& s, double newGrade)
       {
           s.grade = newGrade;
       }
```

- 在这个函数中，`s`是`Student`对象的引用，通过这个引用可以直接修改原始的`Student`对象的成绩成员变量。
- 情况三：实现操作符重载等需要类似引用语义的功能时
  - 例如，在实现`<<`操作符重载来输出自定义类对象的信息时，通常会使用引用。

```cpp
       class Complex
       {
       public:
           double real;
           double imag;
       };
       std::ostream& operator<<(std::ostream& os, const Complex& c)
       {
           os << c.real << " + " << c.imag << "i";
           return os;
       }
```

- 这里的`os`是`std::ostream`的引用，通过返回引用可以实现链式调用（如`cout << c1 << c2;`），并且在函数内部通过引用修改`os`对象的状态（向流中写入数据）。

一般来说，如果需要动态内存分配、可能传递空值或者遍历指针相关的数据结构，指针是一个合适的选择；如果想要避免大型对象的拷贝、直接修改原始对象或者实现类似引用语义的功能（如操作符重载），引用则更有优势。同时，在现代 C++ 中，尽量使用引用而不是指针来提高代码的可读性和安全性，因为引用在初始化后不能再指向其他对象，而指针可以随意修改指向的对象，容易导致错误。

数组和指针的区别

1. **概念上的区别**
   - 数组
     - 数组是一种数据结构，它是一组相同类型元素的集合。这些元素在内存中是连续存储的，并且通过数组名和索引来访问。例如，`int arr[5];`定义了一个包含 5 个整数的数组。数组的大小在定义时通常是固定的，在 C++ 中，它是一种编译时就确定大小的数据结构（不过 C++ 11 引入了`std::vector`等动态数组容器，这里先讨论原生数组）。
   - 指针
     - 指针是一个变量，其值为另一个变量的内存地址。例如，`int* ptr;`定义了一个可以指向整数类型变量的指针。指针可以指向任何合适类型的内存单元，并且可以在程序运行过程中动态地改变其指向的地址。
2. **内存分配和存储方式的区别**
   - 数组
     - 数组在内存中的存储是连续的。例如，对于`int arr[5] = {1, 2, 3, 4, 5};`，假设数组`arr`的起始地址是`0x1000`，那么`arr[0]`存储在`0x1000`位置，`arr[1]`存储在`0x1000 + sizeof(int)`位置，`arr[2]`存储在`0x1000 + 2*sizeof(int)`位置，以此类推。数组名在大多数情况下可以看作是一个常量指针，它指向数组的第一个元素，并且这个指针的值不能被修改（在 C++ 中不能将数组名赋值给其他地址）。
   - 指针
     - 指针本身占用一定的内存空间来存储地址。在 32 位系统中，指针通常占用 4 个字节，在 64 位系统中，指针通常占用 8 个字节。指针所指向的内存单元可以是不连续的，例如，可以先让指针指向一个数组中的某个元素，然后再让它指向另一个不相关的变量。
3. **访问元素方式的区别**
   - 数组
     - 通过索引来访问数组中的元素。例如，`arr[2]`就可以访问数组`arr`中的第三个元素（索引从 0 开始）。这种访问方式是基于数组的起始地址和元素类型的大小进行计算的，编译器会自动将`arr[i]`转换为`*(arr + i)`的形式，其中`i`是索引。
   - 指针
     - 首先要将指针指向一个有效的内存地址，然后通过解引用操作符`*`来访问指针所指向的元素。例如，如果`ptr`是一个指向整数的指针，并且已经指向了一个有效的整数变量，那么`*ptr`就可以访问这个整数变量的值。此外，指针也可以通过算术运算来访问相邻的内存单元，例如，`ptr + 1`会将指针移动到下一个与它所指向类型相同的内存单元（如果`ptr`指向一个整数，那么`ptr + 1`将指向内存中紧接着这个整数的下一个整数位置）。
4. **作为函数参数的区别**
   - 数组
     - 当数组作为函数参数时，实际上传递的是数组的首地址，也就是一个指针。例如，有函数`void func(int arr[])`，这里的`arr[]`其实等价于`int* arr`。在函数内部，无法直接获取数组的大小（除非另外传递数组大小参数），因为数组名在函数内部退化为一个指针。
   - 指针
     - 指针作为函数参数时，传递的就是指针本身的值，也就是一个内存地址。可以在函数内部修改指针所指向的内容，也可以修改指针本身的值（使其指向其他内存地址），不过需要注意避免产生悬空指针（指向已经释放的内存或者无效的内存地址）等问题。
5. **初始化的区别**
   - 数组
     - 数组在定义时可以进行初始化，例如，`int arr[3] = {1, 2, 3};`或者`int arr[] = {1, 2, 3};`（这种情况下编译器会根据初始化列表中的元素个数来确定数组大小）。如果不进行初始化，对于全局数组和静态局部数组，数组元素会被初始化为 0；对于自动局部数组，数组元素的值是不确定的。
   - 指针
     - 指针在定义时可以初始化为`nullptr`（在 C++ 11 及以后版本）或者一个有效的内存地址。例如，`int* ptr = nullptr;`或者`int num = 5; int* ptr = #`（这里`&num`是取变量`num`的地址，使得`ptr`指向`num`）。如果指针没有被初始化而直接使用，可能会导致程序出现未定义行为，因为它可能指向任意的内存地址。

debug和release区别

1. **定义与目的**
   - Debug 模式
     - Debug 模式主要用于程序开发过程中的调试。在这个模式下，编译器会生成包含大量调试信息的可执行文件，这些信息包括变量的名称、类型、作用域，函数的调用栈信息等。目的是帮助开发者方便地定位错误、跟踪程序的执行流程和观察变量的值的变化。
   - Release 模式
     - Release 模式用于生成最终交付给用户的产品版本。这个模式下的重点是优化程序的性能和减小文件大小，编译器会对代码进行各种优化，例如去除不必要的调试代码、优化循环、内联函数等，以提高程序的运行速度和效率。
2. **代码生成与优化方面的区别**
   - 优化程度
     - **Debug 模式**：几乎不进行优化或者只进行少量基本的优化。这是为了保证程序的执行过程尽可能地接近源代码的逻辑，方便开发者调试。例如，变量的存储和访问顺序可能与源代码中的定义顺序完全一致，函数调用也会按照原始的调用方式进行，不会进行一些复杂的优化，如函数内联（将函数调用替换为函数体的代码）。
     - **Release 模式**：编译器会进行大量的优化。例如，它可能会对循环进行展开（如果这样做可以提高性能），将一些简单的函数内联到调用它的地方，对内存访问进行优化以提高缓存命中率等。这些优化措施可以显著提高程序的运行速度，但也可能会使生成的代码与原始代码在结构上有较大差异。
   - 调试信息的包含与否
     - **Debug 模式**：包含完整的调试信息。这些信息存储在可执行文件的特定区域，调试器（如 Visual Studio 的调试器、GDB 等）可以读取这些信息来帮助开发者进行调试。例如，当程序在调试器中暂停时，开发者可以查看当前作用域内的所有变量的值，通过调用栈可以知道程序是如何到达当前执行点的，还可以设置断点来暂停程序的执行并检查程序状态。
     - **Release 模式**：通常会去除大部分调试信息，以减小可执行文件的大小。因为这些调试信息对于最终用户来说是没有用的，而且会占用一定的存储空间。不过，一些编译器也允许在 Release 模式下保留部分调试信息，例如用于生成程序崩溃时的错误报告。
3. **安全性与稳定性方面的区别**
   - 错误检查和处理
     - **Debug 模式**：会包含更多的错误检查代码。例如，在访问数组元素时，可能会进行额外的边界检查，以确保程序不会访问到数组之外的内存区域。当发生错误时，程序可能会更容易出现异常或者中断执行，并且会提供更详细的错误信息，帮助开发者定位问题。
     - **Release 模式**：为了提高性能，可能会减少一些错误检查代码。这意味着在某些情况下，程序可能会在没有明显错误提示的情况下出现异常行为，如访问越界可能会导致程序崩溃或者产生不可预测的结果。不过，好的编程实践应该在 Release 版本中也考虑足够的错误检查和容错机制，以确保程序的稳定性。
   - 内存管理
     - **Debug 模式**：内存分配和释放操作可能会被更严格地监控。例如，一些调试库会在内存块的头部和尾部添加额外的标记，用于检查内存是否被正确地分配和释放，是否存在内存泄漏（分配的内存没有被释放）或者内存越界访问等问题。
     - **Release 模式**：虽然内存管理的基本规则仍然适用，但不会有像 Debug 模式那样详细的监控。这就要求开发者在编写代码时更加谨慎，确保内存管理的正确性，因为在 Release 模式下，内存错误可能更难被发现。
4. **运行速度和资源占用方面的区别**
   - 运行速度
     - **Debug 模式**：由于没有进行大量的优化，并且包含了更多的调试相关代码，程序的运行速度通常会比 Release 模式慢。例如，频繁的变量检查和调试信息的处理会消耗额外的时间和处理器资源。
     - **Release 模式**：经过优化后，程序的运行速度通常会明显快于 Debug 模式。特别是对于一些计算密集型或者性能敏感的应用程序，这种速度提升可能会非常显著。
   - 资源占用
     - **Debug 模式**：可执行文件的大小通常会比 Release 模式大，因为包含了调试信息。同时，由于运行时需要处理调试信息等因素，可能会占用更多的内存资源。
     - **Release 模式**：可执行文件相对较小，内存占用也相对较少，这使得它更适合在资源有限的环境中运行，并且可以更快地加载和执行。

### 102. strcpy与strncpy函数区别

1. **函数定义和功能概述**
   - strcpy 函数
     - 函数原型为`char* strcpy(char* destination, const char* source);`。它的主要功能是将源字符串（`source`）的内容复制到目标字符串（`destination`）中，包括字符串结束标志`'\0'`。这个函数会一直复制，直到遇到源字符串中的`'\0'`为止。
   - strncpy 函数
     - 函数原型为`char* strncpy(char* destination, const char* source, size_t n);`。它也是用于字符串复制，但它会从源字符串中最多复制`n`个字符到目标字符串中。如果源字符串的长度小于`n`，则目标字符串中剩余的部分会被填充`'\0'`；如果源字符串的长度大于等于`n`，则目标字符串不会自动添加`'\0'`结束标志，这可能导致目标字符串不是一个以`'\0'`结尾的合法字符串。
2. **安全性方面的区别**
   - strcpy 函数
     - 存在安全风险。因为它没有对复制的长度进行限制，如果源字符串的长度大于目标字符串的长度，就会导致缓冲区溢出。例如，假设定义了`char dest[5]; char* src = "abcdef";`，然后使用`strcpy(dest, src);`，就会发生缓冲区溢出，因为源字符串`"abcdef"`的长度为 6（包括`'\0'`），而目标字符串`dest`的长度只有 5。这种缓冲区溢出可能会导致程序崩溃、数据损坏或者被恶意利用来执行任意代码（安全漏洞）。
   - strncpy 函数
     - 相对更安全一些。通过指定复制的最大长度`n`，可以在一定程度上避免缓冲区溢出。但是，如果使用不当，仍然可能会出现问题。例如，如果忘记考虑源字符串长度和`n`的关系，没有正确地处理目标字符串结尾的`'\0'`标志，可能会导致目标字符串无法正确地作为 C 风格字符串被其他函数使用（因为 C 风格字符串要求以`'\0'`结尾）。
3. **复制行为的区别**
   - strcpy 函数
     - 会完整地复制源字符串到目标字符串，直到遇到源字符串中的`'\0'`。例如，`char dest[10]; char* src = "hello";`，使用`strcpy(dest, src);`后，`dest`中的内容将是`"hello"`（后面会自动添加`'\0'`）。
   - strncpy 函数
     - 按照指定的长度`n`进行复制。例如，`char dest[10]; char* src = "abcdef";`，如果使用`strncpy(dest, src, 3);`，则`dest`中的内容将是`"abc"`，后面会被自动填充`'\0'`，因为源字符串长度大于`n`，且复制了 3 个字符后，目标字符串剩余部分填充`'\0'`；如果使用`strncpy(dest, src, 7);`，则`dest`中的内容将是`"abcdef"`，但不会自动添加`'\0'`，因为源字符串长度小于等于`n`。
4. **使用场景的区别**
   - strcpy 函数
     - 在确定源字符串长度不会超过目标字符串长度的情况下可以使用。例如，当已经知道两个字符串的长度范围，并且源字符串一定能完整地放入目标字符串中时，如在内部固定大小的缓冲区之间进行字符串复制，并且已经确保了安全性的情况下。不过，在现代 C++ 编程中，由于其安全风险，一般不推荐使用。
   - strncpy 函数
     - 适用于需要限制复制长度的场景。比如，从用户输入（可能包含恶意输入）中提取一定长度的字符串部分，或者在处理网络数据包中的字符串数据等场景中，通过限制复制长度来避免缓冲区溢出。但需要注意正确处理目标字符串结尾的`'\0'`标志，以确保生成的是合法的 C 风格字符串。

### 103. static_cast比C语言的转换强在哪里

- `static_cast`是 C++ 中的一个显式类型转换操作符，它的使用使得**类型转换意图更加明显**。在代码中看到`static_cast`，开发者可以很容易地识别出这是一个经过考虑的类型转换操作。例如，`int i = static_cast<int>(3.14);`，这种写法明确地告诉阅读代码的人，这里是在进行一个从`double`（常量 3.14 默认是`double`类型）到`int`的类型转换，有助于提高代码的可读性和可维护性。

### 104. 成员函数里memset(this, 0, sizeof(*this))会发生什么

- `memset`是 C 和 C++ 标准库中的一个函数，它主要用于**将一段内存区域的内容设置为指定的值**。其函数原型为`void *memset(void *s, int c, size_t n);`。
- 这个函数的功能是将从指针`s`指向的内存地址开始，长度为`n`字节的内存区域，每个字节都设置为`c`（`c`是一个`int`类型的值，但实际上只会使用其最低字节来填充内存）。例如，如果你想将一个字符数组全部初始化为`'\0'`（字符串结束标志），可以使用`memset`函数。

1. **对象内存清零的基本行为**
   - 当在成员函数中使用`memset(this, 0, sizeof(*this))`时，本质上是将对象自身（由`this`指针指向）**所占内存空间的内容全部设置为 0**。`this`指针指向当前对象，`sizeof(*this)`计算出当前对象的大小，`memset`函数按照字节为单位，将从`this`所指向的地址开始，长度为`sizeof(*this)`的内存区域都填充为 0。
2. **对基本数据类型成员的影响**
   - 对于对象中的基本数据类型成员（如`int`、`char`、`float`等），这些成员的值会被设置为 0。例如，如果对象中有一个`int`成员变量`n`，执行`memset(this, 0, sizeof(*this))`后，`n`的值将变为 0。
   - 但是需要注意，**对于一些有特殊意义的 0 值，如指针类型成员被设置为`nullptr`（**在 C++ 11 及以后的标准下更合适的表示是`nullptr`，而不是简单的 0，但在这种`memset`操作下指针会被设置为 0，其效果类似`nullptr`），**可能会影响到后续对这些指针的解引用操作**。如果在`memset`之前这些指针是指向有效内存区域的，那么将其清零后再进行解引用可能会导致程序出现错误（如访问违规）。
3. **对对象虚函数表指针（如果有）的影响**
   - 在 C++ 中，如果对象是一个包含虚函数的类的实例，对象的内存布局通常会在开头（或者在特定的位置，取决于编译器实现）包含一个虚函数表指针（vptr）。这个指针指向虚函数表，虚函数表中存储了该类的虚函数的地址。
   - 当执行`memset(this, 0, sizeof(*this))`时，这个**虚函数表指针也会被清零。这会导致对象在调用虚函数时出现未定义行为。**因为调用虚函数是通过虚函数表指针来查找正确的虚函数地址的，一旦指针被清零，就无法正确地找到虚函数的实现，很可能导致程序崩溃或者执行错误的代码路径。
4. **对包含对象（成员对象）的影响**
   - 如果对象中包含其他对象（作为成员），那么这些成员对象的内存也会被清零。这可能会导致**这些成员对象的内部状态被破坏**。例如，如果成员对象有自己的构造函数，这些构造函数初始化的状态会被覆盖，并且如果成员对象也有虚函数等复杂的内部结构，同样可能会导致类似上述虚函数表指针被清零后的问题。
5. **不适当使用的风险总结**
   - **总的来说，在成员函数中随意使用`memset(this, 0, sizeof(*this))`是一种比较危险的操作。**它可能会破坏对象的正常状态，包括基本数据成员、虚函数相关的机制以及成员对象的状态。除非你非常清楚这种操作对对象的所有方面的影响，并且确实需要将对象的所有内存清零（这种情况在实际的良好设计的 C++ 程序中比较少见），否则应该避免这种操作。

### 105. 回调函数是什么?作用

1. **定义**
   - 回调函数是一种作为参数传递给另一个函数的函数。这个被当作参数的函数会在调用它的函数（通常称为 “宿主函数” 或 “高阶函数”）内部的某个特定点被调用。简单来说，它就像是一个预先准备好的 “小工具”，当**主程序执行到特定步骤时，自动调用函数,(看见许秀自动输出许哥牛逼)就会使用这个 “小工具” 来完成特定的任务。**
2. **作用**
   - 实现事件驱动编程
     - 在图形用户界面（GUI）编程中，回调函数被广泛应用。例如，当用户点击一个按钮时，操作系统会检测到这个事件，并调用预先注册的回调函数来处理该事件。以一个简单的 **C++ GUI 库（如 Qt）为例，当创建一个按钮对象并设置其`clicked`回调函数时**，每次按钮被点击，该回调函数就会被执行，用于执行用户定义的操作，如打开一个新窗口、保存文件等。

### 106. 什么是一致性哈希

### 107. 为什么友元函数必须在类内部声明

1. **类的封装性和访问控制机制**
   - 类是 C++ 中实现封装的主要工具。通过将数据成员和成员函数分为`public`（公有）、`private`（私有）和`protected`（保护）三种访问级别，类可以控制外部代码对其内部细节的访问。`private`成员只能被类的成员函数访问，这是为了隐藏内部数据结构和实现细节，防止外部代码随意修改对象的状态，从而保证类的完整性和独立性。
   - 友元函数和友元类的概念是对这种封装性的一种有控制的突破。它们被允许访问类的`private`和`protected`成员，但是这种访问权限需要在类内部进行明确的授权，这就是为什么友元函数必须在类内部声明。
2. **告知编译器友元关系**
   - 当在类内部声明一个友元函数时，编译器会记录下这种特殊的关系。这样，当编译器在编译这个友元函数的定义部分（通常在类外部）时，它就知道这个函数被赋予了访问类内部私有和保护成员的权限。
   - 例如，考虑以下代码：

```cpp
     class MyClass {
     private:
         int privateData;
     public:
         MyClass(int data) : privateData(data) {}
         friend void friendFunction(MyClass& obj);
     };
     void friendFunction(MyClass& obj) {
         // 这里可以访问obj的privateData，因为它是友元函数
         std::cout << obj.privateData << std::endl;
     }
```

- 在这个例子中，`friendFunction`函数的定义在类外部，但是因为在`MyClass`类内部声明了它为友元函数，编译器就知道在`friendFunction`函数中访问`MyClass`对象的`privateData`是合法的。如果友元函数不在类内部声明，编译器在编译`friendFunction`函数时，按照常规的访问控制规则，会认为访问`privateData`是非法的，从而产生编译错误。

1. 明确友元的作用域和意图
   - 在类内部声明友元函数，可以明确这个友元函数是与该类相关联的，并且其访问权限是针对这个特定类的。这有助于代码的可读性和维护性，让其他阅读代码的人能够清楚地看到哪些外部函数被赋予了特殊的访问权限，以及这些权限是用于哪个类的。
   - 同时，这种声明方式也限制了友元函数的作用域。一个友元函数只有在被某个类声明为友元后，才能访问该类的私有和保护成员。这避免了友元函数无限制地访问其他类的内部数据，保证了访问权限的相对集中和可管理性。

### 108. 友元函数和友元类是什么

1. 友元函数（Friend Function）
   - 定义
     - 友元函数是在类定义中被声明为 “朋友” 的非成员函数。它可以访问类的私有（`private`）和保护（`protected`）成员，就好像它是类的成员函数一样。这打破了类的封装性，但在某些特定情况下是非常有用的。
   - 声明方式
     - 在类的定义中，通过使用`friend`关键字来声明友元函数。例如，有一个`Circle`类，想要定义一个友元函数来计算圆的面积，代码可能如下：

```cpp
       class Circle {
       private:
           double radius;
       public:
           Circle(double r) : radius(r) {}
           friend double area(const Circle& c);
       };
       double area(const Circle& c) {
           return 3.14 * c.radius * c.radius;
       }
```

- 在这个例子中，`area`函数是`Circle`类的友元函数，它可以访问`Circle`类中的私有成员`radius`来计算圆的面积。
- 作用和使用场景
  - **方便外部函数访问类的私有成员**：当需要一个外部函数来处理类内部的数据，但又不想将这些数据成员设为公有（`public`）时，友元函数就很有用。例如，在上面的`Circle`类中，我们希望`area`函数能够计算圆的面积，但不想将`radius`暴露给外部，友元函数就提供了这样的访问途径。
  - **实现运算符重载（某些情况）**：在 C++ 中，当需要重载一些二元运算符（如`<<`用于输出流操作），并且希望这些运算符能够访问类的私有成员时，友元函数是一种很好的选择。例如，对于一个自定义的`Complex`类（表示复数），如果想通过`cout << complexObj`的方式输出复数对象，可能需要将`operator<<`声明为`Complex`类的友元函数，这样它才能访问`Complex`类中的实部和虚部成员来进行正确的输出。

1. 友元类（Friend Class）
   - 定义
     - 友元类是在另一个类的定义中被声明为 “朋友” 的类。友元类的所有成员函数都可以访问声明它为友元的那个类的私有和保护成员。
   - 声明方式
     - 同样通过`friend`关键字在类定义中进行声明。例如，有`ClassA`和`ClassB`两个类，`ClassB`是`ClassA`的友元类：

```cpp
       class ClassA {
       private:
           int privateData;
       public:
           ClassA(int data) : privateData(data) {}
           friend class ClassB;
       };
       class ClassB {
       public:
           void accessData(ClassA& a) {
               std::cout << a.privateData << std::endl;
           }
       };
```

- 在这个例子中，`ClassB`的成员函数`accessData`可以访问`ClassA`的私有成员`privateData`，因为`ClassB`是`ClassA`的友元类。
- 作用和使用场景
  - **实现不同类之间的紧密协作**：当两个类之间有非常紧密的关系，需要一个类能够访问另一个类的内部细节时，友元类是一种解决方案。例如，在一个图形系统中，可能有一个`Shape`类和一个`Drawing`类，`Drawing`类需要访问`Shape`类的私有成员来进行正确的绘制操作，此时可以将`Drawing`类声明为`Shape`类的友元类。
  - **方便数据共享和操作**：在一些复杂的对象关系中，友元类可以方便地共享和操作彼此的数据。例如，在一个包含多个相关组件的系统中，不同组件类之间可能需要相互访问私有数据来实现整体的功能，友元类机制可以提供这样的数据访问途径。不过，需要注意的是，过度使用友元类可能会破坏类的封装性，导致代码的可维护性和安全性降低，所以应该谨慎使用

### 109. 动态编译和静态编译是什么

1. **定义**
   - 静态编译（Static Compilation）
     - 静态编译是指在编译程序时，将程序所依赖的库（如标准库或者第三方库）的代码直接链接到可执行文件中。这个过程在编译阶段完成，生成的可执行文件包含了程序本身的代码以及所有被链接的库代码，**因此可执行文件相对比较大。**
   - 动态编译（Dynamic Compilation）或动态链接（Dynamic Linking）
     - 动态编译是指在编译程序时，并不将所有依赖的库代码直接包含在可执行文件中。而是在**程序运行时，当需要调用库中的函数或者使用库中的数据时，才去加载相应的共享库（动态链接库）**。可执行文件只包含对库的引用信息，其大小相对较小。
2. **工作流程区别**
   - 静态编译流程
     - 编译器将源程序（例如`.cpp`文件）编译成目标文件（`.o`或`.obj`文件）。这些目标文件包含了程序的机器语言代码，但还不能直接运行，因为它们可能依赖于其他库。
     - 链接器将目标文件和静态库文件（`.a`或`.lib`文件）进行链接。它会把库中的代码复制到最终的可执行文件中，解决目标文件之间以及目标文件和库文件之间的符号引用（例如函数调用和变量引用）。
     - 最终生成一个完整的、包含所有依赖代码的可执行文件。例如，一个简单的 C++ 静态编译后的可执行文件，**运行时不再需要额外的库文件（除了操作系统提供的一些基本支持），因为所有需要的代码都已经在可执行文件中。**
   - 动态编译流程
     - 编译器同样将源程序编译成目标文件。
     - 链接器在链接时，**对于动态库（`.so`或`.dll`文件）**，只是在可执行文件中记录下对这些库的引用信息，如库的名称、函数在库中的位置等。这个过程生成的可执行文件比较小，**因为没有包含库的实际代码。**
     - 当程序运行时，操作系统的加载器会根据可执行文件中的引用信息，在内存中加载相应的动态库。如果动态库还没有被加载，加载器会找到库文件并将其加载到内存中，然后将程序中的函数调用等操作与动态库中的实际代码进行关联。例如，在 Linux 系统中，当运行一个动态编译的程序时，它会通过`ld - linux.so`等加载器来加载所需的`.so`动态库文件。

### 110. hello.c的编译过程

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}

```

![img](http://oss.interviewguide.cn/img/202205212343505.png)

1. **预处理（Pre - processing）**
   - 操作内容
     - 当编译`hello.c`时，首先进行预处理。预处理程序会处理以`#`开头的预处理指令。对于`#include`指令，它会将头文件的内容插入到源文件中。例如，如果`hello.c`中有`#include <stdio.h>`，预处理程序会把`stdio.h`中的内容（如`printf`函数的声明等）插入到`hello.c`文件相应的位置。
     - **对于`#define`指令定义的宏，会进行宏展开。假设`hello.c`中有`#define MESSAGE "Hello, World!"`，那么在预处理阶段，代码中所有出现`MESSAGE`的地方都会被替换为`"Hello, World!"`。**
     - 同时，`#ifdef`、`#ifndef`、`#else`和`#endif`等条件编译指令也会被处理，根据条件判断来包含或排除相应的代码部分。
   - 生成文件
     - 预处理后的文件通常以`.i`为扩展名，**例如`hello.i`。这个文件的内容是经过头文件展开、宏替换和条件编译后的纯 C 代码，**它的规模可能比原始的`hello.c`文件大，因为包含了头文件的内容。
   - 工具使用
     - 在 GCC 编译器中，可以使用`gcc -E hello.c -o hello.i`命令来生成预处理后的文件。其中`-E`选项表示只进行预处理，`-o`选项用于指定输出文件的名称。
2. **编译（Compilation）**
   - 操作内容
     - 编译器（如 GCC 的`cc1`组件）对预处理后的文件（`.i`文件）进行编译。编译过程主要包括词法分析、语法分析、语义分析和代码生成。
     - 词法分析阶段，编译器将`.i`文件的内容分解为一个个的词法单元，如关键字（`int`、`if`等）、标识符（变量名、函数名等）、常量（数字常量、字符常量等）、运算符（`+`、`-`、`*`、`/`等）和界符（`;`、`{`、`}`等）。
     - 语法分析阶段，编译器检查这些词法单元是否符合 C 语言的语法规则，并构建一个语法树来表示代码的语法结构。例如，对于语句`printf("%s", MESSAGE);`，语法树会体现出这是一个函数调用语句，函数名为`printf`，参数是`"%s"`和`MESSAGE`。
     - 语义分析阶段，编译器检查变量是否被正确声明和使用、函数调用是否正确（参数类型和数量是否匹配等）、类型转换是否合理等。例如，如果试图将一个字符数组传递给一个期望整数参数的函数，编译器会在语义分析阶段报错。
     - 最后，代码生成阶段，编译器将语义正确的代码转换为目标机器语言（通常是汇编语言）。这个过程会根据目标机器的架构（如 x86、ARM 等）和指令集生成相应的机器指令序列。
   - 生成文件
     - **编译后生成的文件通常是汇编语言文件，以`.s`为扩展名，如`hello.s`。这个文件包含了与`hello.c`源文件对应的汇编指令，用于在目标机器上执行相应的操作**。
   - 工具使用
     - 在 GCC 编译器中，可以使用`gcc -S hello.i -o hello.s`命令来生成汇编文件。其中`-S`选项表示只进行编译，生成汇编文件，`-o`选项用于指定输出文件的名称。
3. **汇编（Assembly）**
   - 操作内容
     - 汇编器（如 GCC 的`as`组件）**将汇编语言文件（`.s`文件）转换为目标机器的机器语言（二进制指令）。**每个汇编指令对应一个或多个机器指令，汇编器会将这些汇编指令翻译成二进制格式，以便计算机的处理器能够直接执行。例如，对于汇编指令`movl $0, %eax`（将常量 0 移动到`eax`寄存器），汇编器会将其转换为对应的二进制机器指令，这些机器指令的格式和内容由目标机器的指令集决定。
   - 生成文件
     - 汇编后生成的文件是目标文件**，以`.o`或`.obj`为扩展名，如`hello.o`。**这个文件包含了机器语言代码，是二进制格式的文件，但还不能直接运行，因为它可能还需要与其他目标文件或库文件进行链接。
   - 工具使用
     - 在 GCC 编译器中，可以使用`gcc -c hello.s -o hello.o`命令来生成目标文件。其中`-c`选项表示只进行汇编，生成目标文件，`-o`选项用于指定输出文件的名称。
4. **链接（Linking）**
   - 操作内容
     - **链接器（如 GCC 的`ld`组件）将目标文件（`.o`文件）与需要的库文件链接在一起，生成最终的可执行文件**。如果`hello.c`程序中调用了标准库中的函数（如`printf`），链接器会将目标文件与包含`printf`函数实现的库文件进行链接。
     - 链接器还会进行符号解析，将目标文件之间的函数调用和变量引用进行关联。例如，如果`hello.o`文件中的`main`函数调用了`printf`函数，链接器会找到`printf`函数的定义位置（在库文件中），并建立起这种调用关系。
   - 生成文件
     - 链接完成后生成最终的可执行文件，在 Linux 等系统下通常没有固定的扩展名，如`a.out`（默认名称）或者可以通过`-o`选项指定文件名，如`hello`。这个文件可以在操作系统环境下直接运行，执行`hello.c`程序所定义的功能。
   - 工具使用
     - 在 GCC 编译器中，可以使用`gcc hello.o -o hello`命令来生成最终的可执行文件。其中`-o`选项用于指定输出文件的名称。



### 111. 介绍几种常见的锁

![image-20241006225510787](C:\Users\furina\AppData\Roaming\Typora\typora-user-images\image-20241006225510787.png)

### 112. 为什么C++没有垃圾回收机制,跟Java不一样

1. **性能考虑**
   - **C++ 的设计目标**：C++ 是一种系统编程语言，注重性能和对底层硬件的高效控制。垃圾回收（GC）机制虽然方便了程序员管理内存，但它会带来一定的性能开销。GC 通常需要在程序运行过程中定期或不定期地暂停程序执行，以检查和回收不再使用的内存。这种暂停（称为 “Stop - the - World” 暂停）会影响程序的实时性和响应速度。例如，**在一些对性能要求极高的应用场景，如游戏开发、实时控制系统等，即使短暂的暂停也可能导致游戏卡顿或者控制系统响应延迟。**
   - **Java 的性能权衡**：Java 虽然也注重性能，但它的设计初衷更侧重于跨平台和易于开发。Java 的**垃圾回收机制在一定程度上牺牲了性能来换取开发的便利性**。现代 Java 虚拟机（JVM）中的 GC 算法在不断优化，尽量减少暂停时间，但仍然无法完全避免对性能的影响。
2. **灵活性和确定性控制需求**
   - **C++ 的灵活性**：C++ 程序员可以直接控制内存的分配和释放。通过`new`和`delete`操作符（对于对象）或者`malloc`和`free`（对于 C 风格的内存块），程序员可以在**精确的时间点进行内存管理**。这在一些需要精细控制内存生命周期的场景中非常重要。例如，在开发嵌入式系统或者资源受限的环境中，程序员可能需要确保内存的分配和释放符合特定的硬件资源限制和时序要求。
   - **Java 的确定性差异**：在 Java 中，由于垃圾回收机制的存在，程序员无法精确控制对象的销毁时间。虽然 Java 提供了一些方法来建议（如`System.gc()`，但不保证立即执行）垃圾回收，但对象的回收最终是由 GC 系统根据其算法和内存使用情况来决定的。这种不确定性在一些对资源管理有严格要求的场景下可能不太适用。
3. **应用场景差异**
   - **C++ 的应用场景偏向底层和高性能需求**：C++ 常用于操作系统开发、游戏引擎开发、高性能计算等领域。在这些场景中，程序员需要对内存等资源进行精确控制，以实现高性能和高效利用资源。例如，游戏引擎需要频繁地分配和释放内存来加载和卸载游戏资源（如纹理、模型等），手动内存管理可以更好地优化内存使用，减少内存碎片，提高游戏的性能和稳定性。
   - **Java 的应用场景侧重企业级和快速开发领域**：Java 在企业级应用、Web 应用、移动应用开发（Android 部分应用）等领域广泛应用。在这些场景中，开发速度、代码的可维护性和跨平台性更为重要。垃圾回收机制可以帮助程序员避免内存泄漏等问题，使他们能够更专注于业务逻辑的实现，如开发复杂的企业级业务流程或者 Web 服务。

### 113. C++从代码到可执行程序经历了什么

1. **预处理阶段**
   - **头文件展开**：C++ 编译器首先执行预处理操作。在这个阶段，以`#include`指令包含的头文件内容会被插入到源文件中。例如，如果有一个源文件`main.cpp`包含了`<iostream>`头文件，预处理器会将`<iostream>`头文件中的所有内容（如`std::cout`和`std::cin`等相关的声明）添加到`main.cpp`中。这使得编译器在后续阶段能够理解代码中对标准输入输出流等相关功能的引用。
   - **宏替换**：`#define`指令定义的宏也会在这个阶段被处理。例如，定义了`#define PI 3.14159`，在预处理阶段，代码中所有出现`PI`的地方都会被替换为`3.14159`。这是一种简单的文本替换机制，用于定义常量或者简单的代码片段替换。
   - **条件编译**：`#ifdef`、`#ifndef`、`#else`和`#endif`等指令用于条件编译。根据这些指令中的条件判断，预处理器可以选择性地包含或排除部分代码。例如，在开发调试版本和发布版本时，可以通过条件编译来包含或不包含调试相关的代码，如`#ifdef DEBUG std::cout << "Debugging information"; #endif`，只有在定义了`DEBUG`宏时，才会输出调试信息。
2. **编译阶段**
   - **词法分析**：编译器将预处理后的源文件分解为一个个的单词（词法单元），如关键字（`int`、`class`等）、标识符（变量名、函数名等）、常量（数字常量、字符常量等）、运算符（`+`、`-`、`*`、`/`等）和界符（`;`、`{`、`}`等）。这个过程类似于对文本进行语法单位的划分，为后续的语法分析做准备。
   - **语法分析**：编译器检查这些词法单元是否符合 C++ 的语法规则。它会构建一个语法树，以表示代码的语法结构。例如，对于语句`int a = 5;`，语法树会表示出这是一个声明语句，其中声明了一个`int`类型的变量`a`，并将其初始化为 5。如果代码存在语法错误，如缺少分号或者括号不匹配等，编译器会在这个阶段报错。
   - **语义分析**：在语法正确的基础上，编译器会进行语义分析。这包括检查变量是否被正确声明和使用、函数调用是否正确（参数类型和数量是否匹配等）、类型转换是否合理等。例如，如果试图将一个`double`类型的值赋给一个`int`类型的变量，而没有进行适当的类型转换，编译器会在语义分析阶段发出警告或者错误提示。
   - **代码生成**：经过前面的步骤后，编译器会将语义正确的代码转换为目标机器语言（如汇编语言）。这个过程会根据目标机器的架构（如 x86、ARM 等）和指令集生成相应的机器指令序列。不同的编译器可能会采用不同的代码生成策略，以优化生成的代码性能，例如选择合适的寄存器来存储变量、优化循环结构等。
3. **汇编阶段**
   - 汇编器将编译阶段生成的汇编语言代码转换为机器语言（二进制指令）。每个汇编指令对应一个或多个机器指令，汇编器会将这些汇编指令翻译成二进制格式，以便计算机的处理器能够直接执行。例如，对于汇编指令`mov eax, 5`（将常量 5 移动到`eax`寄存器），汇编器会将其转换为对应的二进制机器指令，这些机器指令的格式和内容由目标机器的指令集决定。
4. **链接阶段**
   - **目标文件合并**：在编译和汇编过程中，每个源文件（`.cpp`文件）通常会生成一个目标文件（`.o`或`.obj`文件）。链接器的一个主要任务是将这些目标文件合并在一起。例如，如果有一个项目包含`main.cpp`和`functions.cpp`两个源文件，分别生成了`main.o`和`functions.o`两个目标文件，链接器会将它们合并成一个可执行文件。
   - **符号解析**：链接器还需要解决符号引用的问题。在不同的目标文件中，可能会有函数调用或者变量引用。例如，`main.cpp`中的函数可能调用了`functions.cpp`中定义的函数，链接器需要找到这些函数的定义位置，并将调用和定义关联起来。同样，对于全局变量的引用也需要进行解析。
   - **库链接**：如果程序引用了外部库（如标准库或者第三方库），链接器会将这些库中的相关代码链接到可执行文件中。对于静态库，链接器会将库中需要的代码复制到可执行文件中；对于动态库，链接器会在可执行文件中添加对动态库的引用信息，以便在程序运行时加载动态库。

## 其他问题

### 1. 构造函数、析构函数的执行顺序

> 构造函数：父类构造函数、成员类对象构造函数、子类构造函数；
>
> 析构函数：子类析构函数、成员类对象析构函数、父类析构函数

1. 单继承情况下构造函数和析构函数的执行顺序
   - **构造函数执行顺序**：在单继承关系中，首先执行基类的构造函数，然后再执行派生类的构造函数。这是因为派生类是基于基类构建的，基类部分需要先初始化。
   - 例如，有一个基类`Base`和一个派生类`Derived`，代码如下：

```cpp
   class Base {
   public:
       Base() {
           std::cout << "Base constructor called." << std::endl;
       }
   };
   class Derived : public Base {
   public:
       Derived() {
           std::cout << "Derived constructor called." << std::endl;
       }
   };
   int main() {
       Derived d;
       return 0;
   }
```

- 在`main`函数中创建`Derived`类的对象`d`时，首先会调用`Base`类的构造函数，输出`Base constructor called.`，然后再调用`Derived`类的构造函数，输出`Derived constructor called.`。
- **析构函数执行顺序**：与构造函数的顺序相反。先执行派生类的析构函数，然后再执行基类的析构函数。因为在对象销毁时，派生类部分先被清理，最后才清理基类部分。
- 例如，为上述`Base`和`Derived`类添加析构函数：

```cpp
   class Base {
   public:
       Base() {
           std::cout << "Base constructor called." << std::endl;
       }
       ~Base() {
           std::cout << "Base destructor called." << std::endl;
       }
   };
   class Derived : public Base {
   public:
       Derived() {
           std::cout << "Derived constructor called." << std::endl;
       }
       ~Derived() {
           std::cout << "Derived destructor called." << std::endl;
       }
   };
   int main() {
       Derived d;
       return 0;
   }
```

- 当`main`函数结束，对象`d`销毁时，首先调用`Derived`类的析构函数，输出`Derived destructor called.`，然后调用`Base`类的析构函数，输出`Base destructor called.`。

1. 多继承情况下构造函数和析构函数的执行顺序
   - **构造函数执行顺序**：在多继承中，先执行基类构造函数，按照继承声明的顺序（从左到右）调用基类的构造函数，然后执行派生类的构造函数。
   - 例如，有三个类`Base1`、`Base2`和`Derived`，其中`Derived`继承自`Base1`和`Base2`：

```cpp
   class Base1 {
   public:
       Base1() {
           std::cout << "Base1 constructor called." << std::endl;
       }
   };
   class Base2 {
   public:
       Base2() {
           std::cout << "Base2 constructor called." << std::endl;
       }
   };
   class Derived : public Base1, public Base2 {
   public:
       Derived() {
           std::cout << "Derived constructor called." << std::endl;
       }
   };
   int main() {
       Derived d;
       return 0;
   }
```

- 当创建`Derived`类的对象`d`时，首先调用`Base1`的构造函数，输出`Base1 constructor called.`，然后调用`Base2`的构造函数，输出`Base2 constructor called.`，最后调用`Derived`类的构造函数，输出`Derived constructor called.`。
- **析构函数执行顺序**：与构造函数顺序相反。先执行派生类的析构函数，然后按照继承声明的相反顺序（从右到左）调用基类的析构函数。
- 例如，为上述类添加析构函数：

```cpp
   class Base1 {
   public:
       Base1() {
           std::cout << "Base1 constructor called." << std::endl;
       }
       ~Base1() {
           std::cout << "Base1 destructor called." << std::endl;
       }
   };
   class Base2 {
   public:
       Base2() {
           std::cout << "Base2 constructor called." << std::endl;
       }
       ~Base2() {
           std::cout << "Base2 destructor called." << std::endl;
       }
   };
   class Derived : public Base1, public Base2 {
   public:
       Derived() {
           std::cout << "Derived constructor called." << std::endl;
       }
       ~Derived() {
           std::cout << "Derived destructor called." << std::endl;
       }
   };
   int main() {
       Derived d;
       return 0;
   }
```

- 当`main`函数结束，对象`d`销毁时，首先调用`Derived`类的析构函数，输出`Derived destructor called.`，然后调用`Base2`的析构函数，输出`Base2 destructor called.`，最后调用`Base1`的析构函数，输出`Base1 destructor called.`。

1. 包含对象成员情况下构造函数和析构函数的执行顺序
   - **构造函数执行顺序**：当类包含对象成员时，先执行对象成员的构造函数（按照对象成员声明的顺序），然后执行类自身的构造函数。
   - 例如，有一个类`Outer`包含一个`Inner`类的对象成员：

```cpp
   class Inner {
   public:
       Inner() {
           std::cout << "Inner constructor called." << std::endl;
       }
   };
   class Outer {
   public:
       Outer() {
           std::cout << "Outer constructor called." << std::endl;
       }
       Inner inner;
   };
   int main() {
       Outer o;
       return 0;
   }
```

- 当创建`Outer`类的对象`o`时，首先调用`Inner`类的构造函数，输出`Inner constructor called.`，然后调用`Outer`类的构造函数，输出`Outer constructor called.`。
- **析构函数执行顺序**：与构造函数顺序相反。先执行类自身的析构函数，然后执行对象成员的析构函数（按照对象成员声明的相反顺序）。
- 例如，为上述类添加析构函数：

```cpp
   class Inner {
   public:
       Inner() {
           std::cout << "Inner constructor called." << std::endl;
       }
       ~Inner() {
           std::cout << "Inner destructor called." << std::endl;
       }
   };
   class Outer {
   public:
       Outer() {
           std::cout << "Outer constructor called." << std::endl;
       }
       ~Outer() {
           std::cout << "Outer destructor called." << std::endl;
       }
       Inner inner;
   };
   int main() {
       Outer o;
       return 0;
   }
```

- 当`main`函数结束，对象`o`销毁时，首先调用`Outer`类的析构函数，输出`Outer destructor called.`，然后调用`Inner`类的析构函数，输出`Inner destructor called.`。

### 2. 纯虚函数

- 纯虚函数是在基类中声明的虚函数，它在基类中没有定义具体的函数体，只是通过在函数声明的结尾加上` = 0`来标识。例如，在 C++ 中，`virtual void func() = 0;`就是一个纯虚函数的声明。
- 纯虚函数的存在是为了定义一个接口，**强制派生类去实现这个函数**。它体现了一种抽象的概念，即基类只是规定了派生类应该具有什么样的行为，但本身不提供具体的实现方式。
- 在 C++ 中，**只要一个类包含纯虚函数，它就是抽象类**。纯虚析构函数也不例外。当一个类有纯虚析构函数时，这个类不能被实例化，符合抽象类的定义。

```cpp
   class Vehicle {
   public:
       virtual void move() = 0;
   };
   class Car : public Vehicle {
   public:
       void move() override {
           cout << "The car is moving with engine." << endl;
       }
   };
   class Bicycle : public Vehicle {
   public:
       void move() override {
           cout << "The bicycle is moving with pedals." << endl;
       }
   };
```

### 3. 构造函数不定义为虚函数原因;父类析构函数定义为虚函数原因

> 构造函数若为虚函数，实例化对象时会实现多态进行动态绑定，**先调用了子类的构造函数，倒反天罡**

例如，当创建一个`Dog`类的对象时，编译器知道要调用`Dog`类的构造函数来初始化这个对象，这个过程不需要动态绑定（虚函数的主要特性）。

- **虚函数的语义不符**：虚函数主要用于实现多态，即通过基类指针或引用调用函数时，能够根据实际指向的对象类型来决定调用哪个函数。但在构造函数执行时，对象还没有完全构建好，没有所谓的 “对象实际类型” 和 “基类类型” 的动态切换场景。例如，在构造一个`Derived`类的对象时，它首先要构造基类部分，这个过程是**按照继承层次逐步构建**的，不是基于多态的动态调用场景。

> 父类指针指向子类对象向上转型实现多态时，析构函数非虚会导致调用的析构函数没有实现多态，而是父类的析构函数，先析构父类后没有析构子类，**内存泄漏，倒反天罡**

### 4. 类什么时候析构

1. 生命周期结束被销毁
2. delete

### 5. 构造函数或析构函数可以调用虚函数吗

> 构造函数（静态）里使用动态是不实际的，实现不了多态**，因为对象还没实例化，运行类型没确定**

1. 构造函数中调用虚函数
   - **从语法角度是可以的**：在构造函数中可以调用虚函数，但是这种调用可能不会产生预期的多态效果。
   - **行为分析**：当在构造函数中调用虚函数时，**虚函数的调用是基于对象的静态类型，而不是动态类型**。这是因为在构造函数执行期间，对象还没有完全构造完成，此时对象的动态类型信息还没有完全建立起来。
   - 例如，有一个基类`Base`和一个派生类`Derived`，代码如下：

```cpp
   class Base {
   public:
       Base() {
           print();
       }
       virtual void print() {
           std::cout << "Base::print" << std::endl;
       }
   };
   class Derived : public Base {
   public:
       Derived() {}
       void print() override {
           std::cout << "Derived::print" << std::endl;
       }
   };
   int main() {
       Derived d;
       return 0;
   }
```

- 在这个例子中，当创建`Derived`类的对象`d`时，首先会调用`Base`类的构造函数。在`Base`类的构造函数中调用`print`函数，虽然`print`是虚函数，但是这里会调用`Base`类的`print`函数，输出`Base::print`，而不是`Derived::print`。这是因为在`Base`类构造函数执行时，对象的`Derived`部分还没有被构造，对象被视为`Base`类型。

2. **析构函数中调用虚函数**

- **语法上可以调用**：和构造函数一样，析构函数中也可以调用虚函数，**前提是父类析构函数是虚函数**
- **行为注意事项**：在析构函数中调用虚函数同样可能不会产生完全的多态效果。当析构函数开始执行时，对象的派生部分已经开始被销毁，此时对象的动态类型信息也在逐渐消失。不过，如果析构函数是通过基类指针删除派生类对象**（并且虚函数机制正确设置）**，那么在析构函数中调用虚函数可以产生多态效果。
- 例如，以下是一个可能出现问题的示例：

```cpp
   class Base {
   public:
       ~Base() {
           print();
       }
       virtual void print() {
           std::cout << "Base::print" << std::endl;
       }
   };
   class Derived : public Base {
   public:
       ~Derived() {}
       void print() override {
           std::cout << "Derived::print" << std::endl;
       }
   };
   int main() {
       Base* b = new Derived();
       delete b;
       return 0;
   }
```

- 在这个例子中，当通过`Base`指针`b`删除`Derived`对象时，首先会调用`Base`类的析构函数。在`Base`类的析构函数中调用`print`函数，会输出`Base::print`，而不是`Derived::print`。这是因为在`Base`类析构函数执行时，对象的`Derived`部分已经开始被销毁，对象被视为`Base`类型。为了正确地实现多态销毁，应该将基类的析构函数声明为虚函数。

### 6. 构造函数的几种关键字

1. **default 关键字**
   - **用途**：在 C++ 11 中引入了`default`关键字用于显式指示编译器生成默认构造函数。默认构造函数是一种特殊的构造函数，它可以在没有参数的情况下初始化对象。
   - **使用场景**：当类中定义了其他构造函数（例如带参数的构造函数）后，编译器不会自动生成默认构造函数。如果此时还需要默认构造函数，可以使用`default`关键字来生成。例如：

```cpp
   class MyClass {
       int value;
   public:
       MyClass(int val) : value(val) {}
       MyClass() = default;
   };
```

- 在这个例子中，`MyClass`类首先定义了一个带参数的构造函数`MyClass(int val)`，按照 C++ 的规则，编译器此时不会自动生成默认构造函数。但通过`= default`，明确指示编译器生成默认构造函数，这样就可以像`MyClass obj;`这样创建对象而不需要传递参数。
- **注意事项**：使用`default`关键字生成的默认构造函数的行为与编译器自动生成的默认构造函数行为相同。它会对类中的成员进行默认初始化，例如对于基本类型成员会进行默认值初始化（如`int`类型成员初始化为 0）。

2. **delete 关键字**

- **用途**：`delete`关键字用于**禁止编译器生成某些函数，包括构造函数、析构函数、赋值运算符和其他一些函数**。这在一些特定场景下非常有用，比如当想要阻止某些不适当的操作时。
- **使用场景**：例如，当不希望类的对象被复制时，可以将复制构造函数和赋值运算符声明为`delete`。

```cpp
   class NonCopyable {
   public:
       NonCopyable() = default;
       NonCopyable(const NonCopyable&) = delete;
       NonCopyable& operator=(const NonCopyable&) = delete;
   };
```

- 在这个`NonCopyable`类中，通过`= delete`将复制构造函数和赋值运算符声明为删除状态。这样，如果尝试像`NonCopyable obj1; NonCopyable obj2 = obj1;`（复制构造）或者`NonCopyable obj1; obj1 = obj2;`（赋值）这样的操作，编译器会报错，禁止这些可能导致错误的复制行为。
- **注意事项**：一旦将某个函数声明为`delete`，就不能再使用被删除的函数形式进行操作。这是一种编译期的限制，有助于提高代码的安全性和逻辑性。

3. **= 0（纯虚函数）在构造函数中的误解澄清**

- 在构造函数中不能使用`= 0`来定义纯虚构造函数。因为构造函数的作用是创建对象，而纯虚函数所在的类是抽象类，抽象类是不能实例化的，所以纯虚构造函数没有意义。但是可以在抽象类中有纯虚函数，这些纯虚函数会强制派生类去实现相应的函数，用于定义接口和实现多态等操作，只是构造函数不能是纯虚的。

### 7. 构造函数、拷贝构造函数、赋值运算符区别

- 构造函数

对象不存在，不使用别的对象初始化

- 拷贝构造函数

**对象不存在**，使用别的对象初始化

- 赋值运算符

对象存在，用别的对象给它**赋值**

### 8. 拷贝构造函数、赋值运算符重载的区别

- 对象存不存在，前者原来不存在；后者一直存在
- 拷贝运算符**创建的新对象**是通过**复制已有同类型对象的数据成员**来初始化的；赋值运算符用于将一个对象的数据成员赋值给另一个**已存在**的同类型对象
- 拷贝初始化有些也用=运算符，看起来像=重载，但区别在对象存不存在

```cpp
Student s;
Student s1 = s;    // 调用拷贝构造函数
Student s2;
s2 = s;    // 赋值运算符操作

```

### 9. 虚拟继承

1. 定义
   - 虚拟继承是一种在 C++ 中用于解决多继承情况下菱形继承问题的机制。当一个派生类从多个基类继承，而这些基类又有一个共同的基类时，就可能会出现菱形继承结构。
   - 例如，有类 A，类 B 和类 C 都继承自 A，然后类 D 同时继承自 B 和 C。在这种情况下，如果没有虚拟继承，D 类中会包含两份 A 类的数据成员（一份来自 B，一份来自 C），这可能会导致数据冗余和二义性问题。
2. 虚拟继承的语法和实现方式
   - 在 C++ 中，使用`virtual`关键字来实现虚拟继承。例如，如果 B 和 C 虚拟继承自 A，语法如下：

```cpp
   class A {
       // A类的成员
   };
   class B : virtual public A {
       // B类的成员
   };
   class C : virtual public A {
       // C类的成员
   };
   class D : public B, public C {
       // D类的成员
   };
```

- 当使用虚拟继承时，编译器会创建一个共享的基类子对象。在上面的例子中，D 类对象中只会有一个 A 类的子对象，而不是两个。这是通过在对象内存布局中设置一个虚基类指针（如果有虚函数还会有虚函数表指针）来实现的。这个虚基类指针指向共享的基类对象部分。

1. 解决的问题 - 数据冗余和二义性
   - **数据冗余方面**：在非虚拟继承的菱形继承中，派生类会包含多个共同基类部分的数据副本。例如，假设 A 类有一个成员变量`int value;`，在非虚拟继承的情况下，D 类对象中会有两个`value`变量，分别来自 B 和 C 对 A 的继承。而通过虚拟继承，D 类对象中只有一个`value`变量，避免了数据冗余。
   - **二义性方面**：非虚拟继承还可能导致成员访问的二义性。例如，在 D 类中访问`A`类的成员时，如果没有虚拟继承，编译器不知道应该选择从 B 继承的 A 部分还是从 C 继承的 A 部分。而虚拟继承解决了这个问题，因为只有一个共享的基类子对象，访问其成员时不会产生二义性。
2. 虚拟继承的性能开销
   - 虚拟继承会带来一定的性能开销。因为需要额外的指针（虚基类指针）来维护共享基类对象的位置，并且在访问虚基类成员时，可能需要通过这个指针进行额外的偏移计算来找到正确的成员位置。
   - 不过，在解决菱形继承问题所带来的好处面前，这种性能开销在很多情况下是可以接受的，特别是在需要合理组织类层次结构和避免数据混乱的场景中。
3. 应用场景示例
   - 以图形绘制系统为例。假设有一个基本图形类`Shape`，有两个派生类`Rectangle`和`Circle`，它们都继承了`Shape`的基本属性（如颜色等）。**然后有一个复杂图形类`ComplexShape`，它可能同时包含`Rectangle`和`Circle`部分，此时`ComplexShape`可以虚拟继承`Shape`，以避免`ComplexShape`对象中出现两份`Shape`类的属性，确保数据的一致性和避免访问二义性。**

```cpp
#include <iostream>
using namespace std;

class A{}
class B : virtual public A{};
class C : virtual public A{};
class D : public B, public C{};

int main()
{
    cout << "sizeof(A)：" << sizeof A <<endl; // 1，空对象，只有一个占位
    cout << "sizeof(B)：" << sizeof B <<endl; // 4，一个bptr指针，省去占位,不需要对齐
    cout << "sizeof(C)：" << sizeof C <<endl; // 4，一个bptr指针，省去占位,不需要对齐
    cout << "sizeof(D)：" << sizeof D <<endl; // 8，两个bptr，省去占位,不需要对齐
}

```

![img](http://oss.interviewguide.cn/img/202205220025114.png)

![img](http://oss.interviewguide.cn/img/202205220022397.png)

1. - 