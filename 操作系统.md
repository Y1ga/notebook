# 进程&线程

## 进程

多个程序、交替执行的思想就是C

![并发与并行](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)

![进程的三种基本状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/7-%E8%BF%9B%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.jpg)

一个进程的活动期间至少具备三种基本状态：**运行、就绪、阻塞**

- 运行：该时刻进程占用CPU
- 就绪：可运行，**由于其他进程处于运行状态**而暂停运行，**CPU此时没有调度**
- 阻塞：该进程**等待某一事件发生**（I/O完成）而暂停运行，即使给它CPU控制权也无法运行
- 创建：进程正在被创建时的状态
- 结束：进程正在系统中消失的状态

![进程五种状态的变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg)

![虚拟内存管理-换入换出](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/9-%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA.jpg)

虚拟内存管理的操作系统中，**通常把阻塞状态的进程的物理内存空间换出到硬盘**，再运行的时候再从硬盘换入到物理内存，**此时进程没有占用实际的物理内存空间即为挂起状态**，与阻塞状态不同**阻塞是等待某个事件的返回但占据了物理内存空间**

![七种状态变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

- sleep也是强制让进程挂起
- Linux中程序执行时用ctrl + z挂起进程

### 进程控制块

PCB, Process Control Block的数据结构来描述进程，是**进程存在的唯一标识**，进程没了PCB也一样

![image-20240913105110303](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913105110303.png)

### 进程的控制

![image-20240913105437259](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913105437259.png)

### 进程的上下文切换

**一个进程切换到另一个进程运行**，称为进程的上下文切换

- CPU运行任务时，需要知道任务从哪里加载从哪里运行因此需要保存好**程序计数器（PC，记录了下一条要执行的指令的地址）**、**寄存器（存储当前执行指令所需要的数据、地址、状态信息等）**，这个就叫CPU上下文

- 系统内核会存储保存下来的上下文信息，任务再次分配给CPU运行时，CPU重新加载这些上下文保证任务原来的状态不受影响，让任务看起来是连续的，任务指的是**进程、线程、中断**因此有进程上下文切换、线程上下文切换、中断上下文切换

- **进程由内核管理核调度**，进程的上下文切换不仅包含了**虚拟内存、栈、全局变量等用户空间的资源，还包括内核堆栈、寄存器等内核空间的资源**

  ![进程上下文切换](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpg)

  ![image-20240913111406434](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913111406434.png)

## 线程

**线程（Thread）是调度的基本单位，进程（Process）是资源拥有的基本单位**

- 线程的上下文切换

  - 当两个线程属于同一个进程时，因为**虚拟内存是共享的**所以在切换时虚拟内存这些资源就保持不动，**只需要切换线程的私有数据、寄存器等不共享的数据**
  - 两个线程不是同一个进程时，切换的过程跟进程上下文切换一样

  

#### 线程的实现

![image-20240913112035427](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913112035427.png)

![image-20240913112042912](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913112042912.png)

![image-20240913112204582](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913112204582.png)

#### 调度原则

![image-20240913112454910](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913112454910.png)

## 多线程

![image-20240913113455965](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913113455965.png)

两个线程同时对同一块内存进行读写

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/8-%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B.jpg)

假如此时i为50，A线程读完放在寄存器，在寄存器计算完要写入内存前，**中断发生操作系统保存好线程上下文给线程控制块TCB**，B线程也读了同块内存的数据给寄存器计算，再将读取寄存器的值写入内存于是内存里的i=51;又发生一次线程上下文切换，A线程写入内存i又变为51

![蓝色表示线程 1 ，红色表示线程 2](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/9-%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5-%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B-%E7%AB%9E%E4%BA%89.jpg)

### 互斥

![互斥](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/10-%E4%B8%B4%E7%95%8C%E5%8C%BA.jpg)

### 同步

在并发线程上需要互相等待互通消息，**这种互相制约的等待与互通消息就是进程/线程同步**，其实就是需要有先后次序

**互斥：不能同时；同步：有先后**

### 互斥与同步的实现

#### 锁

![image-20240913121512516](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913121512516.png)

##### 忙等待锁/自旋锁

- 当一个线程试图获取一个被占用的忙等待锁时，**它会持续不断地检查锁是否可用**，这个过程中线程一直处于活跃状态，不断地 “忙碌等待” 锁的释放。

- 例如，线程就像一个在门口**不断敲门询问**是否可以进入房间的人，它不会去别的地方休息等待，而是一直在门口循环询问。

- 优点

  - **响应速度快**：如果锁很快就被释放，那么忙等待锁可以让线程迅速获取锁并继续执行，因为线程一直在等待，不需要进行上下文切换等额外的操作。
  - **适用于短时间等待**：当预计锁的持有时间很短时，忙等待锁可以避免上下文切换的开销，提高性能。

- 缺点

  - **浪费 CPU 资源**：如果锁长时间被占用，忙等待的线程会持续占用 CPU 时间，不断循环检查锁的状态，而其他线程可能无法得到足够的 CPU 资源，导致系统整体性能下降。

    ![image-20240914183404385](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240914183404385.png)

    

##### 无忙等待锁/互斥锁

![image-20240914183949677](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240914183949677.png)

- 当一个线程试图获取一个被占用的无忙等待锁时，它会进入**阻塞状态，释放 CPU 资源**，不再占用 CPU 进行循环检查。
- 就像一个人在门口等待进入房间，如果门被锁住了，他会去旁边的椅子上**坐下休息等待**，而不是一直在门口敲门询问。当锁被释放时，操作系统会唤醒这个被阻塞的线程，让它继续执行。

![image-20240914183734059](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240914183734059.png)

- 优点：

  - **节省 CPU 资源**：当线程等待锁时进入阻塞状态，释放 CPU 资源给其他线程使用，避免了忙等待锁中浪费 CPU 资源的问题，提高了系统的整体性能。
  - **适合长时间等待**：对于可能需要长时间等待锁释放的情况，无忙等待锁是更好的选择，因为线程不会持续占用 CPU 资源。

- 缺点

  - **上下文切换开销**：当线程从阻塞状态被唤醒时，会涉及到上下文切换的开销。但是，在长时间等待的情况下，这种开销通常比忙等待锁浪费的 CPU 资源要小。

    

    ![image-20240914183322838](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240914183322838.png)

    

#### 信号量

信号量表示资源的数量

- P操作：用于**申请资源**。**-1后若信号量<0则进入阻塞等待**，如果**信号量的值为零，则线程会被阻塞**，等待资源变为可用。

- V操作：用于**释放资源**。**+1后若>=0则唤醒等待中的线程**，通知其他正在等待资源的线程资源已可用。

![信号量与火车轨道](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/16-%E7%81%AB%E8%BD%A6PV%E6%93%8D%E4%BD%9C.jpg)

#### 信号量与锁的区别与联系

在一定程度上，将信号量初始值设为 1 可以实现类似互斥锁的功能，但它们之间还是存在一些细微的差别：

**相似之处**

- **资源访问控制**
  - 当信号量初始值设为 1 时，在同一时刻只有一个线程能够成功调用 `WaitOne` 方法获取信号量，这和互斥锁的行为类似，即同一时刻只有一个线程可以进入临界区（被保护的代码区域）。
  - 无论是信号量还是互斥锁，都可以用来防止多个线程同时访问共享资源，确保共享资源在某一时刻只被一个线程使用。

**不同之处**

- **信号量的计数特性**
  - 信号量具有计数的概念。虽然初始值设为 1，**但可以在程序中通过多次调用 `Release` 方法来增加信号量的值，从而允许更多的线程同时获取信号量**。例如，如果信号量的值被增加到 3，那么就可以有 3 个线程同时获取信号量并进入临界区。
  - 而互斥锁在任何时候都只允许一个线程拥有锁，不存在计数的概念，也不能手动增加可拥有锁的线程数量。
- **释放机制**
  - 对于信号量，一个线程可以在没有获取到信号量的情况下多次调用 `Release` 方法来增加信号量的值。
  - 而互斥锁必须由拥有锁的线程来释放锁，如果一个线程没有获取到锁而尝试释放锁，这在大多数互斥锁的实现中是不允许的，会导致错误。
- **使用场景和语义**
  - **互斥锁主要用于保护共享资源的独占访问，强调的是对资源的排他性保护**。例如，当多个线程需要访问一个共享的数据结构（如链表、树等）进行读写操作时，使用互斥锁可以确保在任何时候只有一个线程在操作该数据结构。
  - **信号量更侧重于对资源数量的控制**，它可以用于表示有限数量的资源可供多个线程使用的情况。例如，系统中有 3 个打印机资源，多个线程需要打印文档，通过信号量可以控制同时最多有 3 个线程可以获取打印机资源进行打印操作。

#### 生产者-消费者问题

1. **生产者线程**：负责生产数据项，并将其放入一个共享缓冲区中。
2. **消费者线程**：从共享缓冲区中取出数据项进行消费。

##### 问题关键

- 同步：确保生产者在缓冲区满时不能生产，消费者在缓冲区空时不能消费，即一定是生产者->消费者->生产者的次序
- 互斥：保证同一时间只有一个线程访问共享缓冲区

##### 信号量

1. empty：缓冲区空位置数量，用于**消费者询问缓冲区是否有空位**
2. full：缓冲区已占用位置数量，用于**生存者询问缓冲区是否有空位**
3. mutex：缓冲区互斥访问

##### 生产者线程操作

1. P(empty)，若已满说明消费者还没消费
2.  获得空位置后，进行mutex锁定
3. 数据项放入缓冲区
4. 释放mutex
5. V(full)，通知可以开吃了

##### 消费者线程操作

1. P(full)等待已占用位置
2. 获得占用位置后，mutex
3. 从缓冲区取出数据项
4. 释放mutex
5. V(empty)，增加空位置数量

##### 为什么需要empty和full两个

假设一个简单的缓冲区，只能容纳一个数据项。如果只有一个信号量`s`，初始值为 1。生产者线程和消费者线程的操作如下：

1. 生产者线程：
   - 执行`P(s)`操作，信号量`s`的值变为 0。
   - 将数据放入缓冲区。
   - 执行`V(s)`操作，信号量`s`的值变为 1。我该通知下一个生产者还是消费者呢？
2. 消费者线程：
   - 执行`P(s)`操作，信号量`s`的值变为 0。
   - 从缓冲区取出数据。
   - 执行`V(s)`操作，信号量`s`的值变为 1。我该通知下一个消费者还是生产者呢？

**在这个例子中，无法确定缓冲区的当前状态是满还是空。如果生产者线程连续生产两个数据项而消费者线程还未消费，由于没有区分满和空的机制，可能会导致数据覆盖或者错误的消费操作。**

#### 读者-写者问题

有一个共享的资源（比如一个文件、数据库或内存中的数据结构），**可以被多个读者线程同时读取，但在任何时候只能有一个写者线程对其进行写入操作**。如果一个写者正在写入数据，那么其他的读者线程和写者线程都必须等待，直到写者完成写入操作。**如果一个读者正在读取数据，其他读者可以同时进行读取**，但写者必须等待所有读者完成读取后才能进行写入操作。

##### 同步与互斥

- 互斥：同一时间只有一个线程可以访问共享资源进行读取或写入
- 同步：readCountSemaphone信号量**控制读者数量**；writeSemaphore信号量用于**写者互斥访问**

##### 读者线程

1. mutex + P(readCountSemaphone),**防止多个读者同时增加导致数据不一致**，与生产者-消费的**区别在这，有多个读者**
2. 第一个读者P(writeSemaphore)防止写者介入
3. 读取共享资源
4. 读取完成，mutex + V(readCountSemaphone)
5. 若是最后一个读者，P(writeSemaphore)

##### 写者线程

1. P(writeSemaphore)
2. 写入共享资源
3. V(writeSemaphore)

#### 哲学家就餐问题

有五位哲学家围坐在一张圆桌旁，每位哲学家面前有一盘食物和一把叉子。哲学家的生活就是思考和吃饭，他们在思考一段时间后会感到饥饿，然后尝试拿起左右两边的叉子吃饭，吃完后又放下叉子继续思考。但是，为了成功吃饭，哲学家必须同时拿到左右两把叉子。如果所有哲学家同时拿起左边的叉子，那么他们都无法拿到右边的叉子，从而导致死锁，大家都无法吃饭。

##### 法1

1. think()
2. P(fork[i])
3. P(fork[(i+1)%N])
4. eat()
5. V(fork[(i+1)%N])
6. V(fork[(i+1)%N])

由于没有互斥，可以同时拿一把叉子

![方案一的问题](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/25-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%B8%80%E9%97%AE%E9%A2%98.jpg)

##### 法2

加互斥，5把叉子最好是2人同时吃，但是就只有一个人能吃，效率极低

![image-20240913125121700](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913125121700.png)

##### 法3

避免同时拿一边的叉子

![image-20240913125229360](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240913125229360.png)

##### 法4

引入资源分配者服务员

- 服务员负责决定哪个哲学家可以获取叉子。由于服务员可以看到全局的状态，能够避免所有哲学家同时拿起左边叉子的情况，从而防止死锁。
- 例如，当一个哲学家请求吃饭时，服务员会检查当前的资源分配情况，如果允许该哲学家获取叉子，就给予批准；否则，让哲学家等待。

![方案四也可解决问题](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/31-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B-%E5%9B%BE%E8%A7%A3.jpg)

#### 死锁

**死锁的定义**

死锁是指在多线程或多进程环境下，**两个或多个线程（进程**）在执行过程中，因争夺资源而造成的一种互相等待的现象。此时，这些线程（进程）都无法继续执行下去，它们被永久地阻塞，除非操作系统或其他外部因素介入来打破这种僵局。

**产生死锁的原因**

- 互斥条件
  - 资源不能被共享，只能由一个线程（进程）使用。例如，打印机在同一时刻只能被一个进程使用，如果另一个进程也需要使用打印机，就必须等待。
- 请求与保持条件
  - 线程（进程）已经保持了至少一个资源，但又提出了新的资源请求，而新请求的资源被其他线程（进程）占有，此时请求线程（进程）被阻塞，但又对自己已有的资源保持不放。例如，线程 A 已经获取了资源 R1，现在又请求资源 R2，而资源 R2 被线程 B 占用，同时线程 A 不释放资源 R1。
- 不可剥夺条件
  - 资源只能由拥有它的线程（进程）主动释放，其他线程（进程）不能强行剥夺。例如，一个进程获得了打印机的使用权，在它完成打印任务之前，其他进程不能强行占用打印机。
- 循环等待条件
  - 存在一组线程（进程），其中每个线程（进程）都在等待下一个线程（进程）所占用的资源，形成了一个资源等待的循环链。例如，线程 A 等待线程 B 占用的资源 R2，线程 B 等待线程 C 占用的资源 R3，而线程 C 又等待线程 A 占用的资源 R1，这样就形成了一个循环等待的死锁环。





产生死锁的必要条件是什么？

如何避免死锁？

死锁检测和死锁恢复的方法有哪些？

#### 读写锁 

读写锁（Read - Write Lock）是一种同步机制，它与普通的互斥锁（Mutex）类似，但在处理读和写操作的并发访问上更加灵活，主要具有以下特点：

**读共享与写独占**

- **读操作**：**多个线程可以同时获取读锁，**进行并发的读操作。这意味着当没有线程持有写锁时，多个线程可以同时读取共享资源，从而提高了读操作的并发性能。
- **写操作**：当一个线程需要进行写操作时，它必须获取写锁。**写锁是独占的，即当一个线程持有写锁时，其他线程（无论是读操作还是写操作）都无法获取锁，直到写锁被释放**。这确保了在写操作期间，共享资源的完整性和一致性不会被破坏。

**实现原理**

- **内部状态管理**
  - 读写锁内部维护了当前读锁的数量和写锁的状态。当一个线程请求读锁时，如果没有线程持有写锁，那么读锁数量加 1，线程可以进入临界区进行读操作。
  - 当一个线程请求写锁时，读写锁会检查是否有其他线程持有读锁或者写锁，如果没有，则该线程可以获取写锁；否则，它将被阻塞，直到所有的读锁和写锁都被释放。
- **排队机制**
  - 读写锁通常会维护一个等待队列，用于管理等待获取锁的线程。当一个线程无法立即获取到所需的锁（读锁或写锁）时，它会被放入等待队列中。
  - 锁的释放和分配是按照一定的规则进行的。例如，当写锁被释放后，如果等待队列中有等待读锁的线程，那么这些线程可以按照一定的顺序（如先来先服务）获取读锁；如果等待队列中只有等待写锁的线程，那么其中一个线程可以获取写锁。

**使用场景示例**

- **数据缓存系统**
  - 在一个数据缓存系统中，多个线程可能需要频繁地读取缓存中的数据，而偶尔会有一个线程负责更新缓存数据。
  - 使用读写锁可以允许多个线程同时读取缓存，提高读取效率，同时在更新缓存时确保数据的一致性。
- **数据库访问**
  - 在数据库操作中，多个事务可能同时对数据库中的数据进行读取操作，而写操作相对较少。
  - 读写锁可以用于控制对数据库记录的并发访问，提高系统的整体性能。

##### 公平读写锁

**公平读写锁的概念**

1. 普通读写锁允许多个读线程同时访问共享资源，而写线程需要独占访问。在读写锁的基本实现中，读线程和写线程在获取锁时可能存在不公平的竞争。
2. 公平读写锁则在锁的分配机制上进行了优化，它保证了等待时间最长的线程（无论是读线程还是写线程）最先获得锁。**即按照线程请求锁的先后顺序来分配锁，避免了某些线程长时间等待而无法获取锁的情况**，保证了锁分配的公平性。

**公平读写锁的特点**

- 有序性
  - 所有请求锁的线程会按照它们发出请求的时间顺序被放入一个队列中。当锁可用时，锁会被分配给队列头部的线程，确保先来先服务的原则。
- **避免饥饿**
  - 在非公平锁中，可能会出现某些线程一直无法获取锁的情况，这种现象称为饥饿。公平读写锁通过有序地分配锁资源，能够有效避免读线程或写线程被饿死，保障了系统的整体公平性。
- 性能影响
  - 虽然公平读写锁保证了公平性，但维护请求锁的队列以及按照顺序分配锁会带来一定的性能开销。在锁竞争不激烈的情况下，**这种开销可能会使程序的性能略低于非公平读写锁**。然而，在锁竞争激烈且对公平性有较高要求的场景下，公平读写锁能够提供更稳定和可预测的性能。

##### Invoke & BeginInvoke

在.NET 中，`Invoke`和`BeginInvoke`主要用于在 Windows 窗体应用程序等基于 UI 线程的环境中与 UI 元素进行交互。以下是它们的区别：

**`Invoke`方法**

- **同步执行**
  - `Invoke`是一个**同步**方法。当在非 UI 线程中调用`Invoke`时，它会阻塞当前线程的执行，直到 UI 线程执行完委托的方法。
  - 例如，如果在一个工作线程中调用`Invoke`来更新 UI 元素，工作线程会暂停，直到 UI 线程完成更新操作后才继续执行后续代码。
- **使用场景**
  - 适用于需要确保在 UI 线程上执行操作并且需要等待操作完成的情况。比如在更新 UI 元素时，如果后续操作依赖于 UI 元素更新完成，就可以使用`Invoke`。

**`BeginInvoke`方法**

- **异步执行**
  - `BeginInvoke`是**异步**执行的。当在非 UI 线程中调用`BeginInvoke`时，它会立即返回，不会阻塞当前线程，委托的方法会在 UI 线程的消息队列中排队等待执行。
  - 例如，在一个工作线程中调用`BeginInvoke`后，工作线程可以继续执行其他任务，而 UI 线程会在适当的时候处理排队的委托方法。
- **返回值和回调机制**
  - `BeginInvoke`返回一个`IAsyncResult`对象，可用于检查异步操作的状态。并且可以通过提供一个回调方法，在异步操作完成后在 UI 线程上执行额外的操作。
  - 这种机制使得在执行异步 UI 更新的同时，可以在操作完成后执行一些后续处理，而不需要手动检查操作是否完成。
- **使用场景**
  - 适用于不希望阻塞当前线程的情况，尤其是在执行一些耗时的 UI 操作时，可以提高程序的响应性。例如，在后台线程中频繁地更新 UI 进度条，可以使用`BeginInvoke`来避免阻塞后台线程的工作。

##### Monitor类

在 C# 中，`Monitor`类是一个用于线程同步的机制，**基于对象的锁**

**基本概念**

- `Monitor`类主要用于确保在同一时刻只有一个线程可以访问特定的代码块，即临界区。它通过对对象进行加锁和解锁操作来实现线程同步。

**主要方法**

- **`Enter`方法**
  - 当一个线程调用`Monitor.Enter(object obj)`时，它会尝试获取与`obj`关联的锁。如果锁当前没有被其他线程持有，那么调用线程将获得锁并继续执行临界区代码。如果锁已经被其他线程持有，调用线程将被阻塞，直到锁被释放。
- **`Exit`方法**
  - 当线程完成对临界区的操作后，必须调用`Monitor.Exit(object obj)`来释放锁，这样其他等待该锁的线程才有机会获取锁并执行临界区代码。
- **`Wait`、`Pulse`和`PulseAll`方法**
  - **`Wait`方法**：当一个线程在临界区内调用`Monitor.Wait(object obj)`时，它会释放与`obj`关联的锁，并进入等待状态，直到其他线程调用`Pulse`或`PulseAll`方法。
  - **`Pulse`方法**：在持有锁的线程中调用`Monitor.Pulse(object obj)`，它会通知在`obj`上等待的单个线程（如果有），让其从等待状态变为就绪状态。被通知的线程不会立即执行，而是要等到锁被当前持有线程释放后才能获取锁并继续执行。
  - **`PulseAll`方法**：类似于`Pulse`方法，但它会通知所有在`obj`上等待的线程。

**与`lock`关键字的关系**

- 在 C# 中，`lock`关键字是一种简化的语法糖，它在内部使用了`Monitor`类来实现。例如，`lock(obj) { // 临界区代码 }`等价于以下代码：

```csharp
Monitor.Enter(obj);
try
{
    // 临界区代码
}
finally
{
    Monitor.Exit(obj);
}
```

**使用场景**

- 用于保护共享资源，防止多个线程同时对其进行访问而导致数据不一致或其他并发问题。例如，在多个线程同时操作一个共享集合或者共享数据结构时，可以使用`Monitor`类来确保线程安全。

#### 乐观锁

![image-20240914184752061](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240914184752061.png)

- 适用场景
  - 适用于读操作比较频繁，而写操作相对较少且冲突较少的场景。因为它减少了锁的开销，能够提高并发性能。例如在一些电商系统中，查询商品信息的操作远远多于更新商品库存的操作，此时使用乐观锁可以提高系统的响应速度。

##### .Load

`this.Load += new System.EventHandler(this.Form2_Load);`

**在 Windows Forms 应用程序中的事件处理**

- **事件和事件处理程序**
  - 在 Windows Forms 编程中，`Load`是窗体（Form）的一个事件。**当窗体正在被加载到内存中，并且在它变得可见之前，`Load`事件会被触发**。
  - `System.EventHandler`是一个委托类型。委托在 C# 中用于封装一个方法，使得这个方法可以作为参数传递给其他方法或者存储在变量中，在特定的事件触发时被调用。
  - `this.Form2_Load`是一个与`EventHandler`委托签名匹配的方法，也就是事件处理程序。这个方法定义了在`Load`事件触发时要执行的具体操作。
- **注册事件处理程序**
  - `this.Load += new System.EventHandler(this.Form2_Load);`这行代码的作用是将`Form2_Load`方法注册为`Load`事件的处理程序。
  - `+=`运算符用于向事件添加一个或多个处理程序。当`Load`事件被触发时（例如，当窗体启动并开始加载时），所有注册到该事件上的方法（在这种情况下是`Form2_Load`方法）都会被依次调用。