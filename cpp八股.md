# CPP八股

## 基础语法

### 1. main函数执行之前和之后的 代码可能是什么

- main函数运行之前

  - 初始化全局`global`和静态变量`static`，`.data`(data segment，占用实际磁盘空间)段

    ```
         int global_var = 42;
         static int static_var = 100;
    ```

  - 自动初始化**未赋初值**的`global`和`static`对象，bool为FALSE，指针为NULL，数值型为0等；即`.bss`段(block started by symbol segment，不占用实际磁盘空间，因为只存储未初始化的数据占位符，当程序加载到内存时，`.bss`段会被初始化为0或空指针不需从磁盘复制数据，因此省磁盘空间)

  - 初始化**全局对象**

  - 设置栈指针

  - 将main函数的参数`argc`，`argv`传递给main函数，然后运行真正的main

  - `__attribute__((construtor))`是一个编译器特定的属性，用于指定一个函数在程序启动时（在`main`函数执行之前）自动被调用，就像一个构造函数一样。

    ```cpp
    #include <stdio.h>
    
    void init_function() __attribute__((constructor));
    
    void init_function() {
        printf("This function is called before main.\n");
    }
    
    int main() {
        printf("This is the main function.\n");
        return 0;
    }
    ```

- 运行之后

  - 全局对象析构函数在main函数之后执行

  - `__attribute__((destructor))`：是一个编译器特定的属性，用于指定一个函数在程序结束时（在`main`函数执行之后）自动被调用，就像一个析构函数一样。

  - ```c
    #include <stdio.h>
    
    void cleanup_function() __attribute__((destructor));
    
    void cleanup_function() {
        printf("This function is called after main.\n");
    }
    
    int main() {
        printf("This is the main function.\n");
        return 0;
    }
    ```

  - `atexit`是一个函数，用于注册一个在程序正常终止时被调用的函数。

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    void cleanup() {
        printf("Cleanup function called.\n");
    }
    
    int main() {
        atexit(cleanup);
        printf("Main function.\n");
        return 0;
    }
    ```

    ### 

### 2. 结构体内存对齐问题

- `alignof`：**返回**内存对齐的大小
- `alignas`：**指定**内存对齐的大小

```c
struct alignas(32) MyStruct {
  int a;
  double b;
};
std::cout << "alignof(MyStruct): " << alignof(MyStruct) << std::endl; // 32
std::cout << "sizeof(MyStruct): " << sizeof(MyStruct) << std::endl; // 32：alignas指定了对齐方式为 32 字节，为了满足对齐要求，结构体的大小需要是 32 字节的整数倍。
//int a占 4 字节，double b占 8 字节，总共是 12 字节，但是为了满足对齐要求，结构体的大小需要向上取整到 32 字节。

struct  MyStruct {
  int a;
  double b;
};
std::cout << "alignof(MyStruct): " << alignof(MyStruct) << std::endl; // 8
std::cout << "sizeof(MyStruct): " << sizeof(MyStruct) << std::endl; // 4字节的int要与最大的double8个字节对齐，16
```



### 3. 指针和引用区别

- 指针是**变量**，存储另一个变量的地址；引用是另一个变量的别名
- 指针在内存中为固定大小（**32位系统是4字节，64位系统8字节**）；**引用本身不占用额外空间**，是另一个变量的别名
- 指针可以**重新赋值**；引用一旦初始化就不能再绑定其他对象，**整个生命周期始终指向同一个对象**
- 指针可以是空指针；引用一定要绑定到一个有效变量，**不存在空引用**



### 4. 传递函数参数时，指针和引用区别

- **类对象**作为参数传递时使用引用
- **栈空间大小敏感（递归）**使用引用，因为**引用不用开辟新空间**
- 需返回**局部变量内存**使用指针，用完记得释放指针的内存不然会泄露



### 5. 栈和堆的区别

- 栈由系统**自动分配，操作系统在底层有分配专门的寄存器存放栈的地址，入栈出栈有专门的指令执行，速度快，不会有碎片**；堆由程序员申请和释放，**由C/C++函数库提供，获取堆内容需要两次访问第一次指针第二次指针保存的地址访问内存**，速度慢，会有碎片
- 栈空间默认4MB，从**高地址向低地址增长**；堆一般1-4GB，从低地址向高地址增长
- 栈存放**函数的局部变量、函数参数**、返回地址等；存放**动态分配的对象**（c++ new和delete；c malloc和free）、数据结构

1. **栈和堆的区别**
   - 存储方式与管理机制
     - **栈**：是一种先进后出（FILO）的数据结构。在程序运行过程中，栈主要用于存储局部变量和函数参数。栈的内存分配和释放是由编译器自动管理的。当一个函数被调用时，函数的参数和局部变量会在栈上分配空间，函数执行结束后，这些空间会自动释放。例如，在以下函数中：

```cpp
void func(int param) {
    int local_variable = 10;
    // 函数执行过程中，param和local_variable存储在栈区
}
```

- 当`func`函数被调用时，`param`和`local_variable`会在栈上分配空间，**函数结束后自动回收。栈的大小通常是由编译器或者操作系统预先设定的，相对比较固定。**
- **堆**：用于动态分配内存，程序员可以通过`malloc`、`calloc`、`realloc`（C 语言）或者`new`、`delete`（C++）等操作符和函数在堆上分配和释放内存。堆的内存分配是比较灵活的，没有像栈那样的固定模式，其大小只受限于系统的物理内存和虚拟内存大小。例如，在 C++ 中：

```cpp
int* ptr = new int;
*ptr = 20;
// 此时，int类型的内存是在堆区分配的，需要使用delete来释放
delete ptr;
```

- 这里通过`new`在堆上分配内存，使用完后要通过`delete`释放，堆区内存管理由程序员负责。
- 内存分配效率
  - **栈**：**栈的内存分配效率非常高**，因为它的操作相对简单。只需要**移动栈顶指针就可以完成内存的分配和释放**，这种操作的时间复杂度基本是**常数级别**的。例如，每次函数调用和返回时，栈顶指针的移动是非常快速的。
  - **堆**：堆的内存分配相对复杂。当在堆上分配内存时，内存管理系统（如`malloc`的实现）**需要遍历空闲链表**来寻找合适的空闲内存块，可能还需要**进行内存块的分割、合并**等操作。**如果没有合适的空闲内存块，可能还需要向操作系统请求更多的内存**，这些过程使得堆的内存分配效率比栈低。
- 内存空间连续性
  - **栈**：栈上的内存空间是**连续的**，这种连续性使得 CPU 在访问栈上的数据时效率较高，因为 C**PU 的缓存机制能够更好地利用这种连续性**。例如，局部变量在栈上连续存储，CPU 在读取这些变量时可以利用缓存预取等技术来提高访问速度。
  - **堆**：堆上分配的内存块在物理地址上**不一定是连续**的。频繁的内存分配和释放可能会导致**内存碎片化，即堆中出现许多大小不一的空闲内存块**，这可能会影响后续内存分配的效率，并且在访问堆上的数据时，由于内存块可能不连续，CPU 缓存的利用率可能不如栈高。
- 内存安全性
  - **栈**：栈相对比较安全，因为栈的内存管理是**自动**的，编译器会自动处理函数调用和返回时的栈帧操作，只要不出现栈溢出（如递归过深或者局部变量占用空间过大）等异常情况，栈上的内存使用不容易出现内存泄漏、悬空指针等问题。
  - **堆**：堆的使用如果不小心，很容易出现**内存泄漏（忘记释放内存）、悬空指针（释放内存后继续使用指针）等问题，这些问题可能会导致程序崩溃或者出现未定义行为**。

2. **为什么不全部用栈**

- **动态内存需求**：栈的大小是有限的，并且在编译时基本就确定了其大小范围。如果所有内存都在栈上分配，对于一些需要在运行时动态确定大小的数据结构（如动态数组、链表等）就无法处理。例如，一个程序需要根据用户输入来创建一个大小不确定的数组，栈无法满足这种需求，因为**栈没有足够的空间来存储任意大小的动态数组**。
- **对象生命周期管理的灵活性**：栈上的对象生命周期是由函数调用和返回决定的，当函数结束时，栈上的对象就会被销毁。对于一些需要在函数外部长期存在的对象，栈无法提供合适的存储方式。例如，一个全局对象或者一个在多个函数之间共享的对象，不能存储在栈上，因为栈上的对象会随着函数的结束而销毁。

3. **为什么不全部用堆**

- **效率问题**：如果全部使用堆，由于堆内存分配和释放的**效率相对较低**，程序的性能会受到很大影响。特别是对于那些频繁调用的函数中的局部变量，如果都在堆上分配，每次函数调用都要进行复杂的堆内存分配操作，会大大降低程序的运行速度。
- **内存管理复杂性**：全部使用堆会大大增加程序员的内存管理负担。因为堆需要程序员**手动释放内存，很容易出现内存泄漏等问题**。相比之下，栈的自动内存管理机制使得程序员不需要关注局部变量和函数参数的内存释放问题，减少了出错的可能性。

###  6 区分以下指针类型

```cpp
int *p [10]; // 数组，元素是指针
int (*p) [10]; // 指针，指向数组
int *p (int); // 函数，返回int型指针
int (*p) (int); // 指针，指向int型参数int型返回类型的函数
```



### 7. new/delete 和 malloc/free区别

- new是**操作符，支持重载**，需要**编译器**支持；malloc是c/c++标准库函数，需要**头文件**支持

- new自动计算分配的空间大小，**返回的是具体类型指针**；malloc要手动计算，且**返回的是void型指针必须进行强制的类型转换**，类型不安全

  ```cpp
  // 指向的int对象值为5，不是内存p大小为5
  int *p = new int(5);
  delete a;
  // 数组大小为5
  int *a = new int[5];
  delete [] a;
  // 返回的是void型指针必须进行类型转换
  int *a = (int*)malloc(sizeof(int));
  free(a);
  ```

- new/delete是操作符，与面向对象紧密结合，**适合非基本数据类型的对象，自动调用对象的构造函数和析构函数**进行对象进行创建和销毁；malloc/free库函数只分配和销毁内存，**不进行对象构造和析构**

- `free`回收的内存不会立即还给系统，而是被**`ptmalloc`双链表**保存起来用户下一次申请内存就从这些内存寻找合适的返回，避免频繁调用；`patmalloc`也会对小块内存进行合并，避免过多的内存碎片

- new内存分配失败**抛出bac_alloc异常**；malloc内存分配失败**返回NULL**

- 构造函数和析构函数的调用

  - new
    - 当使用 new 分配一个类对象时，它会**先分配足够的内存，然后调用该对象的构造函数**来初始化对象。例如，`MyClass* p = new MyClass;`会调用`MyClass`的构造函数来初始化对象。在释放对象内存时，**使用`delete`会先调用对象的析构函数，然后再释放内存**。
  - malloc
    - malloc 只是单纯地分配内存，不会调用构造函数。如果用 malloc 分配的内存用于存储一个类对象，需要程序员手动调用构造函数来初始化对象（这在 C++ 中是不推荐的，不符合面向对象的编程规范）。同样，在释放内存时，使用`free`函数只是简单地释放内存，不会调用析构函数。

- 内存分配位置

  - new
    - new 是 C++ 中的操作符，它在自由存储区（free store）分配内存。自由存储区是 C++ 中通过 new 和 delete 管理的内存区域，它的实现可以基于堆（heap），但在概念上和堆还是有所区别。例如，在某些嵌入式系统或者特定的 C++ 实现中，自由存储区的管理方式可能与常规的堆管理不同。
  - mallo
    - malloc 是 C 语言中的函数，它主要在堆（heap）上分配内存。堆是程序运行时用于动态分配内存的一块区域，它由操作系统管理，所有动态分配的内存块都存储在堆中，直到被手动释放。






### 8. new/delete是如何实现的

- **new先调用operator new进行分配内存**，后调用对象构造函数进行对象构造
- **delete先调用对象析构函数**，后调用operator delete释放内存



### 9. 宏定义与函数、typedef区别

```cpp
#define PI 3.14159
#define SQUARE(x) ((x)*(x))
// 预处理器会在代码中查找宏定义的标识符，并将其替换为对应的文本内容。例如，定义#define PI 3.14159，在预处理阶段，代码中所有出现PI的地方都会被替换成3.14159这个常量。这个过程就像是在文本编辑阶段进行的查找和替换操作，并没有为PI这个宏分配实际的内存空间。

int square(int x) { return x * x; } // 需要使用square(5)
typedef int myIntType; // 定义了一个新的类型名myIntType，它实际上是int类型的别名
```



- 宏定义没有类型检查，在**预处理阶段**即编译前完成，只是简单的文本替换；函数有严格的**类型检查**（参数类型、返回类型），**编译时**进行检查；`typedef`也是**编译**的一部分，会检查数据类型
- 宏效率高，相当于直接插入代码不需要调用；函数需要**一定开销**
- 宏在**整个文件可见**；函数有明确定义域；typedef也有明确定义域
- 宏**不是语句，不加分号**；调用函数、声明函数都要加分号；typedef也是语句，要加分号

```cpp
// 在声明变量时更加简洁。当使用typedef为struct Point创建别名后，如typedef struct Point Point;，在后续代码中声明Point类型的变量时，就可以直接写Point p;，而不需要再写struct Point p;。    
typedef struct {
         int x;
         int y;
     } Point;
     Point p;  
// 这种方式在 C 语言风格的 C++ 代码或者简单的小型程序中是很常见的。每次声明Point类型的变量时都需要带上struct关键字，这在语法上是比较明确的，能清楚地看到这是一个结构体类型的变量声明。
struct Point {
       int x;
       int y;
   };
   int main() {
       struct Point p;
       p.x = 1;
       p.y = 2;
       // 其他操作
       return 0;
   }
```



### 10. 变量声明和定义区别

- 变量声明向编译器告知变量的存在，**但不分配内存空间或进行初始化**。它只是告诉编译器变量的**名称、类型和可能的作用域**。

  ```cpp
  extern int variable; 
  // 这里的extern关键字表示这是一个外部变量声明，告诉编译器这个变量在其他地方定义
  ```

- 变量定义不仅向编译器告知变量的存在，**还为变量分配内存空间**，并可以进行初始化。**一个变量在程序中可以有多个声明；但是只能有一个定义；**

### 11 strlen、sizeof、size()区别

- `sizeof`是一个**运算符**，用于在**编译时**确定给定类型或变量所占用的**字节数**；strlen是字符处理的库函数；对于**标准容器类**（如`std::vector`、`std::string`等），`size`是一个成员函数，用于在**运行时**确定**容器中元素的数量**。
- `sizeof`的结果在**编译时**就确定了，不依赖于程序的运行状态，返回值是一个`size_t`类型的无符号整数，表示**字节数**。对数组名**返回的是整个数组的大小而不是数组首元素的指针大小**；strlen只接受以'\0'结尾的字符数组
- sizeof返回值是无符号整数类型，表示字节数；strlen，返回值是`size_t`类型，通常是无符号整数类型，表示字符串的长度（字符个数）。
- `sizeof`：
  - 常用于确定数据类型的大小，以便进行内存分配、缓冲区大小计算等操作。
  - 在处理底层数据结构或进行与内存布局相关的操作时很有用。
- `size`：
  - 主要用于处理容器类对象，了解容器中当前存储的元素数量。
  - 在遍历容器、判断容器是否为空等操作中经常使用。

```cpp
int myArray[10];
std::vector<int> myVector;
// 编译时已确认
std::cout << "Size of myArray: " << sizeof(myArray) << std::endl; // 40
std::cout << "Size of int: " << sizeof(int) << std::endl; // 4

myVector.push_back(1);
myVector.push_back(2);
myVector.push_back(3);

std::cout << "Size of myVector: " << myVector.size() << std::endl; // 3，元素个数
```

`example2`

```c
void UdpServer::SendError() {
  std::string error;
  sendto(server_fd_, error.c_str(), error.size(), 0,
         (const struct sockaddr *)&client_addr_, sizeof(client_addr_));
}
```

1. 如果将 `error.size()` 替换为 `sizeof(error)`，这通常是不正确的做法，会产生错误的结果。

   - `sizeof(error)` 返回的是 `std::string` 类对象本身的大小，而不是字符串内容的长度。**`std::string` 对象通常包含一些额外的成员变量用于管理字符串**，如指向动态分配内存的指针、字符串长度、缓冲区大小等。这个大小通常远大于实际字符串内容的长度。

   - 而 `error.size()` 返回的是字符串中字符的数量，不包括结尾的空字符，它准确地反映了字符串内容的长度，这是在向网络发送数据时所需要的正确长度。

2. 因为 `sendto` 函数需要**知道目标地址结构体的大小**，以便正确地处理和解析地址信息。**不同类型的地址结构体（如 `sockaddr_in`、`sockaddr_in6` 等）可能有不同的大小**，通过传递正确的大小，函数可以确保在处理地址时不会访问超出结构体范围的内存，从而保证程序的安全性和正确性。

3. `error.c_str()`返回一个**指向以空字符结尾的字符数组的指针（const char*）**。这个指针指向的内存区域包含了与`error`字符串内容相同的字符序列，但这个指针所指向的内存是临时的，不应该被修改，并且**其有效性与`error`对象的生命周期相关。**

   - 用途：通常用于将`std::string`对象传递给需要以传统 C 风格字符串（以空字符结尾的字符数组）作为参数的函数。例如，一些 C 语言的函数或者**某些 C++ 函数接口要求传入 C 风格字符串**，这时可以使用`c_str()`来满足这种需求。

### 12. 常量指针和指针常量区别

- 常量指针，**指向的对象是常量**，用于函数传参以确保函数内部不能修改传入的对象。例如：`void printValue(const int* value);`，在这个函数中，不能通过`value`指针修改所指向的整数。
- 指针常量，**指针本体是常量**

### 13. a和&a的区别

- a值是数组首元素的地址；&a值是整个数组的地址，例如，`&a + 1` 会跳过整个数组的大小，指向数组后面的下一个位置，但这个位置通常在程序中没有实际意义。

```c
  int a[5] = {1, 2, 3, 4, 5};
  printf("a = %p\n", a);            // 输出数组首元素地址
  printf("&a = %p\n", &a);          // 输出整个数组地址
  printf("a + 1 = %p\n", a + 1);    // 指向数组第二个元素地址
  printf("&a + 1 = %p\n", &a + 1);  // 跳过整个数组的地址
```

![image-20240902140752292](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240902140752292.png)

### 14. C++和python区别

- c++是**编译语言，编译时将代码转为机器指令效率高**，先编译后在**特定平台**允许；python是**解释型语言**，**解释器逐行分析源代码，将其转换为中间代码或直接转换为机器指令解释器执行转换后的代码，输出结果**，因此有**解释器**就可以很**方便跨平台**

- python用缩进区分不同代码块；c++用花括号

  

### 15. C++和C区别

- C没有**字符串**类型，没有**引用**类型，不可以**函数重载**
- iostream取代了stdio；try/catch/throw取代了setjmp和longjmp
- C需要**手动管理内存**malloc free；C++有手动和自动new delete std::unique_ptr智能指针等
- C是**面向过程**的编程语言，以**过程为中心**，将数据和对数据的操作分离，注重算法和数据结构的实现；C++**面向对象、面向泛型、面向过程的多范式编程语言**，例如，可以使用 C++ 的类来封装数据和操作，提高代码的可维护性和可扩展性。同时，C++ 也支持模板和泛型编程，允许编写通用的代码，提高代码的复用性。

### 16. C++与Java区别

### 17. struct与class区别

- 成员

  - struct成员默认public，继承默认public
  - class成员默认private，继承默认private

- C++与C中的struct区别

  - C：不可以有函数；是一些变量的集合体
  - C++：能继承，能实现多态

- 具体使用场景

  - 在一些简单的场景下，当希望**数据成员可以被方便地访问**时，`struct`更合适。例如，在一个简单的配置文件读取程序中，定义一个`struct`来存储配置参数

  - 表示轻量级数据容器场景：当需要一个轻量级的数据容器来传递数据，**且不需要复杂的继承、多态等面向对象特性时**，`struct`是一个不错的选择。例如，在一个函数返回多个值的情况下，可以使用`struct`来封装这些值：

    - 简单数据记录和传递

    - 在一个简单的学生信息管理系统中，可能有一个函数用于从数据库中读取学生的基本信息，包括姓名、学号和年龄。可以使用`struct`来封装这些信息并在函数之间传递。

  ```cpp
     struct StudentInfo {
         std::string name;
         std::string studentId;
         int age;
     };
     StudentInfo getStudentInfoFromDB(const std::string& studentId) {
         // 模拟从数据库获取学生信息的过程
         StudentInfo info;
         // 假设从数据库读取数据并填充info的代码
         return info;
     }
  ```

  `StudentInfo`这个`struct`作为一个轻量级的数据容器，用于存储从数据库读取的学生信息，然后可以将这个`struct`作为返回值传递给其他函数进行进一步的处理，比如显示学生信息或者更新学生信息等操作。

### 18. define宏定义和const的区别

#### 编译阶段

- define是在预处理阶段起作用，const是编译、运行起作用

#### 安全性

- define只做替换，不做类型检查，容易产生错误
- const，编译器会对其检查

#### 内存占用

- define的数据没有分配空间，只是文本的插入替换
- const定义的变量不能改变，但能分配空间

### 19. const和static的作用

- const

  - `const`用于定义常量，它告诉编译器该变量的值是**不可修改**的。一旦一个变量被声明为`const`，任何试图修改它的操作都会导致编译错误。例如，`const int num = 10;`，在这里`num`的值在定义后就不能被改变。
  - `const`变量的存储位置和生命周期取决于它的定义方式。如果是在函数内部定义的`const`局部变量，它存储在栈上，生命周期仅限于函数执行期间。如果是**全局**`const`变量，它通常存储在只读数据区，生命周期是**整个程序的运行周期**。

  - 修饰类成员函数和成员变量
    - 常量成员函数
      - 在类中，成员函数可以被声明为`const`。例如，`class MyClass {public: void func() const; };`，`const`成员函数**表示该函数不会修改类的任何非`const`成员变量**。这可以让编译器帮助检查代码，防止在`const`成员函数中出现修改非`const`成员变量的错误。例如：

  ```cpp
  class MyClass {
  public:
      int value;
      void setValue(int new_value) {
          value = new_value;
      }
      void printValue() const {
          // value++;  // 这是错误的，在const成员函数中不能修改非const成员变量
          std::cout << value << std::endl;
      }
  };
  ```

  - 常量成员变量
    - 在类中，成员变量也可以用`const`修饰。例如，`class MyClass {public: const int const_value = 10; };`，这样的成员变量在对象初始化后不能被修改，其作用类似于定义一个常量。不过，**对于`const`成员变量，在类的构造函数初始化列表中进行初始化是更好的做法**。例如：

  ```cpp
  class MyClass {
  public:
      const int const_value;
      MyClass() : const_value(10) {}
  };
  ```

- static

  - 当`static`修饰局部变量时，该变量的生命周期延长，从**函数调用结束后仍然存在**，并且只会初始化一次。**应用场景**：用于**记录函数被调用的次数，或者在函数多次调用之间保存一些中间状态**。因为静态局部变量的值在函数调用之间保持不变，不像普通局部变量每次函数调用都会重新初始化。
  - 当`static`修饰全局变量时，它**限制了变量的作用域，使得变量只能在定义它的文件中被访问，其他源文件无法访问这个变量**。例如，在一个大型项目中有多个源文件，为了**避免全局变量的命名冲突和不必要的访问，可以将一些只在一个源文件内部使用的全局变量定义为静态全局变量**。
  - 静态**局部变量**存储在静态存储区，生命周期是**整个程序**的运行周期。静态**全局变量**也存储在静态存储区，生命周期同样是**整个程序运行周期，但它的作用域被限制在定义它的文件中**。类的静态成员变量同样存储在静态存储区，生命周期是**整个程序**运行周期，**所有类的对象共享这些静态成员变量**。
  - 独立于对象的函数
    - 当一个函数不需要访问类的非静态成员（即不依赖于具体的对象状态）时，可以将其定义为静态成员函数。例如，在一个数学工具类中，计算两个数的最大值的函数可以是静态的。

  ```cpp
       class MathUtils {
       public:
           static int max(int a, int b) {
               return (a > b)? a : b;
           }
       };
  ```

  ​	这样的函数可以直接通过类名调用，如`MathUtils::max(3, 5)`，而不需要创建类的对象。这在一些只涉及通用操作，不依赖于对象特定状态的场景中非常有用。

  - **静态函数（非类成员）**
    - **作用**：在文件作用域（全局作用域）下定义静态函数，其作用域也被限制在定义它的源文件中，和静态全局变量类似。这有助于提高程序的模块性，避免函数名冲突。
    - **应用场景**：在一个源文件中有一些辅助函数，这些函数只在该文件内部的模块中使用，将**它们定义为静态函数可以防止其他源文件中的代码调用这些函数，保持模块的独立性**。例如，在一个文件`util.cpp`中有一个静态函数用于内部数据格式转换：

  ```cpp
          static void convertDataFormat() {
              // 数据格式转换的具体操作
          }
  ```

  这个函数不会被其他源文件意外调用，使得代码的结构更加清晰。

### 20. 顶层const和底层const

- 顶层：const修饰的变量本身是const
- 底层：const修饰的变量指向的对象是const

```cpp
int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
const int b3 = 20; 		   //顶层const，b3是常量不可变
const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
const int& b5 = a;		   //用于声明引用变量，都是底层const
```

### 21. 数组名和指针的区别

- 数组名不是真正意义的指针，可以理解为常指针，没有自增自减的操作；
- 

### 22. final和override关键字

- override

`override`关键字用于**显式地声明一个虚函数是在重写基类中的虚函数**。它的主要目的是**帮助编译器检查函数签名是否正确匹配基类中的虚函数**。如果**函数签名不匹配，编译器会报错**，这可以避免因意外错误（如函数参数类型错误或函数名拼写错误）导致的函数重载而非重写的情况。

```cpp
 class Base {
 public:
     virtual void func(int x) {
         std::cout << "Base::func with x = " << x << std::endl;
     }
 };
 class Derived : public Base {
 public:
     void func(int x) override {
         std::cout << "Derived::func with x = " << x << std::endl;
     }
 };
```

- final

  - **应用于类**：当`final`关键字用于类时，表示这个类不能被继承。这样可以确保类的设计意图不被派生类改变，同时也有助于编译器进行一些优化，因为它知道这个类的层次结构是固定的。
  - **应用于虚函数**：当`final`关键字用于虚函数时，它表示这个虚函数不能在派生类中被重写。这有助于固定虚函数的行为，防止派生类意外或恶意地改变函数行为。

  ```cpp
  class FinalClass final {
  public:
     void someFunction() {
         std::cout << "This is a function in a final class." << std::endl;
     }
  };
  // 以下代码会导致编译错误，因为FinalClass不能被继承
  // class Derived : public FinalClass {};
  
  
  class Base {
  public:
     virtual void func(int x) final {
         std::cout << "Base::func with x = " << x << std::endl;
     }
  };
  class Derived : public Base {
  public:
     // 以下代码会导致编译错误，因为Base::func在Base类中被声明为final，不能被重写
     // void func(int x) {
     //     std::cout << "Derived::func with x = " << x << std::endl;
     // }
  };
  ```



### 23. 拷贝初始化和直接初始化

- 直接初始化

直接初始化是指在创建对象时，使用**与该对象类型相匹配的构造函数**来初始化对象。

例如，对于一个简单的`Point`类，有一个接受两个`int`参数的构造函数`Point(int x, int y)`，可以这样进行直接初始化：`Point p(1, 2);`。

- 拷贝初始化

拷贝初始化是指使用一个**已存在的同类型对象**来初始化新的对象，编译器会先用指定构造函数创建一个临时对象

首先，编译器会检查是否有合适的拷贝构造函数（如果没有自定义的拷贝构造函数，**编译器会自动生成一个默认的拷贝构造函数，对于简单的类，它会进行成员变量的浅拷贝**）。

如果已经有一个`Point p1(1, 2)`，可以通过拷贝初始化创建一个新的对象`Point p2 = p1;`。

```cpp
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数

```

- 列表初始化
  - **定义与语法**：列表初始化是使用花括号`{}`来初始化对象。可以用于初始化基本类型、数组、结构体、类等多种类型。例如，对于一个`std::vector`，可以使用`std::vector<int> v = {1, 2, 3};`进行列表初始化；对于一个自定义的`Point`类（有`x`和`y`两个成员变量），如果有合适的构造函数支持，也可以使用`Point p{1, 2};`进行列表初始化。
  - 过程与效果
    - 对于基本类型，列表初始化会尝试将花括号中的值转换为对应的基本类型的值。例如，`int i{3.14};`会将`i`初始化为 3（因为会进行截断）。
    - 对于类类型，编译器会查找合适的构造函数来处理列表中的值。如果有一个接受`std::initializer_list`参数的构造函数，会优先调用这个构造函数。例如，`std::vector`类有一个接受`std::initializer_list`的构造函数，所以`std::vector<int> v = {1, 2, 3};`会调用这个构造函数来初始化`v`。
  - 使用场景
    - **当需要同时初始化多个值，并且这些值可以通过一个有序的列表来表示时**，列表初始化非常方便。例如，初始化数组、容器类（如`std::vector`、`std::list`等）或者具有多个成员变量的结构体和类。它提供了一种简洁、统一的初始化方式，并且在某些情况下（如初始化`std::initializer_list`相关的类型）可以提供更精确的控制。

- 值初始化
  - **定义与语法**：值初始化是指在创建对象时，**没有显式地提供初始化值，对象会被初始化为默认值**。在 C++ 中有多种方式实现值初始化，例如使用空的括号语法`T object();`（注意这种语法在某些情况下可能会被误解为函数声明，特别是对于基本类型），或者在使用`new`表达式时不提供初始值（如`T* ptr = new T;`）。

### 24. 初始化和赋值的区别

一般没什么区别，在类中有区别

**赋值语法**：赋值操作使用赋值运算符`=`，对于基本类型，如`int a; a = 5;`。对于类类型，赋值操作会调用类的赋值运算符重载函数（如果定义了的话），例如`MyClass obj1, obj2; obj2 = obj1;`会调用`MyClass`类的`operator=`函数（如果有）来实现赋值。

```cpp
class A{
public:
    int num1;
    int num2;
public:
    A(int a=0, int b=0):num1(a),num2(b){};
    A(const A& a){};
    //重载 = 号操作符函数
    A& operator=(const A& a){
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main(){
    A a(1,1);
    A a1 = a; //拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
    return 0;
}

```



### 25. extern C的用法

- `extern "C"`是 C++ 中的一个链接指示符，主要用于实现 C++ 与 C 语言的混合编程。它的作用是告诉 C++ 编译器，被它修饰的代码块应该按照 C 语言的编译和链接规则来处理，而不是按照 C++ 的规则。

假设我们有一个 C 语言编写的函数`int add(int a, int b)`，在 C++ 代码中想要调用这个函数，需要在 C++ 文件中使用`extern "C"`进行声明，如下所示：

```cpp
     extern "C" {
         int add(int a, int b);
     }
     int main() {
         int result = add(3, 5);
         return 0;
     }
```

- 与头文件的结合使用
  - 在实际的项目中，为了方便管理和使用，通常会将`extern "C"`声明**放在头文件**中。例如，对于一个包含 C 语言函数的库，会创建一个头文件来包含这些函数的`extern "C"`声明，这样 C++ 代码只需要包含这个头文件就可以正确地调用库中的 C 语言函数。例如，有一个名为`mylib.h`的头文件，内容如下：

```cpp
   #ifndef MYLIB_H
   #define MYLIB_H
   extern "C" {
       int add(int a, int b);
       int subtract(int a, int b);
   }
   #endif
```

### 26. 野指针和悬空指针

- 野指针
  - 野指针是指指针变量指向了一个**不确定的内存地址**。这种指针通常是因为指针没有被初始化或者被赋予了一个随意的值而产生的。例如，在 C/C++ 中，如果只是声明了一个指针变量但没有对其进行初始化，这个指针就是野指针。

```c++
   int* wild_ptr;
   // 此时wild_ptr就是野指针，它指向的内存地址是不确定的
```

- 悬空指针

  - 悬空指针是指指针原本指向的**内存已经被释放，但指针仍然存在并且仍然指向那块已经释放的内存**。例如，在 C/C++ 中，当使用`delete`（在 C++ 中）或者`free`（在 C 语言中）释放了指针所指向的动态分配内存后，该指针就变成了悬空指针。

  ```cpp
     int* ptr = new int(10);
     // 使用ptr
     delete ptr;
     // 此时ptr就变成了悬空指针
  ```

  

### 27. C和C++的类型安全

1. **C 语言的类型安全**
   - 弱类型安全特性
     - C 语言是一种弱类型安全语言。这意味着它在编译时对类型的检查相对宽松。例如，C 语言允许进行隐式类型转换。在一些情况下，这可能会导致意外的结果。比如，将一个`float`类型的值赋给一个`int`类型的变量，会自动截断小数部分，像`int i = 3.14;`，这里`i`的值会被截断为 3，没有编译时的警告来提示可能的数据丢失。
   - 指针类型安全问题
     - C 语言中的指针操作也可能引发类型安全问题。由于可以进行强制类型转换，能够将一种指针类型转换为另一种指针类型。例如，将一个`char *`指针转换为`int *`指针并进行解引用，这可能会导致错误的内存访问。假设我们有`char buffer[4] = {'a', 'b', 'c', 'd'};`，如果错误地进行`int *int_ptr = (int *)buffer;`并解引用`*int_ptr`，就会以不符合预期的方式读取内存，可能导致程序崩溃或产生未定义行为。
   - 函数参数类型安全
     - C 语言在函数调用时，对于参数类型的检查也比较薄弱。**编译器不会严格检查实际传递的参数类型是否与函数定义中的参数类型完全匹配**。例如，一个函数期望接收一个`int`参数，但可以传递一个`double`类型的值，编译器可能会进行隐式转换，但这可能不是程序员期望的行为，并且可能导致错误。
2. **C++ 语言的类型安全**
   - 强类型安全特性（相对 C 语言）
     - C++ 在类型安全方面比 C 语言更严格。它提供了更强大的类型检查机制。例如，C++ 中的函数重载就是基于严格的类型检查。不同参数类型的同名函数可以在 C++ 中正确区分，而在 C 语言中会导致命名冲突。**像`void print(int i)`和`void print(double d)`在 C++ 中是两个不同的函数**，可以根据参数类型进行正确的调用，而在 C 语言中不支持这种方式。
   - 引用和指针类型安全改进
     - C++ 引入了引用类型，它提供了一种更安全的方式来处理对象别名。与指针相比，**引用在初始化后不能再绑定到其他对象，这在一定程度上增强了类型安全性**。例如，`int a = 10; int &ref = a;`，`ref`在初始化后就固定地引用`a`，不能再引用其他变量。对于指针，C++ 虽然仍然支持指针操作，但通过一些机制来增强安全性。**例如，`const`指针和指向`const`对象的指针可以防止对对象的意外修改，像`const int *ptr`这种指针**，不能通过它来修改所指向的`int`对象的值。
   - 模板和泛型编程对类型安全的支持
     - C++ 的模板和泛型编程也有助于提高类型安全。**模板允许编写能够适应多种类型的代码，但在编译时会对模板参数进行严格的类型检查。**例如，一个模板函数`template<typename T> void swap(T& a, T& b)`，编译器会检查传入的两个参数类型是否相同。如果试图传递不同类型的参数，如`int i = 1; double d = 2.0; swap(i, d);`，编译器会报错，确保了类型安全。

### 28. 重载、重写（覆盖）和隐藏的区别

- 重载

  - 重载函数必须在同一作用域内，通常是在同一个类或者同一个全局命名空间中。

  - 函数的返回类型不同不能作为重载的依据，只有参数列表的差异才是判断重载的关键因素。



```cpp
     class MathUtils {
     public:
         int add(int a, int b) {
             return a + b;
         }
         double add(double a, double b) {
             return a + b;
         }
     };
```



- 重写
  - 重写**要求基类中的函数是虚函数**，并且**派生类中重写的函数必须与基类中的虚函数具有相同的函数签名（函数名、参数列表、返回类型都要相同，协变返回类型除外）**，同时在派生类中的重写函数通常要使用**`override`**关键字（在 C++11 及以后版本）来明确表示这是一个重写操作，以方便编译器检查。

```cpp
     class Shape {
     public:
         virtual void draw() {
             std::cout << "Drawing a generic shape." << std::endl;
         }
     };
     class Circle : public Shape {
     public:
         void draw() override {
             std::cout << "Drawing a circle." << std::endl;
         }
     };
```

- 隐藏
  - 隐藏是指在派生类中定义的成员（函数或者变量）与基类中的成员具有相同的名称，从而在派生类的作用域内隐藏了基类中的同名成员

```cpp
     class Base {
     public:
         void func() {
             std::cout << "Base::func" << std::endl;
         }
     };
     class Derived : public Base {
     public:
         void func() {
             std::cout << "Derived::func" << std::endl;
         }
     };
```

1. 这里`Derived`类中的`func`函数隐藏了`Base`类中的`func`函数。与重写不同的是，**隐藏不依赖于虚函数机制**。当通过派生类对象直接调用`func`函数时，如`Derived d; d.func();`，会调用`Derived`类中的`func`函数。但是如果想通过派生类对象调用基类中的被隐藏函数，需要使用作用域解析运算符，如`d.Base::func();`。

2. **隐藏主要是基于作用域规则，只要派生类中的成员与基类中的成员同名，就会发生隐藏，而不管函数的参数列表或者是否是虚函数。**这种情况在继承体系中可能会导致一些意外的结果，需要特别注意。

- 什么时候用隐藏而不是重写

1. **不希望实现多态的时候**
   - 假设你有一个基类`Animal`和派生类`Dog`和`Cat`。`Animal`类有一个`makeSound`函数用于发出动物的声音，并且这个函数在`Animal`类中不是为了通过多态来使用，只是作为一个普通的函数，每个派生类都有自己独立的`makeSound`实现，但不想让这些实现被当作多态的行为。

```cpp
   class Animal {
   public:
       void makeSound() {
           std::cout << "Animal makes a sound." << std::endl;
       }
   };
   class Dog : public Animal {
   public:
       void makeSound() {
           std::cout << "Dog barks." << std::endl;
       }
   };
   class Cat : public Animal {
   public:
       void makeSound() {
           std::cout << "Cat meows." << std::endl;
       }
   };
```

2. 完全改变函数语义时
   - **示例场景**：考虑一个基类`Shape`，它有一个`printDetails`函数用于打印形状的一些基本信息，比如形状的类型是 “Generic Shape”。在派生类`Circle`中，`printDetails`函数不仅仅是改变打印的内容（如打印圆的半径等具体信息），而是整个函数的操作逻辑和目的都与基类不同。

```cpp
   class Shape {
   public:
       void printDetails() {
           std::cout << "This is a generic shape." << std::endl;
       }
   };
   class Circle : public Shape {
   public:
       void printDetails() {
           std::cout << "Circle with radius: 5" << std::endl;
       }
   };
```

###  29. C++有哪几种构造函数

1. 默认构造函数

默认构造函数是一种可以在没有参数的情况下初始化对象的构造函数。如果类中没有定义任何构造函数，**编译器会自动生成一个默认构造函数。这个默认构造函数会对类中的基本数据类型成员进行默认初始化（例如，`int`类型成员初始化为 0，指针类型成员初始化为`nullptr`），对于类类型成员，会调用其默认构造函数进行初始化。**

```cpp
     class MyClass {
     public:
         int num;
         std::string str;
     };
     int main() {
         MyClass obj;  // 使用默认构造函数创建对象，num被初始化为0，str被初始化为空字符串
         return 0;
     }
```

2. 带参数的构造函数
3. 拷贝构造函数

拷贝构造函数是一种特殊的构造函数，用于**使用一个已存在的同类型对象**来初始化新的对象。它的参数通常是一个`const`引用，指向同类型的对象。如果没有自定义拷贝构造函数，**编译器会自动生成一个默认的拷贝构造函数，进行浅拷贝（对于基本类型成员直接复制值，对于指针类型成员只复制指针值），这意味着会产生新的一份数据副本。**

```cpp
     class MyString {
     public:
         char* data;
         MyString(const char* str) {
             // 假设这里进行了字符串的复制操作，将str的内容复制到data中
             // 为了简单示例，省略了实际的字符串复制代码
             data = str;
         }
         MyString(const MyString& other) {
             // 自定义拷贝构造函数，进行深拷贝
             // 假设这里进行了正确的字符串复制操作，将other.data的内容复制到data中
             // 为了简单示例，省略了实际的字符串复制代码
             data = other.data;
         }
     };
     int main() {
         MyString s1("Hello");
         MyString s2(s1);  // 使用拷贝构造函数创建对象s2，复制s1的内容
         return 0;
     }
```

4. 移动构造函数

移动构造函数用于将一个**临时对象（或者即将被销毁的对象）的资源 “移动” 到新创建的对象中，而不是进行复制操作。**移动构造函数是将资源的所有权从一个对象转移到另一个对象，而不是复制资源。**它会直接 “窃取” 源对象的资源，然后将源对象置于一种可析构的状态**。

它的参数通常是一个右值引用（`&&`）。例如`MyString&& other`。**右值引用主要用于绑定到即将被销毁的对象（如临时对象），这使得移动构造函数能够识别出可以被 “移动” 资源的对象**。移动构造函数可以**提高性能**，特别是在处理包含大量资源（如动态分配的内存、文件句柄等）的对象时。

在处理临时对象或者不再需要的对象资源时使用，通过移动构造函数可以**避免不必要的资源复制开销**，例如在容器类的实现中，当对容器进行重新分配或者插入操作时，移动构造函数可以高效地处理对象的资源转移。

```cpp
// 拷贝构造，简单的copy   
class MyString {
     public:
         char* data;
         MyString(const MyString& other) {
             int length = strlen(other.data);
             data = new char[length + 1];
             strcpy(data, other.data);
         }
     };
// 移动构造
     class MyString {
     public:
         char* data;
         MyString(MyString&& other) noexcept {
             // 析构
             data = other.data;
             other.data = nullptr;
         }
     };
```

### 30. 左值、右值、左值引用、右值引用

> 左值引用，右值引用

- **左值引用**：左值引用（`&`）主要绑定到左值，左值是具有持**久存储的对象**，例如变量、数组元素等。例如，`int num = 10; int& lvalue_ref = num;`，这里`lvalue_ref`是左值引用，绑定到了变量`num`，它在内存中有确定的存储位置，并且在引用的生命周期内可以一直访问。
- **右值引用**：右值引用绑定到右值，右值不具有持久的存储，它们通常是**临时的计算结果或者字面常量**。例如，在表达式`int&& rvalue_ref = 2 * 3;`中，`rvalue_ref`绑定到了`2 * 3`这个临时的计算结果，这个结果**在表达式执行完后通常就没有存在的必要**了。

> 左值，右值

1. **左值（lvalue）**
   - 定义
     - 左值是指表达式结束后依然持久存在的实体。简单来说，**左值具有明确的内存地址，可以在程序的多个地方被访问和修改**。在 C++ 中，**变量名是典型的左值**，因为变量在内存中有固定的存储位置，并且可以通过变量名来获取和修改存储的值。例如，`int num = 10;`，`num`就是一个左值，它代表了内存中存储`10`这个值的位置。
   - 特性
     - **可寻址性**：左值可以获取其内存地址。例如，可以使用`&`运算符获取变量的地址，如`int* ptr = #`，这表明`num`是一个左值，因为可以获取它的内存地址并存储在指针`ptr`中。
     - **可修改性（非 const 情况下）**：对于非`const`的左值，可以对其进行赋值操作来修改它的值。例如，`num = 20;`，这改变了`num`所代表的内存位置存储的值

2. **右值（rvalue）**

   - 定义
     - 右值是指**表达式结束后就不再存在的临时值**。右值通常是**字面常量、临时对象或者是一些运算的结果**。例如，`10`（字面常量）、`2 + 3`（运算结果）、函数返回的临时对象等都是右值。它们在生成的表达式语句结束后，就不再有实际意义，并且没有持久的存储位置（从用户角度来看）。

   - 特性
     - **临时性**：**右值是临时存在的，一般不能获取其内存地址（虽然在某些底层实现可能有地址，但用户代码通常无法直接访问）**。例如，不能对字面常量`10`使用`&`运算符获取其地址（在符合标准的 C++ 代码中）。
       - **不可修改性（通常情况）**：右值通常不能被赋值，因为它们在表达式结束后就不存在了。例如，`10 = 20;`是非法的，因为`10`是右值，不支持这种赋值操作。不过，在 C++11 引入右值引用后，对于一些特殊情况，可以通过右值引用延长右值的生命周期并进行修改，但这是一种特殊的操作，与常规的右值概念有所不同。

```cpp
   int add(int a, int b) {
       return a + b;
   }
   int main() {
       int x = 5;
       int y = 3;
       int result = add(x, y);
       // x和y是左值，因为它们是变量，有持久的存储位置并且可以修改
       // 5、3是右值，它们是字面常量
       // add(x, y)的返回值是右值，它是一个临时的计算结果，在表达式结束后就不再存在
       // result是左值，用于存储add函数返回的右值结果
       return 0;
   }
```

### 31.  浅拷贝和深拷贝的区别

**区别在有没有为拷贝对象指针指向的值开辟新的内存空间**

1. 浅拷贝（Shallow Copy）
   - **定义**：浅拷贝是指在拷贝对象时，只拷贝对象的基本数据类型成员的**值**，而对于对象中的指针类型成员，**只是复制指针的值，而不复制指针所指向的内存空间**。这样，**源对象和拷贝后的对象中的指针成员会指向同一块内存空间**。
   - 示例
     - 假设我们有一个简单的类`MyString`，它包含一个字符指针来存储字符串内容。

```cpp
     class MyString {
     public:
         char* data;
         MyString(const char* str) {
             data = new char[strlen(str) + 1];
             strcpy(data, str);
         }
         MyString(const MyString& other) {
             data = other.data;
         }
         ~MyString() {
             delete[] data;
         }
     };
```

- 在这个例子中，拷贝构造函数实现的是浅拷贝。当创建一个`MyString`对象的副本时，新对象的`data`指针和源对象的`data`指针指向相同的内存位置。
- 风险和问题
  - 浅拷贝可能导致悬空指针和内存泄漏问题。例如，**当源对象和拷贝后的对象的生命周期结束时，它们的析构函数都会尝试释放`data`所指向的内存空间。如果是浅拷贝，就会导致同一块内存被释放两次，这是一种未定义行为，可能会引起程序崩溃。**而且，如果通过一个对象修改了指针所指向的数据，另一个对象也会受到影响，因为它们指向的是同一块内存。

2. 深拷贝（Deep Copy）

   - **定义**：深拷贝是指在拷贝对象时，不仅拷贝对象的基本数据类型成员的值，还会为**对象中的指针类型成员所指向的内存空间分配新的内存，并将源对象指针所指向的数据完整地复制到新分配的内存中。这样，源对象和拷贝后的对象中的指针成员指向不同的、但内容相同的内存空间**。

   - 示例
     - 对于上面的`MyString`类，我们可以将拷贝构造函数修改为实现深拷贝。

```cpp
     class MyString {
     public:
         char* data;
         MyString(const char* str) {
             data = new char[strlen(str) + 1];
             strcpy(data, str);
         }
         MyString(const MyString& other) {
             data = new char[strlen(other.data) + 1];
             strcpy(data, other.data);
         }
         ~MyString() {
             delete[] data;
         }
     };
```

现在，拷贝构造函数实现了深拷贝。当创建一个`MyString`对象的副本时，会为新对象的`data`指针分配新的内存，并将源对象`data`所指向的字符串内容复制到新的内存中。

### 32. 内联函数和宏定义的区别

内联函数兼具宏的优点，能够在一定程度上提高代码的可读性。与宏相比，内联函数是真正的函数，**具有函数的类型检查**等特性，更加安全。当函数体较小且被频繁调用时，使用**内联函数可以避免函数调用的开销，如栈帧的创建和销毁、参数传递**等。例如，宏定义可能会因为参数的副作用等问题导致错误，而内联函数不会。对比以下宏定义和内联函数：

- 宏定义：

```cpp
     #define SQUARE(x) ((x) * (x))
```

- 内联函数：

```cpp
     inline int square(int x) {
         return x * x;
     }
```

**如果使用宏定义`SQUARE(i++)`，可能会得到意外的结果，因为宏只是简单的文本替换，会导致`i`被多次自增**。而内联函数`square(i++)`会按照函数调用的规则，先将`i`的值传递给函数，然后`i`再自增，避免了这种意外情况。

- 内联函数使用场景

1. 频繁调用的简单函数
   - **性能优化场景**：当一个函数在程序中被频繁调用，并且函数体相对简单时，使用内联函数可以有效减少函数调用的开销。例如，在一个图形渲染引擎中，有一个函数用于计算两个向量的点积。这个函数可能会在渲染每个像素或者每个图形元素时被多次调用。

```cpp
   inline float dotProduct(const Vector3D& v1, const Vector3D& v2) {
       return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
   }
```

- 由于这个函数的计算逻辑简单，且在渲染过程中可能会被频繁调用（比如对于复杂的 3D 场景，可能每秒要调用数百万次），将其定义为内联函数可以让编译器直接将函数体插入到调用点，避免每次调用都产生函数调用栈的开销，从而提高程序的性能。

2. 宏的替代方案（提高代码安全性和可读性）
   - **对比宏的缺陷场景**：在 C 和 C++ 中，宏是一种简单的文本替换机制，它没有类型检查，并且可能会因为参数的副作用等问题导致错误。例如，定义一个宏来计算一个数的平方：`#define SQUARE(x) ((x) * (x))`，如果使用`SQUARE(i++)`，会导致`i`被意外地多次自增。而内联函数可以作为更安全的替代方案。

```cpp
   inline int square(int x) {
       return x * x;
   }
```

当需要像宏一样在代码中方便地进行一些简单的计算或者操作，但又希望有函数的类型检查和更规范的行为时，内联函数是很好的选择。例如，在数学计算库中，对于一些简单的数学运算函数（如加法、减法、平方等），可以使用内联函数来提高代码的可读性和安全性。

3. 对性能敏感的小型库或模块内部函数
   - **库函数性能优化场景**：在开发小型的、性能敏感的库或者模块时，对于内部的一些简单辅助函数，使用内联函数可以优化性能。例如，一个自定义的字符串处理库，其中有一个函数用于判断一个字符是否是空白字符（空格、制表符等）。

```cpp
   inline bool isWhitespace(char c) {
       return c == ' ' || c == '\t' || c == '\n';
   }
```

这个函数在库内部可能会被其他字符串处理函数频繁调用，将其定义为内联函数可以减少函数调用开销，提高整个库的性能。同时，由于它是库内部函数，代码膨胀的影响相对较小，因为它的使用范围主要局限在库内部。

- **内联函数就是mini版的函数**，省去了栈的创建和析构，**不会压栈**

当我们说编译器将内联函数的函数体直接插入到循环中的调用点，是指在编译阶段，编译器会把内联函数的实际代码内容替换掉函数调用的部分。

**示例说明**

假设我们有一个简单的内联函数和一个循环，如下所示：

内联函数定义：

```cpp
       inline int add(int a, int b) {
           return a + b;
       }
```

循环中调用该函数：

```cpp
       for (int i = 0; i < 5; ++i) {
           int result = add(i, 1);
           std::cout << result << " ";
       }
```

在编译时，编译器会将`add`函数体的内容（`return a + b;`）替换到循环中函数调用`add(i, 1)`的位置。经过替换后，代码在逻辑上类似于下面这样：

```cpp
     for (int i = 0; i < 5; ++i) {
         int result = i + 1;
         std::cout << result << " ";
     }
```

这样做的好处是，避免了每次循环迭代时调用`add`函数所产生的开销，**如创建和销毁栈帧、传递参数和返回值等操作。因为函数体代码已经直接 “嵌入” 到了循环内部的调用位置**，所以程序在执行这个循环时可以更高效地运行，减少了额外的函数调用相关的指令和内存操作。

- 滥用内联函数导致代码膨胀

1. **普通函数的存储和调用机制**
   - **代码存储方式**：普通函数在内存中有独立的存储位置，其代码只存储一次。当程序中有多个地方调用这个函数时，无论调用次数多少，编译器只会在内存中生成一份函数代码的副本。例如，有一个函数`int add(int a, int b)`，无论在程序中有 10 个还是 100 个地方调用它，**函数代码都只存储在一个固定的内存区域**。
   - **调用过程开销**：每次调用普通函数时，会产生一些额外的开销。这个过程包括创建新的栈帧来存储函数的局部变量、参数和返回地址，将参数拷贝（如果是按值传递）到栈帧中对应的位置，然后将控制权转移到函数代码所在的内存位置开始执行。函数执行完毕后，再恢复之前的栈帧，将返回值（如果有）传递回调用者。虽然这些操作会产生一定的时间和空间开销，但不会导致代码本身的大量重复。
2. **内联函数导致代码膨胀的原因**
   - **代码插入机制**：内联函数的关键特性是编译器可能会将函数体的代码直接插入到每个调用该函数的位置。例如，有一个内联函数`inline int square(int x) { return x * x; }`，如果在程序中有多个地方调用它，如`int a = square(3);`和`int b = square(5);`，编译器可能会将函数体`return x * x;`分别插入到这两个调用点，就好像把函数体的内容复制到了每个调用它的地方。
   - **重复代码累积**：当内联函数被频繁调用或者函数体本身较大时，这种代码插入方式会导致大量的重复代码。如果一个内联函数有 10 行代码，**并且在程序中被调用 100 次，那么就会在最终的可执行文件中产生 1000 行重复的代码**，从而导致代码膨胀。这不仅会增加可执行文件的磁盘空间占用，还可能因为大量重复代码对程序的性能产生负面影响，如降低指令缓存的命中率等。
   - 如果内联函数的代码非常简单（例如只有一两条指令），编译器可能会按照上述理论方式进行内联，因为插入的代码量很少，不会对程序造成显著的代码膨胀。但如果内联函数本身比较复杂，编译器可能会权衡内联带来的性能提升（减少函数调用开销）和代码膨胀的负面影响，**选择不进行内联**或者采用其他优化方式。

### 33. public protected private访问和继承权限的区别

1. **访问权限**

- `private`的使用场景
  - 用于隐藏类的内部实现细节。当一个类的某些成员变量或函数是类内部的实现细节，不希望被外部类或者派生类访问和修改时，应该将它们声明为`private`。例如，在一个`Stack`类中，存储栈元素的数组和栈顶指针等成员可以声明为`private`，以确保外部代码不能随意修改这些关键的内部状态，从而保证栈的操作符合预期的逻辑。
- `protected`的使用场景
  - 主要用于在**继承体系**中，**允许派生类访问基类的部分成员**，这些成员通常是和派生类的实现相关的。例如，在一个图形类层次结构中，基类`Shape`可能有一些`protected`成员变量来表示图形的位置和颜色等属性。派生类`Circle`和`Rectangle`可以访问这些`protected`成员来实现自己的特定绘制方法，同时这些属性对于外部代码是隐藏的，保证了数据的封装性和安全性。

2. **继承权限**

- **`public`继承**
  - **概念和语法**：在`public`继承方式下，基类的`public`成员在派生类中仍然是`public`，基类的`protected`成员在派生类中仍然是`protected`。没变化。
- **`private`继承**
  - **概念和语法**：对于`private`继承，**基类的所有`public`和`protected`成员在派生类中都变为`private`。**语法形式为`class Derived : private Base`。
  - **成员访问示例**：若基类`Base`有`public`函数`func_public`和`protected`函数`func_protected`，在派生类`Derived`中，这两个函数都变为`private`。**这意味着在派生类内部可以访问这些函数，但在派生类对象外部，这些函数无法被访问。**
  - **继承关系的语义和用途**：`private`继承更像是一种实现继承，它表示一种 “是用…… 实现的”（`is - implemented - in - terms - of`）关系。这种继承方式主要用于只想在派生类内部使用基类的功能，而不想将基类的接口暴露给派生类的使用者。例如，派生类可能需要借助基类的某些实现细节来实现自己的功能，但这些细节不应该成为派生类接口的一部分。
- **`protected`继承**
  - **概念和语法**：在`protected`继承中，**基类的`public`成员在派生类中变为`protected`，`protected`成员仍然是`protected`。**语法是`class Derived : protected Base`。
  - **成员访问示例**：若基类`Base`有`public`函数`func_public`和`protected`函数`func_protected`，在派生类`Derived`中，`func_public`变为`protected`，`func_protected`保持`protected`。这意味着在派生类及其派生类（多层继承）中可以访问这些函数，但在派生类对象外部不能访问。
  - **继承关系的语义和用途**：`protected`继承介于`public`和`private`继承之间。它用于在需要在派生类及其派生类（多层继承）中访问基类的某些功能，但又不想将这些功能完全公开时比较有用。这种继承方式可以保护基类的部分接口，使其在一定范围内（派生类家族）可用，但不会像`public`继承那样完全暴露给外部使用者。

### 34. 什么是大端和小端

![image-20241004150444906](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241004150444906.png)

- 大端

**大端序（Big-Endian 或 Big-Endianness）**：也叫大端模式或大字节序。**数据的高字节保存在内存的低地址**中，而数据的低字节保存在内存的高地址中。这种存储模式类似于把数据当作字符串顺序处理，地址由小向大增加，数据从高位往低位存放。例如，对于 32 位整数 `0x12345678`，高位字节 `0x12` 存于内存低地址，接着依次是 `0x34`、`0x56`、`0x78` 存于更高地址，就像按从左到右（高位在前）的顺序存储。**大端序的优点是符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小。**

- 小端

数据的**高字节保存在内存的高地址**中，而数据的低字节保存在内存的低地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和常规的逻辑方法较为一致。对于 `0x12345678`，在小端序下，内存低地址存放的是 `0x78`（最低字节），接着依次是 `0x56`、`0x34`、`0x12`（最高字节在高地址）12。**小端序的优点是在强制转换数据时不需要调整字节的内容，并且 CPU 做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，效率更高。**

为了实现跨平台的数据交换，**TCP/IP 协议规定使用大端序作为网络字节序1**。在进行网络通信时，发送数据前必须将主机字节序转换为网络字节序，接收数据时再将其转换回主机字节序1。

### 35. 如何用代码判断大小端存储

1. 联合体判断：

**原理**：联合体是一种特殊的数据类型，**它的所有成员共用同一块内存空间**。在一个包含字符类型和整数类型的联合体中，可以利用字符类型占用一个字节的特性来判断大小端存储。

```cpp
     #include <iostream>
     union EndiannessTester {
         int num;
         char c;
     };
     int main() {
         EndiannessTester tester;
         tester.num = 1;
         if (tester.c == 1) {
             std::cout << "Little - endian" << std::endl;
         } else {
             std::cout << "Big - endian" << std::endl;
         }
         return 0;
     }
```

- 在这段代码中，首先定义了一个联合体`EndiannessTester`，它包含一个`int`类型成员`num`和一个`char`类型成员`c`。然后在`main`函数中，将`num`赋值为 1。由于联合体成员共用内存空间，在小端存储模式下，**最低字节（也就是`c`所对应的字节）存储的是数据的最低有效位，所以`c`的值为 1**；而在大端存储模式下，最高字节存储的是数据的最低有效位，`c`的值为 0。通过检查`c`的值，就可以判断存储模式是大端还是小端。

2. 通过指针类型转换判断

   - **原理**：可以将一个`int`类型的数据的地址转换为`char`类型的指针，然后通过这个指针访问第一个字节的值来判断大小端。

   - **示例代码**：

```cpp
     #include <iostream>
     int main() {
         int num = 1;
         char* ptr = reinterpret_cast<char*>(&num);
         if (*ptr == 1) {
             std::cout << "Little - endian" << std::endl;
         } else {
             std::cout << "Big - endian" << std::endl;
         }
         return 0;
     }
```

在这里，首先定义了一个`int`类型的变量`num`并赋值为 1。然后通过`reinterpret_cast`将`num`的地址转换为`char`类型的指针`ptr`。在小端存储模式下，`ptr`指向的第一个字节存储的是 1；在大端存储模式下，`ptr`指向的第一个字节存储的是 0。通过检查`ptr`所指向的第一个字节的值，就可以判断存储模式。



### 36. volatile、mutable和explicit关键字



1. **`volatile`关键字**
   - 定义与基本概念
     - `volatile`是一种类型修饰符，用于告诉编译器被修饰的变量可能会在程序执行过程中被意外地改变。这种改变可能来自于外部设备（如硬件寄存器）、多线程环境中的其他线程或者信号处理程序等。例如，一个用于存储硬件设备状态的变量就适合用`volatile`修饰。
   - 用途和场景
     - **硬件访问和嵌入式编程**：在嵌入式系统中，当程序需要读取和写入硬件寄存器时，这些寄存器的值可能会因为硬件的操作而随时改变。例如，一个用于控制定时器的寄存器，其值可能会根据定时器的运行状态自动更新。

```cpp
     volatile unsigned int* timer_register = (volatile unsigned int*)0x1000;
     // 读取定时器寄存器的值
     unsigned int timer_value = *timer_register;
```

- **多线程编程（有限场景）**：在多线程环境下，虽然`volatile`不能替代适当的同步机制（如互斥锁、原子操作等），但在某些简单场景下可以用于标记共享变量，这些变量可能会被其他线程修改。例如，一个简单的标志变量，用于表示某个线程是否完成任务。

```cpp
     volatile bool task_completed = false;
     // 线程1中执行任务，完成后设置标志
     void thread1() {
         // 执行任务
         //...
         task_completed = true;
     }
     // 线程2中检查任务是否完成
     void thread2() {
         while (!task_completed) {
             // 等待任务完成
         }
         // 任务完成后的操作
         //...
     }
```

**编译器优化影响**：通常情况下，编译器会对代码进行优化，例如将变量的值**缓存在寄存器中，以提高访问速度**。但是对于`volatile`变量，编译器不会进行这样的优化，**因为变量的值可能会在编译器无法预知的情况下发生改变。这确保了每次对`volatile`变量的访问都是真实地从内存中读取或写入**。

- mutable关键字

`mutable`是用于**修饰类的成员变量**的关键字。**它允许在`const`成员函数中修改被修饰的成员变量**。通常情况下，`const`成员函数不能修改类中的成员变量，以保证对象在`const`状态下的完整性。

**用途和场景**

**对象内部状态的灵活修改**：在某些情况下，即使一个类的对象被声明为`const`，仍然可能需要修改对象内部的一些辅助变量。例如，一个带有缓存的类，缓存用于存储某些计算结果，在`const`成员函数中可能需要更新缓存。

```cpp
     class DataCache {
     private:
         mutable std::vector<int> cache;
         // 其他成员变量和函数
     public:
         int getData(int index) const {
             if (cache.size() <= index) {
                 // 重新计算数据并更新缓存
                 // 这里可以修改cache，因为它是mutable的
                 cache.resize(index + 1);
                 // 计算并存储数据到cache[index]
             }
             return cache[index];
         }
     };
```

- explicit

`explicit`用于**修饰类的构造函数，防止隐式转换**。当一个构造函数被标记为`explicit`后，编译器不会自动使用这个构造函数进行隐式转换。

**用途和场景**

**防止意外的类型转换**：如果没有`explicit`关键字，编译器可能会在一些不期望的情况下进行类型转换。例如，有一个类`MyString`，它有一个接受`const char*`的构造函数。

```cpp
     class MyString {
     public:
         MyString(const char* str);
         // 其他成员函数
     };
     void printString(MyString str) {
         // 打印字符串内容
     }
     int main() {
         printString("Hello");
         // 如果MyString的构造函数没有explicit关键字，这里会隐式地将"Hello"转换为MyString对象
         // 加上explicit后，这样的隐式转换会被禁止，需要显式地创建对象，如printString(MyString("Hello"));
         return 0;
     }
```

```cpp
    class Wrapper {
    public:
        explicit Wrapper(int value) : wrappedValue(value) {}
        int getValue() const { return wrappedValue; }
    private:
        int wrappedValue;
    };
```

在这种情况下，如果没有使用`explicit`关键字，那么像`Wrapper w = 10;`这样的代码是合法的，**编译器会自动将整数`10`隐式转换为`Wrapper`类的对象**。但使用`explicit`后，这样的隐式转换就不被允许，必须显式地调用构造函数，如`Wrapper w(10);`。

### 37. 什么情况下会调用拷贝构造函数

- **用同类型对象初始化新对象**：当使用一个已存在的同类型对象来初始化一个新对象时，会调用拷贝构造函数。例如，在 C++ 中有一个类`MyClass`，如果有`MyClass obj1; MyClass obj2(obj1);`，这里就会调用拷贝构造函数来创建`obj2`，并将`obj1`的内容复制给`obj2`。

- **函数按值传递参数**：当一**个函数的参数是按值传递的对象**时，在函数调用时会调用拷贝构造函数来创建参数的副本。例如：

```cpp
    class Point {
    public:
        int x;
        int y;
        Point(int a, int b) : x(a), y(b) {}
        // 拷贝构造函数
        Point(const Point& other) : x(other.x), y(other.y) {}
    };
    void printPoint(Point p) {
        std::cout << "(" << p.x << ", " << p.y << ")" << std::endl;
    }
    int main() {
        Point p1(3, 4);
        printPoint(p1); 
        // 在这里，当调用printPoint函数时，会调用拷贝构造函数创建p1的副本传递给printPoint函数
        return 0;
    }
```

- **函数返回值为对象时**：当一个函数返回一个对象时，如果返回值是按值返回的，会调用拷贝构造函数来创建返回值的副本。例如：

```cpp
    Point getPoint() {
        Point p(5, 6);
        return p;
    }
    int main() {
        Point p2 = getPoint();
        // 在这里，当从getPoint函数返回时，会调用拷贝构造函数创建返回对象的副本并赋值给p2
        return 0;
    }
```

1. 传统理解（没有返回值优化的情况）
   - 在没有返回值优化（RVO，Return Value Optimization）的情况下，当`getPoint`函数返回`p`时，会创建一个临时的`Point`对象副本（通过调用拷贝构造函数）。**这个副本的生命周期从函数返回开始，一直到它被用来初始化`p2`（在`main`函数中）或者完整表达式结束**。
   - 具体来说，在`Point p2 = getPoint();`这个语句中，`getPoint`返回的副本用于初始化`p2`。一旦`p2`初始化完成，这个临时副本就会被销毁。这是因为这个副本只是为了传递返回值而临时创建的对象。
2. 返回值优化（RVO）场景
   - 在现代 C++ 编译器中，通常会应用返回值优化。当编译器能够确定返回值的情况时，它可能会直接在`p2`的内存空间中构造`p`对象，而不是先创建一个临时副本然后再赋值给`p2`。
   - **返回值优化允许编译器跳过这个临时对象的创建和拷贝过程，直接在接收返回值的对象的内存空间中构造函数内部的局部对象**。例如，对于函数`Point getPoint() { Point p(5, 6); return p; }`和`Point p2 = getPoint();`，编译器可能**会直接在`p2`的内存位置构建`p`，而不是先创建一个包含`p`值的临时对象，再将临时对象的值复制给`p2`**。
   - 在这种情况下，从逻辑上看，没有额外的临时副本产生。`p`对象的生命周期就好像直接从`getPoint`函数内延续到了`main`函数中的`p2`，因为编译器优化了返回值的传递过程，避免了不必要的拷贝构造和临时对象的创建。这种优化可以显著提高程序的性能，尤其是在频繁返回复杂对象的函数中。

- 内存分析
  1. **理解对象内存布局**
     - 当编译器应用返回值优化（RVO），直接在`p2`的内存位置构建`p`时，并不是说`p`和`p2`是两个独立的对象占用两份空间。实际上**，`p2`的内存空间大小是由其类型`Point`决定的，这个大小在编译阶段就根据`Point`类的成员变量来确定**。
     - 例如，假设`Point`类有两个`int`成员变量`x`和`y`，编译器会预留足够的空间来存储这两个成员变量。这个空间大小是固定的，不会因为构建方式（是否有返回值优化）而改变。
  2. **关于`p`的构建**
     - 在有返回值优化的情况下，**`p`是在`p2`的内存空间中构建的，并不是另外开辟一块空间来存储`p`。可以把这个过程想象成直接在`p2`的 “地盘” 上按照`p`的构造方式来初始化数据**。
     - 以简单的`Point`类为例，`p`和`p2`在内存中的布局本质上是一样的，都是为了存储`x`和`y`这两个成员变量的值。在没有返回值优化时，会先创建一个临时的`Point`对象（假设为`temp`），`temp`有自己独立的内存空间，用于存储`x`和`y`的值，然后再把`temp`的值复制给`p2`。而在返回值优化的情况下，`p`的构造过程直接在`p2`的内存空间中进行，不会产生额外的`p`对象占用空间。

### 38. 为什么有引用

1. 变量别名与方便使用
   - **场景示例**：在函数参数传递过程中，引用可以作为变量的别名。假设我们有一个函数用于交换两个整数的值：

```cpp
     void swap(int& a, int& b) {
         int temp = a;
         a = b;
         b = temp;
     }
     int main() {
         int num1 = 5, num2 = 10;
         swap(num1, num2);
         // 此时num1的值为10，num2的值为5
         return 0;
     }
```

- 在`swap`函数中，参数`a`和`b`是对传入的`int`变量的引用。这意味着`a`和`b`实际上是`num1`和`num2`的别名，在函数内部对`a`和`b`的操作就是对`num1`和`num2`的操作。这样可以避免像使用普通值传递那样需要复制大量数据，特别是当数据类型是大型结构体或者对象时，引用传递可以提高效率。

2. 函数返回多个值（间接方式）

- **场景示例**：在某些情况下，一个函数可能需要返回多个值。虽然可以使用结构体等方式返回多个值，但引用提供了另一种简洁的方法。例如，有一个函数用于分解一个整数为商和余数：

```cpp
     void divide(int dividend, int divisor, int& quotient, int& remainder) {
         quotient = dividend / divisor;
         remainder = dividend % divisor;
     }
     int main() {
         int dividend = 7, divisor = 3;
         int q, r;
         divide(dividend, divisor, q, r);
         std::cout << "Quotient: " << q << ", Remainder: " << r << std::endl;
         return 0;
     }
```

- 这里`divide`函数通过引用参数`quotient`和`remainder`返回两个值，使得函数可以方便地将计算结果传递回调用者，而不需要返回一个复杂的结构体或者使用全局变量。

3. 对象状态的修改与一致性维护

- **场景示例**：在面向对象编程中，当一个方法需要修改对象的内部状态时，引用非常有用。例如，考虑一个简单的银行账户类：

```cpp
     class BankAccount {
     private:
         double balance;
     public:
         BankAccount(double initial_balance) : balance(initial_balance) {}
         void deposit(double amount) {
             balance += amount;
         }
         void withdraw(double amount) {
             if (amount <= balance) {
                 balance -= amount;
             }
         }
         double getBalance() const {
             return balance;
         }
     };
```

- 在`deposit`和`withdraw`方法中，通过引用隐式地访问和修改`balance`这个对象内部的成员变量，确保对象的状态能够正确地被更新。这种方式可以保持对象的完整性和一致性，因为所有对对象状态的修改都是在对象内部通过引用进行的，外部代码只需要调用对象的方法即可。

4. 资源共享与避免复制开销

- **场景示例**：在**处理大型数据结构（如`std::vector`或自定义的大型数组类）或者复杂的对象时，复制操作可能会带来较大的开销。引用可以用于共享这些资源，避免不必要的复制**。例如，有一个函数用于打印一个`std::vector`的元素：

```cpp
     void printVector(const std::vector<int>& vec) {
         for (int element : vec) {
             std::cout << element << " ";
         }
         std::cout << std::endl;
     }
     int main() {
         std::vector<int> numbers = {1, 2, 3, 4, 5};
         printVector(numbers);
         return 0;
     }
```

- 这里`printVector`函数的参数`vec`是对`std::vector`的常量引用。这样，函数可以访问`vector`的元素进行打印操作，而不需要复制整个`vector`，提高了程序的效率。

### 39. C++有几种类型的new

1. `new`运算符（常规动态内存分配）
   - **基本用法**：这是最常见的`new`形式，用于在堆上分配单个对象的内存。例如，分配一个`int`类型的对象：

```cpp
      int* p = new int;
      *p = 5;
```

- 这里`new int`在堆上分配了足够存储一个`int`类型对象的内存空间，返回指向这块内存的指针，然后通过解引用`*p`可以对这个`int`对象进行赋值等操作。
- **分配数组**：`new`还可以用于分配数组。例如，分配一个包含 10 个`double`类型元素的数组：

```cpp
      double* arr = new double[10];
      for (int i = 0; i < 10; ++i) {
          arr[i] = i * 1.0;
      }
```

- 在这种情况下，`new double[10]`会在堆上分配连续的内存空间，足够存储 10 个`double`类型的元素，返回的指针`arr`指向数组的第一个元素。

2. `new[]`和`delete[]`（数组的动态分配与释放）

- **与`new`的区别**：当使用`new[]`分配数组时，需要使用`delete[]`来释放内存，以确保正确地清理所有分配的元素。这是因为`new[]`在分配数组内存时，除了为数组元素分配空间外，还可能存储了一些额外的信息（如数组的大小等），`delete[]`会利用这些信息来正确地释放内存。例如：

```cpp
      int* array = new int[5];
      // 使用数组
      delete[] array;
```

- 如果错误地使用`delete`（而不是`delete[]`）来释放通过`new[]`分配的数组内存，可能会导致内存泄漏或者程序崩溃等问题。

3. `nothrow`版本的`new`（内存分配失败处理）

- **基本原理**：`new`在默认情况下，如果内存分配失败（例如，堆空间不足）会抛出`bad_alloc`异常。但是，`nothrow`版本的`new`不会抛出异常，**而是返回`nullptr`来表示内存分配失败**。例如：

```cpp
      int* p = new (nothrow) int;
      if (p == nullptr) {
          // 处理内存分配失败的情况
      } else {
          *p = 10;
      }
```

- 这种形式的`new`在一些对异常处理比较敏感的场景下很有用，比如在实时系统或者一些不能轻易处理异常的底层代码中，可以通过检查返回值是否为`nullptr`来判断内存分配是否成功。

4. 定位`new`（Placement New）

- **基本概念和用法**：定位`new`允许在已经分配好的内存上构造对象。它的语法是`new (place_address) type`，其中`place_address`是一个已经分配好的内存地址，`type`是要构造的对象类型。例如：

```cpp
      char buffer[sizeof(int)];
      int* p = new (buffer) int(5);
```

- 在这里，`buffer`是一个已经分配好的字符数组，大小足以容纳一个`int`类型的对象。通过定位`new`，在`buffer`这个内存地址上构造了一个`int`对象，初始值为 5。需要注意的是，对于使用定位`new`构造的对象，**其析构函数需要显式调用**，因为它们不是在通常的堆内存管理机制下分配的。例如**，`p->~int()**;`可以用于析构这个对象，**千万不要使用delete**。



### 40. C++异常处理的方法

1. `try - catch`块（基本异常捕获机制）
   - **语法结构**：`try`块用于包含可能会抛出异常的代码。`catch`块紧跟在`try`块之后，用于捕获和处理特定类型的异常。例如：

```cpp
      try {
          // 可能抛出异常的代码
          int a = 5, b = 0;
          int result = a / b;
      } catch (const std::runtime_error& e) {
          std::cerr << "Runtime error: " << e.what() << std::endl;
      } catch (const std::exception& e) {
          std::cerr << "General exception: " << e.what() << std::endl;
      } catch (...) {
          std::cerr << "Unknown exception" << std::endl;
      }
```

- 在这个例子中，`try`块中的代码尝试进行除法运算，当除数为`0`时会抛出异常（通常是`std::runtime_error`类型的异常）。`catch`块会按照顺序匹配异常类型，第一个匹配成功的`catch`块会执行相应的异常处理代码。`catch(...)`是一个通用的异常捕获块，可以捕获任何类型的异常。
- **异常类型匹配原则**：`catch`块中的异常类型必须是可匹配的。如果抛出的异常是派生类类型，而`catch`块中是基类类型，也可以成功捕获。例如，如果有一个派生自`std::exception`的自定义异常类`MyException`，`catch(const std::exception& e)`可以捕获`MyException`类型的异常。

2. `throw`语句（抛出异常）

- **主动抛出异常**：在 C++ 中，可以使用`throw`语句主动抛出异常。异常可以是内置数据类型（如`int`、`double`等），也可以是用户自定义的类类型。例如：

```cpp
      void divide(int a, int b) {
          if (b == 0) {
              throw std::runtime_error("Division by zero");
          }
          return a / b;
      }
```

- 这里，当`b`为`0`时，函数`divide`通过`throw`语句抛出一个`std::runtime_error`类型的异常，这个异常可以在调用`divide`函数的`try - catch`块中被捕获和处理。
- **异常传播**：如果在一个函数中抛出异常，并且函数内部没有`try - catch`块来捕获这个异常，异常会沿着函数调用栈向上传播，直到找到一个匹配的`catch`块。例如，在多层函数嵌套调用中，异常会从内层函数向外层函数传播，直到被捕获或者导致程序终止。

3. 自定义异常类（扩展异常处理）

- **定义和使用**：可以通过继承`std::exception`类或者其他标准异常类来创建自定义的异常类。例如：

```cpp
      class MyException : public std::exception {
      private:
          std::string errorMessage;
      public:
          MyException(const std::string& msg) : errorMessage(msg) {}
          const char* what() const noexcept override {
              return errorMessage.c_str();
          }
      };
```

- 这个自定义的`MyException`类包含一个错误消息成员变量`errorMessage`，并且重写了`what()`函数来返回错误消息。在程序中，可以像使用其他标准异常一样使用它：

```cpp
      try {
          throw MyException("This is a custom exception");
      } catch (const MyException& e) {
          std::cerr << "Custom exception: " << e.what() << std::endl;
      }
```

- **继承层次结构优势**：通过创建自定义异常类的继承层次结构，可以更好地组织和分类异常。例如，可以有一个基类异常用于表示一般性的错误，而派生类异常用于表示更具体的错误类型，这样在`catch`块中可以根据不同的异常类型进行更精细的处理。

### 41. static的作用





### 42. 值传递、指针传递、引用传递的区别、使用场景和效率

## C++11新标准

### 1. 有哪些新特性

### 2. auto decltype decltype(auto)

1. `decltype`关键字
   - 定义与基本原理
     - `decltype`用于查询表达式的类型。它的**返回值是操作数的类型，而不是表达式的值**。例如，`int x = 5; decltype(x) y;`，这里`y`的类型会被推断为`int`，因为`decltype`根据`x`的类型来确定`y`的类型。
   - 用途和场景
     - **模板编程中的类型推断**：在模板函数或模板类中，当需要根据传入的参数类型来确定另一个变量或返回值的类型时，`decltype`很有用。例如：

```cpp
     template<typename T1, typename T2>
// -> decltype(a + b)使用了 C++11 引入的后置返回类型语法。
     auto add(T1 a, T2 b) -> decltype(a + b) {
         return a + b;
     }
```

- **与`auto`配合使用（`decltype(auto)`）**：在某些复杂的类型推断场景中，如函数返回引用类型时，`decltype`可以和`auto`结合使用，以正确推断返回类型。
- 限制和注意事项
  - 对于`decltype`表达式，如果**操作数是一个左值，那么`decltype`返回左值引用**类型；如果**操作数是一个右值，那么返回非引用**类型。例如，`int x = 5; decltype((x)) y = x;`，这里`y`是`int&`类型，因为`(x)`是一个左值表达式。

2. `decltype(auto)`关键字

- 定义与基本原理
  - `decltype(auto)`是 C++ 14 引入的，它结合了`auto`和`decltype`的特点，用于更精确地推断返回类型，特别是在返回引用类型或者复杂表达式类型的情况下。例如，在一个函数返回一个引用时：

```cpp
     int& getValue(int& x) {
         return x;
     }
     decltype(auto) wrapper(int& x) {
         return getValue(x);
     }
```

- 用途和场景
  - **函数返回类型推断（尤其是返回引用）**：当函数返回一个引用或者涉及复杂的表达式，并且希望准确地返回表达式的类型（包括引用类型）时，`decltype(auto)`非常有用。例如，在一个函数返回一个对象的成员引用时：

```cpp
     class MyClass {
     public:
         int& getMember() {
             return member;
         }
     private:
         int member;
     };
     decltype(auto) accessMember(MyClass& obj) {
         return obj.getMember();
     }
```

- 限制和注意事项

  - 使用`decltype(auto)`需要注意表达式的类型，特别是涉及**引用和临时对象**的情况。如果返回的表达式**是一个临时对象的引用，可能会导致悬空引用的问题**。因此，在使用`decltype(auto)`时，需要确保返回的引用是有效的。

    ```cpp
        int& getLocalRef() {
             int local = 10;
             return local;
         }
         // 这里getLocalRef返回一个局部变量的引用，当wrapper函数使用decltype(auto)返回这个引用时，就会出现悬空引用的问题，因为local在getLocalRef函数结束后就被销毁了。
         decltype(auto) wrapper() {
             return getLocalRef();
         }
    ```

    

### 3.  NULL和nullptr区别

1. `NULL`的定义与背景

   - **起源与定义**：在 C 和早期 C++ 中，`NULL`是一个用于表示空指针的宏。它通常被定义为`((void*)0)`，这意味着它本质上是一个空指针常量，将一个指针赋值为`NULL`表示这个指针不指向任何有效的内存地址。例如，在 C 语言中：

   ```C
   #ifdef __cplusplus
   #define NULL 0
   #else
   #define NULL ((void *)0)
   #endif
   ```

```c
     int *p = NULL;
```

这里`p`被初始化为一个空指针，不指向任何实际的`int`类型的内存区域。

**存在的问题**：在 C++ 中，`NULL`的定义会带来一些潜在的问题。因为 C++ 存在函数重载，当`NULL`被定义为`((void*)0)`时，它可能会导致一些模糊的函数调用。例如，有以下两个函数重载：

```cpp
     void func(int);
     void func(void*);
```

当调用`func(NULL)`时，编译器可能会产生歧义，不知道应该将`NULL`转换为`int`还是`void*`来匹配函数参数类型。

2. nullptr

   **C++11 引入**：`nullptr`是 C++11 新引入的关键字，专门用于表示空指针。它的类型是`std::nullptr_t`，这是一种特殊的类型，能够隐式转换为任何指针类型，但不能转换为非指针类型（如`int`、`double`等）。

   - **向后兼容性**：虽然`nullptr`在 C++11 中引入，但为了向后兼容，`NULL`仍然可以在许多 C++ 代码中看到。不过，在新的 C++ 代码中，尤其是涉及到指针操作和函数重载的场景，建议优先使用`nullptr`来表示空指针，以避免潜在的类型转换错误和函数重载歧义。
   - **代码风格与一致性**：在一个项目中，为了保持代码风格的一致性，应该尽量统一使用`nullptr`或者`NULL`。如果使用`nullptr`，可以利用其类型安全性的优势，更准确地表达代码的意图，特别是在处理指针相关的操作和函数调用时。

![image-20241004160243092](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241004160243092.png)

### 4. 智能指针的原理、常用的智能指针及实现

- 智能指针对象释放timing

1. `std::unique_ptr`的对象释放
   - **独占所有权与自动释放**：`std::unique_ptr`拥有独占式所有权，当`unique_ptr`对象生命周期结束时，它所指向的对象会自动释放。例如，在一个函数内部：

```cpp
     void func() {
         std::unique_ptr<int> p(new int(5));
         // 函数体中使用 *p或者p.get()来访问指向的整数
     } 
     // 当函数func结束时，p所指向的int对象会被自动删除
```

**资源转移后的释放**：`unique_ptr`还支持资源的转移。当通过`std::move`将资源从一个`unique_ptr`转移到另一个`unique_ptr`后，原来的`unique_ptr`不再拥有对象，新的`unique_ptr`在其生命周期结束时释放对象。例如：

```cpp
     std::unique_ptr<int> p1(new int(10));
     std::unique_ptr<int> p2 = std::move(p1);
     // 此时p1不再拥有对象，p2拥有对象，当p2生命周期结束时释放对象
```

2. `std::shared_ptr`的对象释放

- **引用计数归零后释放**：`std::shared_ptr`通过引用计数来决定对象的释放时机。当没有任何`shared_ptr`指向一个对象时（即引用计数为 0），该对象会被释放。例如：

```cpp
     {
         std::shared_ptr<int> p1(new int(20));
         std::shared_ptr<int> p2 = p1;
         // 此时引用计数为2，因为p1和p2都指向同一个int对象
     }
     // 当代码块结束，p1和p2都超出作用域，引用计数减为0，int对象被释放
```

- **在复杂的对象关系中释放**：在存在多个`shared_ptr`的复杂场景下，只要所有指向对象的`shared_ptr`都不再有效（比如被重新赋值或者销毁），对象就会被释放。例如，考虑一个简单的树形结构，节点类如下：

```cpp
     class TreeNode {
     public:
         std::shared_ptr<TreeNode> left;
         std::shared_ptr<TreeNode> right;
         int data;
         TreeNode(int val) : data(val) {}
     };
```

- 当删除树中的节点时：

```cpp
       void deleteTree(std::shared_ptr<TreeNode> root) {
           if (root) {
               deleteTree(root->left);
               deleteTree(root->right);
               root = nullptr; 
               // 当根节点以及其左右子树的所有shared_ptr都不再引用节点时，节点被释放
           }
       }
```

3. `std::weak_ptr`与对象释放的间接关系

- **不参与直接释放但辅助`shared_ptr`**：`std::weak_ptr`本身不直接管理对象的释放。它主要用于解决`shared_ptr`的循环引用问题。当`weak_ptr`所关联的`shared_ptr`对象（通过`lock`方法获取）引用计数归零并释放对象后，`weak_ptr`可以检测到这种变化。例如：

```cpp
     std::shared_ptr<int> p(new int(30));
     std::weak_ptr<int> wp = p;
     p.reset();
     // 此时，对象被释放，当通过wp.lock()尝试获取shared_ptr时，得到nullptr
```

### 5. 说一说你了解的关于lambda函数的全部知识

1. 定义与基本语法
   - Lambda 函数（也称为匿名函数）是 C++ 11 引入的一种功能强大的编程结构。它的基本语法如下：

```cpp
     [capture list](parameter list) -> return type {
         function body;
     }
```

- `[capture list]`：捕获列表，用于指定在 Lambda 函数内部可以访问哪些外部变量。这些变量可以按值或按引用进行捕获。例如，`[x]`表示按值捕获变量`x`，`[&y]`表示按引用捕获变量`y`，`[=]`表示按值捕获 Lambda 函数所在作用域内的所有变量，`[&]`表示按引用捕获所有变量。
- `(parameter list)`：参数列表，和普通函数的参数列表类似，用于定义 Lambda 函数的输入参数。如果没有参数，可以留空括号，如`[]() -> int { return 0; }`。
- `-> return type`：返回类型，用于指定 Lambda 函数的返回值类型。如果返回类型可以自动推断，这部分可以省略。例如，`[](int a, int b) { return a + b; }`，编译器可以自动推断返回类型为`int`。
- `{function body}`：函数体，包含了 Lambda 函数要执行的代码逻辑。

1. 捕获外部变量
   - **按值捕获**：当按值捕获变量时，Lambda 函数会创建一个副本。例如：

```cpp
     int x = 5;
     auto lambda1 = [x]() {
         std::cout << x << std::endl;
     };
     x = 10;
     lambda1(); 
     // 输出5，因为x是按值捕获，Lambda函数内部使用的是捕获时的副本
```

- **按引用捕获**：**按引用捕获变量意味着 Lambda 函数内部使用的是原始变量的引用**。例如：

```cpp
     int y = 5;
     auto lambda2 = [&y]() {
         std::cout << y << std::endl;
     };
     y = 10;
     lambda2(); 
     // 输出10，因为y是按引用捕获，Lambda函数内部使用的是原始变量，其值会随着原始变量的变化而变化
```

- **混合捕获和默认捕获**：可以在捕获列表中混合使用按值捕获和按引用捕获。例如，`[x, &y]`表示按值捕获`x`，按引用捕获`y`。另外，`[=]`（按值默认捕获）和`[&]`（按引用默认捕获）提供了一种方便的方式来捕获所有变量，但使用时需要注意可能出现的意外修改（对于`[&]`）或者不必要的副本（对于`[=]`）。

1. 用途和场景
   - **作为回调函数**：在很多 C++ 库（如`STL`中的算法）中，需要提供一个回调函数。Lambda 函数可以方便地作为回调函数使用。例如，在`std::for_each`算法中：

```cpp
     std::vector<int> numbers = {1, 2, 3, 4, 5};
     std::for_each(numbers.begin(), numbers.end(), [](int n) {
         std::cout << n << " ";
     });
```

- **局部函数定义**：在某些情况下，需要在一个函数内部定义一个只在局部使用的函数，Lambda 函数可以很好地满足这个需求。例如，在一个函数内部有一段特定的计算逻辑，使用 Lambda 函数可以避免定义**一个独立的、可能只使用一次的普通函数**。
- **函数式编程风格**：支持函数式编程风格的操作，如在`std::transform`算法中，可以使用 Lambda 函数来定义如何转换容器中的元素。例如：

```cpp
     std::vector<int> input = {1, 2, 3, 4, 5};
     std::vector<int> output;
     std::transform(input.begin(), input.end(), std::back_inserter(output), [](int n) {
         return n * n;
     });
```

类型和存储

- **类型推断**：Lambda 函数的类型是一个独特的**闭包类型**。编译器会根据捕获列表、参数列表和返回类型等自动推断其类型。不过，这个类型很难直接使用，因为它是编译器自动生成的，并且在不同的编译器或者编译环境下可能会有所不同。通常，我们使用`auto`关键字来存储 Lambda 函数，让编译器自动处理类型推断。
- **存储方式**：Lambda 函数在内存中的存储方式与普通函数不同。它可能会占用**栈空间（对于简单的、没有捕获外部变量的 Lambda 函数）**或者**堆空间（对于捕获了外部变量的 Lambda 函数，因为需要存储捕获的变量）**。当 Lambda 函数捕获外部变量时，它会生成一个闭包对象，这个闭包对象包含了捕获的变量以及函数指针等信息。

### 6. 智能指针的作用

自己造一个指针如int *是基本数据类型，是没有析构函数的，因此不会自动释放内存

- **避免内存泄漏**：在 C++ 中，使用普通指针时，如果忘记释放动态分配的内存，就会导致内存泄漏。例如，当使用`new`操作符在堆上创建了一个对象，但在程序结束前**没有使用`delete`操作符释放该对象占用的内存，这部分内存就无法被系统回收，会一直占用内存空间**。智能指针通过将内存的释放操作封装在对象的析构函数中，当**智能指针对象生命周期结束时，析构函数会自动被调用，从而确保所管理的内存能够被正确释放**。例如，`std::unique_ptr`在其析构函数中会自动释放它所指向的对象占用的内存，有效地避免了因忘记释放内存而导致的内存泄漏问题。
- **防止悬空指针**：悬空指针是指指针所指向的内存已经被释放，但指针仍然存在并可能被错误地使用。智能指针通过其内部的管理机制可以避免这种情况。例如，`std::shared_ptr`使用引用计数来确保只有当没有任何智能指针引用某个对象时，该对象才会被释放。这样可以防止在一个指针已经释放了所指向的对象后，其他指针还错误地访问这个已经不存在的对象。

- **异常安全**：在存在异常的情况下，智能指针可以保证资源的正确释放。例如，在一个函数中，使用普通指针进行资源分配和操作，如果在操作过程中抛出异常，并且没有妥善处理指针的释放，就可能导致资源泄漏。而使用智能指针，即使**在抛出异常的情况下，智能指针的析构函数仍然会被调用，从而保证了资源的安全释放**。例如，在一个复杂的函数调用链中，`std::shared_ptr`可以在任何环节抛出异常时，确保其管理的资源不会出现泄漏，提高了代码在异常情况下的安全性。
- **资源所有权管理清晰化**：智能指针**明确了资源的所有权和共享关系**，使得代码的逻辑更加清晰。例如，`std::unique_ptr`表示独占式所有权，一个对象只能被一个`unique_ptr`拥有，这种独占性使得代码的资源管理责任明确。而`std::shared_ptr`通过引用计数来表示共享所有权，多个`shared_ptr`可以指向同一个对象，程序员可以清楚地知道资源在多个部分之间是共享的关系，便于理解和维护代码中的资源管理逻辑。



### 7. 智能指针的循环引用

让我们用一个更具体的场景来解释循环引用。想象有两个类，`Person`和`Car`。一个`Person`可以拥有一辆`Car`，一辆`Car`也可以属于一个`Person`。我们用`shared_ptr`来表示这种关系：

```cpp
      class Person;
      class Car;
      class Person {
      public:
          std::shared_ptr<Car> myCar;
      };
      class Car {
      public:
          std::shared_ptr<Person> myOwner;
      };
```

当我们创建一个`Person`和一辆`Car`并且让它们互相引用时，就会出现循环引用。比如：

```cpp
      std::shared_ptr<Person> p(new Person);
      std::shared_ptr<Car> c(new Car);
      p->myCar = c;
      c->myOwner = p;
```

在这里，`p`指向`Person`对象，`c`指向`Car`对象。同时，`Person`对象中的`myCar`成员又指向`Car`对象，`Car`对象中的`myOwner`成员又指向`Person`对象，形成了一个循环引用的关系。

1. **深入理解引用计数与内存泄漏的关系**
   - `shared_ptr`的一个重要机制是引用计数。当创建一个`shared_ptr`并指向一个对象时，这个对象的引用计数初始化为 1。每当有一个新的`shared_ptr`指向这个对象时，引用计数就会加 1；当一个`shared_ptr`不再指向这个对象（比如它被重新赋值或者超出了作用域）时，引用计数就会减 1。当引用计数为 0 时，`shared_ptr`就会释放它所指向的对象。
   - 在我们刚才的例子中，`Person`对象的引用计数**至少是 1**（因为`p`指向它），而且由于`Car`对象中的`myOwner`也指向`Person`对象，所以即使`p`超出了作用域，`Person`对象的引用计数也不会变为 0。同样的道理，`Car`对象的引用计数也不会变为 0。这就导致即使`p`和`c`所在的作用域结束，`Person`和`Car`对象都不会被释放，它们占用的内存就一直被占用，无法被系统回收，从而产生了内存泄漏。
2. **详细解释`weak_ptr`如何解决问题**
   - `weak_ptr`是一种特殊的智能指针，它主要用于辅助`shared_ptr`来解决循环引用的问题。`weak_ptr`可以指向一个由`shared_ptr`管理的对象，但是它不会增加这个对象的引用计数。
   - 我们来修改前面的例子，把`Car`类中的`myOwner`成员从`shared_ptr`改为`weak_ptr`：

```cpp
      class Person;
      class Car;
      class Person {
      public:
          std::shared_ptr<Car> myCar;
      };
      class Car {
      public:
          std::weak_ptr<Person> myOwner;
      };
```

- 现在，当我们创建`Person`和`Car`对象并建立它们之间的关系时，`Car`对象中的`myOwner`（`weak_ptr`类型）指向`Person`对象，但不会增加`Person`对象的引用计数。当`p`（指向`Person`对象的`shared_ptr`）超出作用域时，`Person`对象的引用计数可以正常地减为 0，然后这个对象就会被释放。此时，`Car`对象的`myOwner`会发现它所指向的`Person`对象已经不存在了（因为`Person`对象已经被释放）。这样就避免了循环引用，`Car`对象最终也可以在没有其他`shared_ptr`指向它的时候被正常释放，从而解决了内存泄漏的问题。

### 8. 手写实现智能指针需要实现哪些函数

1. 以`std::unique_ptr`为例

构造函数和析构函数

- **构造函数**：需要实现一个或多个构造函数来初始化智能指针。可以有默认构造函数（将指针初始化为`nullptr`）、接受裸指针的构造函数。例如：

```cpp
        template<typename T>
        class MyUniquePtr {
        private:
            T* ptr;
        public:
            MyUniquePtr() : ptr(nullptr) {}
            MyUniquePtr(T* p) : ptr(p) {}
        };
```

- **析构函数**：用于在智能指针生命周期结束时释放所管理的资源。对于`unique_ptr`，因为是独占式所有权，所以直接释放指针所指向的对象即可。例如：

```cpp
        ~MyUniquePtr() {
            delete ptr;
        }
```

- 解引用运算符（`*`）和成员访问运算符（`->`）重载
  - **解引用运算符（`*`）**：使得智能指针可以像普通指针一样通过`*`进行解引用，获取所指向对象的值。例如：

```cpp
        T& operator*() {
            return *ptr;
        }
```

- **成员访问运算符（`->`）**：用于访问所指向对象的成员函数和成员变量，特别是当所指向对象是一个类或者结构体时非常有用。例如：

```cpp
        T* operator->() {
            return ptr;
        }
```

移动构造函数和移动赋值运算符

- **移动构造函数**：实现独占资源的转移。它接收一个右值引用的`MyUniquePtr`对象，将资源从被移动的对象转移到新对象中，并将被移动对象的指针置为`nullptr`。例如：

```cpp
        MyUniquePtr(MyUniquePtr&& other) {
            ptr = other.ptr;
            other.ptr = nullptr;
        }
```

- **移动赋值运算符**：将当前对象的资源释放，然后接收另一个`MyUniquePtr`对象（右值引用）的资源，同样将被移动对象的指针置为`nullptr`。移动赋值运算符主要用于**处理临时对象（右值）的资源转移，避免不必要的资源复制开销**。当一个对象是右值（例如临时对象或者即将被销毁的对象）时，移动赋值运算符会被调用，有效地将资源从一个对象 “移动” 到另一个对象。例如：

```cpp
        MyUniquePtr& operator=(MyUniquePtr&& other) {
            if (this!= &other) {
                delete ptr;
                ptr = other.ptr;
                other.ptr = nullptr;
            }
            return *this;
        }
```

2. 以`std::shared_ptr`为例（简单实现，不考虑线程安全等复杂情况）

构造函数和析构函数

- **构造函数**：除了基本的默认构造函数和接受裸指针的构造函数外，还需要考虑引用计数的初始化。引用计数可以使用一个单独的类来管理，或者简单地使用一个`int`变量。例如：

```cpp
        template<typename T>
        class MySharedPtr {
        private:
            T* ptr;
            int* ref_count;
        public:
            MySharedPtr() : ptr(nullptr), ref_count(new int(0)) {}
            MySharedPtr(T* p) : ptr(p), ref_count(new int(1)) {}
        };
```

- **析构函数**：当引用计数减为 0 时，释放所指向的对象和引用计数的内存。例如：

```cpp
        ~MySharedPtr() {
            (*ref_count)--;
            if (*ref_count == 0) {
                delete ptr;
                delete ref_count;
            }
        }
```

- 解引用运算符（`*`）和成员访问运算符（`->`）重载，使得可以像普通指针一样访问所指向的对象。例如：
  - **解引用运算符（`\*`）**：

```cpp
        T& operator*() {
            return *ptr;
        }
```

- **成员访问运算符（`->`）**：

```cpp
        T* operator->() {
            return ptr;
        }
```

拷贝构造函数和拷贝赋值运算符

- **拷贝构造函数**：实现共享资源，新创建的`MySharedPtr`对象与被拷贝的对象指向相同的资源，并增加引用计数。例如：

```cpp
        MySharedPtr(const MySharedPtr& other) {
            ptr = other.ptr;
            ref_count = other.ref_count;
            (*ref_count)++;
        }
```

- **拷贝赋值运算符**：先将当前对象的引用计数减 1，如果减为 0 则释放资源，然后再进行与拷贝构造函数类似的操作，指向新的资源并增加引用计数。例如：

```cpp
        MySharedPtr& operator=(const MySharedPtr& other) {
            if (this!= &other) {
                (*ref_count)--;
                if (*ref_count == 0) {
                    delete ptr;
                    delete ref_count;
                }
                ptr = other.ptr;
                ref_count = other.ref_count;
                (*ref_count)++;
            }
            return *this;
        }
```

### 9. 智能指针的使用场景

1. **`std::unique_ptr`的使用场景**
   - 独占资源管理
     - **场景描述**：在一个函数内部动态分配了一个资源，并且这个资源只在该函数内部使用，函数结束后资源就应该被释放。例如，在一个文件读取函数中，动态分配了一个缓冲区来存储文件内容。
     - **代码示例**：

```cpp
       std::vector<int> readFile(const std::string& filename) {
           std::unique_ptr<char[]> buffer(new char[1024]);
           // 打开文件，读取内容到buffer等操作
           std::vector<int> result;
           // 假设从buffer解析数据到result向量
           return result;
       }
```

- 在这里，`buffer`是一个`unique_ptr`，它独占了动态分配的字符数组。当`readFile`函数结束时，`buffer`的析构函数会自动释放这个字符数组，防止内存泄漏。这种独占式的管理很适合局部资源的分配，确保资源的生命周期与函数执行周期紧密相关。
- **对象所有权转移**
  - **场景描述**：在对象的工厂函数中创建对象并返回，同时将对象的所有权转移给调用者。例如，创建一个图形对象（如`Circle`）的工厂函数。
  - **代码示例**：

```cpp
       class Circle {
       public:
           // Circle的成员函数等
       };
       std::unique_ptr<Circle> createCircle() {
           std::unique_ptr<Circle> circlePtr(new Circle);
           return std::move(circlePtr);
       }
```

- 函数`createCircle`创建了一个`Circle`对象，并将其封装在`unique_ptr`中。通过`std::move`将`circlePtr`的所有权转移给函数的调用者。调用者获得了对象的独占所有权，负责后续对该对象的管理和销毁。

2. **`std::shared_ptr`的使用场景**

- 共享资源管理
  - **场景描述**：在一个复杂的数据结构中，多个对象需要共享同一份资源。例如，**在一个图形渲染系统中，多个图形对象可能共享同一份材质资源**。
  - **代码示例**：

```cpp
       class Material {
       public:
           // 材质的属性和方法
       };
       class Shape {
       public:
           std::shared_ptr<Material> material;
           Shape(std::shared_ptr<Material> mat) : material(mat) {}
       };
       int main() {
           std::shared_ptr<Material> commonMaterial(new Material);
           Shape shape1(commonMaterial);
           Shape shape2(commonMaterial);
           // 此时commonMaterial的引用计数为2，因为有两个Shape对象共享它
           return 0;
       }
```

- 在这里，`commonMaterial`是一个`shared_ptr`，它指向一份`Material`资源。`Shape`类的对象`shape1`和`shape2`都通过`shared_ptr`共享这份`Material`资源。只要还有`Shape`对象（或者其他地方）引用这份`Material`资源（即`commonMaterial`的引用计数不为 0），资源就不会被释放，这确保了资源在多个对象之间的共享是安全的，不会被意外销毁。
- **跨模块或长生命周期共享对象**
  - **场景描述**：在一个大型项目中，不同的模块可能需要访问和共享同一个对象。例如，一个配置对象，多个模块（如数据库模块、网络模块、用户界面模块）都需要读取和修改它的内容。
  - **代码示例**：

```cpp
       class Configuration {
       public:
           // 配置参数和方法
       };
       // 在某个初始化模块中
       std::shared_ptr<Configuration> globalConfig(new Configuration);
       // 数据库模块函数
       void databaseModule(std::shared_ptr<Configuration> config) {
           // 使用config进行数据库相关的配置操作
       }
       // 网络模块函数
       void networkModule(std::shared_ptr<Configuration> config) {
           // 使用config进行网络相关的配置操作
       }
       int main() {
           databaseModule(globalConfig);
           networkModule(globalConfig);
           // 只要还有模块在使用globalConfig，它所指向的Configuration对象就不会被释放
           return 0;
       }
```

- 这个例子中，`globalConfig`作为一个全局共享的`Configuration`对象，通过`shared_ptr`在不同的模块之间传递和共享。每个模块都可以安全地使用这个对象，而不用担心对象在其他模块还在使用时被意外销毁。
