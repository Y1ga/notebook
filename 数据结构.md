# 复杂度

## 时间复杂度

#### 单层循环

1. 找出时间t与i的关系式
2. 找出循环停止条件
3. 联立

![image-20240507114036699](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507114036699.png)

![image-20240507114233092](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507114233092.png)

#### 双层循环

1. 找出外层循环执行次数
2. 找出内层循环执行次数
3. 相加

![image-20240507114814144](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507114814144.png)

1. 外层循环是log2n
2. 内层循环是n
3. 相加是nlog2n

#### 多层循环

## 空间复杂度

研究辅助空间大小与输入数据量n的关系

![image-20240507115630994](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507115630994.png)

![image-20240507115948824](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507115948824.png)

实际只占4B，因为k=1是局部变量用完就销毁,O(1)

![image-20240507120133149](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507120133149.png)

数组传的只是指针（8B），因此占12B，O(1)

# 数组

**数组是存放在连续内存空间上的相同类型数据的集合。**

![image-20240515113432674](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240515113432674.png)

- 二分法
- 双指针
- 滑动窗口
- 螺旋矩阵

![image-20240515105015928](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240515105015928.png)

## 二分法

### 左闭右闭

1. 区间问题假设均为[1, 1]
2. left, right问题考虑区间是否取得到，若为**开区间则不必加戏**；若为闭区间要加戏

```java
int a[];
int left = 0;
int right = a.length - 1;
// 设想区间是[1, 1]
// left == right在区间是有意义的
while (left <= right) {
    int mid = (left + right) / 2;
    if (a[mid] > target) {
        // 因为mid≠target，又right取得到，因此right不能等于mid
        right = mid - 1;
    } else if (a[mid] < target) {
        // 同理mid已经验证过≠target，则left不再取到mid而是mid+1
        left = mid + 1;
    } else	return mid;
}
return -1;
```

### 左闭右开

```java
int a[];
int left = 0;
int right = a.length;
// 假设是[1, 1)
// 很明显是fifa，left==right在区间[left, right)没有意义
while (left < right) {
    int mid = (left + right) / 2;
    // 由于right取不到，因此right此时应＝mid
    if (a[mid] > target) {
        right = mid;
    } else if (a[mid] < target) {
        // 由于left取得到，mid已经验证过≠，因此要mid+1
        left = mid + 1;
    } else	return mid;
}
return -1;
```

## 习题

### 二分查找

#### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```java
// 一刷：查找结束如果没有相等值则返回 left，该值为插入位置
// 二刷：ok！
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] > target){
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else{
                return mid;
            }
        }
        return left;
	}
}
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

```java
// 一刷：二分法除了可以找元素索引还可以用于找左右边界
// 右边界：nums[mid] <= target时的left值？
// 左边界：nums[mid] >= target时的right值？
// 二刷：nums[mid] > target时寻找右边界， 位置分布"left target mid right"
// 此时left为最靠近的右边界；同理<时位置分布"left mid target right"
// right为最靠近的左边界
// 最后leftboarder-1是对left = mid+1;rightboarder = left的粗糙处理的补偿
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftboarder = getLeftBoarder(nums, target);
        int rightborader = getRightBoarder(nums, target);
        if (leftboarder == -2 || rightborader == -2) return new int[] {-1, -1};
        if ((rightborader - leftboarder) > 1) return new int[] {leftboarder + 1, rightborader - 1};
        return new int[] {-1, -1};
    }

    public int getRightBoarder(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int rightborader = -2;
        while (left <= right) {
            // 等价于(left + right) / 2防止当left和right都很大时相加的和很大使内存溢出
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                // 当mid值==target时
                left = mid + 1;
                rightborader = left;
            }
        }
        return rightborader;
    }

    public int getLeftBoarder(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int leftboarder = -2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) { 
                left = mid + 1;
            } else {
                right = mid - 1;
                leftboarder = right;
            }
        }
        return leftboarder;
    }
}
```

#### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```java
// 一刷：由于受left仅=left影响
// mid更新时需要补偿一个1不然会造成死循环
// 二刷：没懂为什么左开右闭？因为不一定等于可能是小于例如8的平方根是2明显是小于
// 不要用mid * mid > x，防止乘法溢出

class Solution {
    public int mySqrt(int x) {
        if (x == 0 || x == 1)   return x;
        int left = 1, right = x / 2;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;
            if (mid > x / mid) {
                // 下一轮搜索区间是[left...mid - 1]
                right = mid - 1;
            } else{
                // 下一轮搜索区间是[mid..right]
                left = mid;
            } 
        }
        return left;
    }
}
```

#### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```java
// 二刷：防止内存溢出用long 
// mid * mid > num 与 mid > num / mid不同因为 num / mid会发生强制类型转换例如2 == 5/2 ≠ 2*2 <5
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num == 1) return true;
        long left = 1, right = num / 2;
        while (left <= right){
            long mid = left + (right - left) / 2;
            if(mid * mid > num){
                right = mid -1;
            }else if (mid * mid < num){
                left = mid + 1;
            } else return true;
        }
        return false;
    }
}
```



### 删除元素（双指针）

#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

 

##### 解答

```java
// 快慢指针（双指针）
// 二刷。。。nums[left+1]改变后必与后面不一样啊
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 1;
        while (fast < nums.length){
            if (nums[slow] != nums[fast]){
                nums[slow+1] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow + 1;
    }
}
```

#### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

##### 解答

```java
// 一刷：双指针，一个负责记录（兼重新排序），一个负责（检索）
// 二刷：i = left+1而不是left，因为是++left没有加过
class Solution {
    public void moveZeroes(int[] nums) {
        int left = -1, right = 0;
        while(right < nums.length){
            if (nums[right] != 0) {
                nums[++left] = nums[right];
            } 
            right++;
        }
        for (int i = left + 1; i < nums.length; ++i) {
            nums[i] = 0;
        }
    }
}
```

#### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```java
// 一刷：学会在不使用复制数组的情况下实现数组重排
// 二刷：使用String去比较equals而不是char array
// 三刷：else情况还是没有分析清楚，强制left>=0可以避免第一个是‘#’的情况
// new String(chs, 0, left+1);即只保留有效数组
// new String(chs, 0, chs.length)
class Solution {
    public boolean backspaceCompare(String s, String t) {
       return afeterDel(s.toCharArray()).equals(afeterDel(t.toCharArray()));
    }

    public String afeterDel(char[] chs){
        int left = -1, right = 0;
        while (right < chs.length) {
            if (chs[right] != '#'){
                chs[++left] = chs[right];
            } else{
                if (left >= 0) {
                    --left;
                }
            }
            ++right;
        }
        return new String(chs, 0, left+1);
    }
}
```

#### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```java
// 一刷：可以借助外部数组，但时间复杂度O（n)
// 二刷：left是否等于right边界条件：代入具体数值
// 输入：[-4,-1,0,3,10]，最后left = 2， right = 2，还剩一个0没处理，因此要等于，不然会漏值
class Solution {
    public int[] sortedSquares(int[] nums) {
        int left = 0, right = nums.length - 1;
        int count = nums.length - 1;
        int array[] = new int[nums.length];
        while (left <= right) {
            if (nums[left] * nums[left] > nums[right] *nums[right]){
                array[count--] = nums[left] * nums[left];
                ++left;
            } else{
                array[count--] = nums[right] * nums[right];
                --right;
            } 
        }
        return array;
    }
}
```

### 长度最小的子数组（滑动窗口）

#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```java
// 一刷：学会使用Integer.MAX_VAULE来作标志位
// 关于窗口还是迷糊
// 二刷：外循环持续加nums[right]
// 内嵌套while持续判断是否-nums[left]
// 标志位还不会
// 三刷：（求最小时用MAX标志位，最大时用0标志位）
// ans = Math.min(ans, right - left + 1);应放在第一行，count-之前肯定满足，-之后就不一定
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
            int left = 0;
            int sum = 0;
            int result = Integer.MAX_VALUE;
            for (int right = 0; right < nums.length; ++right) {
                sum += nums[right];
                while (sum >= target) {
                    result = Math.min(result, right - left + 1);
                    sum -= nums[left++];
                }
            }
            return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

#### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```java
// 一刷：a表示fruits的种类标记数组，a[fruits[i]]表示该种类出现了多少次
// ++a[fruits[i]]表示出现一次就一次数，tot总共出现的种类数目
// ans每使用一次滑动窗口计数一次
// 二刷：关于left和right还是晕的厉害
// left用于更新最开始的水果种类
// 三刷：if (--count[fruits[left++]] == 0)
// 每次进入total>2都会开始清洗left一次，统计left究竟有多少个
class Solution {
    public int totalFruit(int[] fruits) {
        int count[] = new int[fruits.length+10];
        int  total = 0;
        int result = 0;
        for (int right = 0, left = 0; right < fruits.length; ++right){
            if (++count[fruits[right]] == 1) {
                total++;
            }
            while (total > 2) {
                if (--count[fruits[left++]] == 0){
                    total--;
                }
            }
            result = Math.max(result, right - left + 1);
        }

        return result;
    }
}
```

### 螺旋矩阵

#### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```java
// 二刷：学会使用坐标法进行模拟左闭右开
// 灵魂在于更新startX和startY和offset
// loop <= n/2是因为一次能更新一半
// 更新行用i更新列用j
class Solution {
    public int[][] generateMatrix(int n) {
        int startX = 0;
        int startY = 0;
        int i = 0;
        int j = 0;
        int count = 1;
        int[][] a = new int[n][n];
        int offset = 1;
        int loop = 1;
        while(loop <= n / 2){

            for (j = startY; j < n - offset; ++j) {
                a[startX][j] = count++;
            }
            for (i = startX; i < j; ++i) {
                a[i][j] = count++;
            }
            for (;j > startY; --j){
                a[i][j] = count++;
            }
            for (;i > startX; --i){
                a[i][j] = count++;
            }
            ++startX;
            ++startY;
            ++offset;
            loop++;
        }
        if (n % 2 == 1){
            a[startX][startY] = count;
        }
        return a;
    }
}
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else   return mid;
        }
        return left;
    }
```





# 链表

链表在内存中是**不连续分布**的，即散乱分布在内存中的某地址上，分配机制取决于**操作系统的内存管理**，通过指针域的指针链接在内存中各个节点

![image-20240528101545920](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240528101545920.png)



```java
// 链表定义
public class ListNode{
	int val;
	ListNode next;
	public ListNode() {}
	public ListNode(int val) {this.val = val;}
	public ListNode(int val, ListNode next){
		this.val = val;
		this.next = next;
	}
}
```



## 习题

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```java

/* 	法1：虚拟头节点法
	一刷：欲删除结点的元素，先要知道上一个结点是什么，此为难点
    因此使用虚拟头节点时，需额外再定义一个pre指向dummy而不是head
  */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1, head);
        ListNode cur = head;
        ListNode pre = dummy;
        while (cur != null){
            if (cur.val == val){
                pre.next = cur.next;
            } else{
                pre = cur;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
}
/*	法2：原链表删除法
	需要注意既要定义pre又要定义cur
*/ 
class Solution{
    public ListNode removeElements(ListNode head, int val){
        while (head != null && head.val == val){
            head = head.next;
        }
        if (head == null) {
            return head;
        }
        ListNode cur = head.next;
        ListNode pre = head;
        while (cur != null){
            if (cur.val == val){
                pre.next = cur.next;
            } else{
                pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }
```



### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```java
/*	一刷：list是表，里面定义head和size模拟表的添加和删除
	注意index 是要< size而不是等于,size很方便便于使用for循环遍历
*/ 

class ListNode{
    int val;
    ListNode next;
    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
}
class MyLinkedList {
    ListNode head;
    int size;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    
    public int get(int index) {
        if (index < 0 || index >= size){
            return -1;
        }
        ListNode cur = head;
        for (int i = 0; i <= index; i++){
            cur = cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    public void addAtIndex(int index, int val) {
        if (index > size){
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        ListNode prev = head;
        for (int i = 0; i < index; i++){
            prev = prev.next;
        }
        ListNode toAdd = new ListNode(val);
        // 此处注意一定要先指向后者，不然会丢失
        toAdd.next = prev.next;
        prev.next = toAdd;

    }
    
    public void deleteAtIndex(int index) {
        if (index >= size || index < 0){
            return;
        }
        size--;
        if (index == 0){
            head = head.next;
            return;
        }
        ListNode cur = head;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
    }
}

```

```java
// 二刷：增加和删除要注意头元素的情况！
class ListNode{
    int val;
    ListNode next;
    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
}
class MyLinkedList {
    ListNode head;
    int size;

    public MyLinkedList() {
        head = new ListNode(0);
        size = 0;
    }

    
    public int get(int index) {
        if (index >= size || index < 0){
            return -1;
        }
        ListNode cur = head;
        for (int i = 0; i < index; ++i){
            cur = cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    public void addAtIndex(int index, int val) {
        if (index > size || index < 0){
            return;
        }
        size++;
        // 头元素特例
        if (index == 0){
            ListNode addin = new ListNode(val);
            addin.next = head;
            head = addin;
            return;
        }
        ListNode cur = head;
        for (int i = 0; i < index - 1; i++){
            cur = cur.next;
        }
        ListNode addin = new ListNode(val);
        addin.next = cur.next;
        cur.next = addin;
    }
    
    public void deleteAtIndex(int index) {
        if (index >= size || index < 0){
            return;
        }
        size--;
        // 头元素特例！
        if (index == 0){
            head = head.next;
            return;
        }
        ListNode cur = head;
        for (int i = 0; i < index - 1; i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
    }
}
```

### 反转链表

```java
// 一刷：简简又单单的双指针
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode temp = null;
        ListNode cur = head;
        ListNode pre = null;
        while (cur != null){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
        
    }
}
```

