# 复杂度

## 时间复杂度

#### 单层循环

1. 找出时间t与i的关系式
2. 找出循环停止条件
3. 联立

![image-20240507114036699](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507114036699.png)

![image-20240507114233092](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507114233092.png)

#### 双层循环

1. 找出外层循环执行次数
2. 找出内层循环执行次数
3. 相加

![image-20240507114814144](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507114814144.png)

1. 外层循环是log2n
2. 内层循环是n
3. 相加是nlog2n

#### 多层循环

## 空间复杂度

研究辅助空间大小与输入数据量n的关系

![image-20240507115630994](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507115630994.png)

![image-20240507115948824](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507115948824.png)

实际只占4B，因为k=1是局部变量用完就销毁,O(1)

![image-20240507120133149](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240507120133149.png)

数组传的只是指针（8B），因此占12B，O(1)

# 数组

**数组是存放在连续内存空间上的相同类型数据的集合。**

![image-20241010123356014](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241010123356014.png)

![image-20241010123252304](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241010123252304.png)

- 二分法
- 双指针
- 滑动窗口
- 螺旋矩阵

![image-20240515105015928](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240515105015928.png)

## 二分法

### 时间复杂度

1. **时间复杂度分析**
   - 设数组的长度为`n`，在每一次迭代中，搜索区间的长度都会减半。
   - 第一次迭代后，搜索区间长度变为`n/2`；第二次迭代后，搜索区间长度变为`n/2^2`；第三次迭代后，搜索区间长度变为`n/2^3`；以此类推。
   - 直到搜索区间长度变为 1 或者 0（即`left > right`）时，算法结束。假设经过`k`次迭代后搜索区间长度变为 1 或 0，那么有`n/2^k ≤ 1`。
   - 解这个不等式可得：`k ≥ log₂n`。
   - 所以，二分法的时间复杂度为，其中`n`是数组的长度。这里的对数是以 2 为底的，因为每次迭代都将搜索区间减半。
2. **示例理解**
   - 例如，有一个长度为 8 的有序数组`[1, 3, 5, 7, 9, 11, 13, 15]`，要查找元素 7。
   - 第一次迭代，`left = 0`，`right = 7`，`mid = 3`，`nums[mid]=7`，找到目标元素，只需要 1 次比较。
   - 如果数组长度变为 16，第一次迭代后搜索区间变为 8，第二次迭代就有可能找到目标元素，最多需要`log₂16 = 4`次比较。
   - 随着数组长度`n`的增大，比较次数大致以对数的速度增长，这体现了二分法的高效性。





二分查找法的最坏时间复杂度是多少？

二分查找法的空间复杂度是多少？

二分查找法的适用场景有哪些？

### 左闭右闭

1. 区间问题假设均为[1, 1]
2. left, right问题考虑区间是否取得到，若为**开区间则不必加戏**；若为闭区间要加戏

```java
int a[];
int left = 0;
int right = a.length - 1;
// 设想区间是[1, 1]
// left == right在区间是有意义的
while (left <= right) {
    int mid = (left + right) / 2;
    if (a[mid] > target) {
        // 因为mid≠target，又right取得到，因此right不能等于mid
        right = mid - 1;
    } else if (a[mid] < target) {
        // 同理mid已经验证过≠target，则left不再取到mid而是mid+1
        left = mid + 1;
    } else	return mid;
}
return -1;
```

### 左闭右开

```java
int a[];
int left = 0;
int right = a.length;
// 假设是[1, 1)
// 很明显是fifa，left==right在区间[left, right)没有意义
while (left < right) {
    int mid = (left + right) / 2;
    // 由于right取不到，因此right此时应＝mid
    if (a[mid] > target) {
        right = mid;
    } else if (a[mid] < target) {
        // 由于left取得到，mid已经验证过≠，因此要mid+1
        left = mid + 1;
    } else	return mid;
}
return -1;
```

## 习题

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

### 二分查找

#### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```java
// 一刷：查找结束如果没有相等值则返回 left，该值为插入位置
// 二刷：ok！
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] > target){
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else{
                return mid;
            }
        }
        return left;
	}
}
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

```java
// 一刷：二分法除了可以找元素索引还可以用于找左右边界
// 右边界：nums[mid] <= target时的left值？
// 左边界：nums[mid] >= target时的right值？
// 二刷：nums[mid] > target时寻找右边界， 位置分布"left target mid right"
// 此时left为最靠近的右边界；同理<时位置分布"left mid target right"
// right为最靠近的左边界
// 最后leftboarder-1是对left = mid+1;rightboarder = left的粗糙处理的补偿
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftboarder = getLeftBoarder(nums, target);
        int rightborader = getRightBoarder(nums, target);
        if (leftboarder == -2 || rightborader == -2) return new int[] {-1, -1};
        if ((rightborader - leftboarder) > 1) return new int[] {leftboarder + 1, rightborader - 1};
        return new int[] {-1, -1};
    }

    public int getRightBoarder(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int rightborader = -2;
        while (left <= right) {
            // 等价于(left + right) / 2防止当left和right都很大时相加的和很大使内存溢出
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                // 当mid值==target时
                left = mid + 1;
                rightborader = left;
            }
        }
        return rightborader;
    }

    public int getLeftBoarder(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int leftboarder = -2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) { 
                left = mid + 1;
            } else {
                right = mid - 1;
                leftboarder = right;
            }
        }
        return leftboarder;
    }
}
```

```CPP
// 三刷：二分法找左边界和右边界
// 1. 找左边界为例：nums[mid] == target情况，如果中间位置不是第一个元素，并且目标值大于中间位置前一个元素的值，说明中间位置的元素是目标值第一次出现的位置。
// 2. else { right = mid - 1; }：说明目标值的开始位置在当前中间位置的左侧，因为mid不一定是第一次出现的位置
// 3.  if (start == -1) return {-1, -1};空数组的情况
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() -1 ;
        int start = -1;
        int end = -1;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if (target > nums[mid]){
                left = mid + 1;
            } else if (target < nums[mid]){
                right = mid - 1;
            } else{
                if (mid == 0 || target > nums[mid - 1] ){
                    start = mid;
                    break;
                } else {
                    right = mid -1;
                }
            }
        }
        if (start == -1) return {-1, -1};
        left = start;
        right = nums.size() - 1;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if (target > nums[mid]){
                left = mid + 1;
            } else if (target < nums[mid]){
                right = mid - 1;
            } else{
                if (mid == nums.size() - 1 || target < nums[mid + 1] ){
                    end = mid;
                    break;
                } else {
                    left = mid + 1;
                }
            }
        }
        return {start, end};
    }
};
```



#### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```java
// 一刷：由于受left仅=left影响
// mid更新时需要补偿一个1不然会造成死循环
// 二刷：没懂为什么左开右闭？因为不一定等于可能是小于例如8的平方根是2明显是小于
// 不要用mid * mid > x，防止乘法溢出

class Solution {
    public int mySqrt(int x) {
        if (x == 0 || x == 1)   return x;
        int left = 1, right = x / 2;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;
            if (mid > x / mid) {
                // 下一轮搜索区间是[left...mid - 1]
                right = mid - 1;
            } else{
                // 下一轮搜索区间是[mid..right]
                left = mid;
            } 
        }
        return left;
    }
}
```

#### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```java
// 二刷：防止内存溢出用long 
// mid * mid > num 与 mid > num / mid不同因为 num / mid会发生强制类型转换例如2 == 5/2 ≠ 2*2 <5
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num == 1) return true;
        long left = 1, right = num / 2;
        while (left <= right){
            long mid = left + (right - left) / 2;
            if(mid * mid > num){
                right = mid -1;
            }else if (mid * mid < num){
                left = mid + 1;
            } else return true;
        }
        return false;
    }
}
```

```cpp
// 三刷
// 三刷：1. left * left > x用left > x / left替代防止内存溢出
// 2. ，对于输入8，正确的结果应该是2（因为2*2 = 4，3*3 = 9，2是小于8的算术平方根的最大整数），但是这段代码会返回3。这是因为当mid = 2时，x > mid * mid，所以left = mid + 1，继续循环。当mid = 3时，虽然x < mid * mid，但是此时循环已经结束，返回了left的值，即3。
class Solution {
public:
    int mySqrt(int x) {
        int left = 1;
        int right = x / 2;
        if(x == 0 || x == 1) return x;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if (x / mid > mid){
                left = mid + 1;
            } else if (x / mid < mid ){
                right = mid - 1;
            } else return mid;
        }
        if (left > x / left){
            return left - 1;
        } else{
            return left;
        }
    }
};
```



### 双指针

#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

 

##### 解答

```java
// 快慢指针（双指针）
// 二刷。。。nums[left+1]改变后必与后面不一样啊
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 1;
        while (fast < nums.length){
            if (nums[slow] != nums[fast]){
                nums[slow+1] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow + 1;
    }
}
```

#### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

##### 解答

```java
// 一刷：双指针，一个负责记录（兼重新排序），一个负责（检索）
// 二刷：i = left+1而不是left，因为是++left没有加过
class Solution {
    public void moveZeroes(int[] nums) {
        int left = -1, right = 0;
        while(right < nums.length){
            if (nums[right] != 0) {
                nums[++left] = nums[right];
            } 
            right++;
        }
        for (int i = left + 1; i < nums.length; ++i) {
            nums[i] = 0;
        }
    }
}
```

```c++
// 二刷
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.size() == 0 || nums.size() == 1){
            return;
        }
        int slow = 0;
        int fast = 1;
        while (fast < nums.size()){
            if (nums[slow] == 0 && nums[fast] != 0){
                nums[slow] = nums[fast];
                nums[fast] = 0;
            }
            if (nums[slow] != 0){
                slow++;
            }
            fast++;
        }
    }
};

```



#### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```java
// 一刷：学会在不使用复制数组的情况下实现数组重排
// 二刷：使用String去比较equals而不是char array
// 三刷：else情况还是没有分析清楚，强制left>=0可以避免第一个是‘#’的情况
// new String(chs, 0, left+1);即只保留有效数组
// new String(chs, 0, chs.length)
class Solution {
    public boolean backspaceCompare(String s, String t) {
       return afeterDel(s.toCharArray()).equals(afeterDel(t.toCharArray()));
    }

    public String afeterDel(char[] chs){
        int left = -1, right = 0;
        while (right < chs.length) {
            if (chs[right] != '#'){
                chs[++left] = chs[right];
            } else{
                if (left >= 0) {
                    --left;
                }
            }
            ++right;
        }
        return new String(chs, 0, left+1);
    }
}
```

```c++
#include <iostream>
#include <string>
// 四刷：敌退我进，敌进我退
class Solution {
public:
    bool backspaceCompare(std::string s, std::string t) {
        std::string sAfterDel = afterDel(s);
        std::string tAfterDel = afterDel(t);
        return sAfterDel == tAfterDel;
    }

    std::string afterDel(std::string str) {
        int left = -1;
        int right = 0;
        while (right < str.length()){
            if (str[right] != '#'){
                str[++left] = str[right];
            } else{
                if(left >= 0){
                    --left;
                }
            }
            right++;
        }
        return str.substr(0, left+1);
    }
};
```



#### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```java
// 一刷：可以借助外部数组，但时间复杂度O（n)
// 二刷：left是否等于right边界条件：代入具体数值
// 输入：[-4,-1,0,3,10]，最后left = 2， right = 2，还剩一个0没处理，因此要等于，不然会漏值
class Solution {
    public int[] sortedSquares(int[] nums) {
        int left = 0, right = nums.length - 1;
        int count = nums.length - 1;
        int array[] = new int[nums.length];
        while (left <= right) {
            if (nums[left] * nums[left] > nums[right] *nums[right]){
                array[count--] = nums[left] * nums[left];
                ++left;
            } else{
                array[count--] = nums[right] * nums[right];
                --right;
            } 
        }
        return array;
    }
}
```

```c++
// 三刷：在比较nums[left] * nums[left]和nums[right] * nums[right]后，没有对另一个指针进行更新。这样会导致在循环中，指针left和right可能不会正确地向中间移动，从而无法遍历完整个数组。
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        int index = nums.size() - 1;
        vector<int> vec(nums.size());
        while (left <= right){
            if (nums[left] * nums[left] > nums[right] * nums[right]){
                vec[index] = nums[left] * nums[left];
                left++; // 本来没有写这个
            } else{
                vec[index] = nums[right] * nums[right];
                right--; // 本来没有写这个
            }
            index--;
        }
        return vec;
    }
};
```



### 滑动窗口

#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![image-20241011141812342](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241011141812342.png)

![image-20241011141935166](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241011141935166.png)

```java
// 一刷：学会使用Integer.MAX_VAULE来作标志位
// 关于窗口还是迷糊
// 二刷：外循环持续加nums[right]
// 内嵌套while持续判断是否-nums[left]
// 标志位还不会
// 三刷：（求最小时用MAX标志位，最大时用0标志位）
// ans = Math.min(ans, right - left + 1);应放在第一行，count-之前肯定满足，-之后就不一定
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
            int left = 0;
            int sum = 0;
            int result = Integer.MAX_VALUE;
            for (int right = 0; right < nums.length; ++right) {
                sum += nums[right];
                while (sum >= target) {
                    result = Math.min(result, right - left + 1);
                    sum -= nums[left++];
                }
            }
            return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

```cc
// 五刷：滑动窗口不熟练
// 六刷：滑动窗口什么时候移动？>=target时
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
            int result = INT32_MAX;
            int sum = 0;
            int left = 0;
            int right = nums.size() - 1;

            for (int right = 0; right < nums.size(); ++right){
                sum += nums[right];
                while (sum >= target){
                    result = result < right - left + 1 ? result : right - left + 1;
                    sum -= nums[left++];
                }
            }
        
        return result == INT32_MAX ? 0 : result;
    }
};
```



#### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```java
// 一刷：a表示fruits的种类标记数组，a[fruits[i]]表示该种类出现了多少次
// ++a[fruits[i]]表示出现一次就一次数，tot总共出现的种类数目
// ans每使用一次滑动窗口计数一次
// 二刷：关于left和right还是晕的厉害
// left用于更新最开始的水果种类
// 三刷：if (--count[fruits[left++]] == 0)
// 每次进入total>2都会开始清洗left一次，统计left究竟有多少个
class Solution {
    public int totalFruit(int[] fruits) {
        int count[] = new int[fruits.length+10];
        int  total = 0;
        int result = 0;
        for (int right = 0, left = 0; right < fruits.length; ++right){
            if (++count[fruits[right]] == 1) {
                total++;
            }
            while (total > 2) {
                if (--count[fruits[left++]] == 0){
                    total--;
                }
            }
            result = Math.max(result, right - left + 1);
        }

        return result;
    }
}
```

```cc
// 滑动窗口left和right的确定很关键
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> map;
        int res = INT_MIN;
        int sum = 0;
        int left = 0;
        for (int right = 0; right < fruits.size(); ++right){
            if (map.size() <= 2){
                map[fruits[right]]++;
            } 
            while(map.size()>2)
            {
                map[fruits[left]]--;    
                if (map[fruits[left]] == 0){
                    map.erase(fruits[left]);
                }
                left++;
            }
            res = res > right - left + 1 ? res : right - left + 1;
        }
        return res;
    }
};
```



#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

```cc
class Solution {
public:
bool is_covered(int cnt_s[], int cnt_t[]){
    for (int i = 'A'; i <= 'Z'; i++){
        if (cnt_s[i] < cnt_t[i]){
            return false;
        }
    }
    for (int i = 'a'; i <= 'z'; i++){
        if (cnt_s[i] < cnt_t[i]){
            return false;
        }
    }
    return true;
}
    string minWindow(string s, string t) {
        int m = s.length();
        int ans_left = -1, ans_right = m;
        int cnt_s[128]{};
        int cnt_t[128]{};
        for (char c:t){
            cnt_t[c]++;
        }
        int left = 0;
        for (int right = 0; right < m; right++){
            cnt_s[s[right]]++;
            while (is_covered(cnt_s, cnt_t)){
                if (right - left < ans_right - ans_left){
                    ans_left = left;
                    ans_right = right;
                }
                cnt_s[s[left]]--;
                left++;
            }
        }
        return ans_left < 0 ? "" : s.substr(ans_left, ans_right - ans_left + 1);
    }
};
```



### 模拟行为

#### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```java
// 二刷：学会使用坐标法进行模拟左闭右开
// 灵魂在于更新startX和startY和offset
// loop <= n/2是因为一次能更新一半
// 更新行用i更新列用j
// 三刷：1. 可以发现，对于奇数边长的矩阵，最后会留下一个中心位置单独填充；对于偶数边长的矩阵，最后一圈会完全填充完毕，不存在单独的中心位置。
// 每填充一圈就称为一次 “循环”，用变量loop表示。对于一个n x n的矩阵，循环的次数正好是n / 2。例如，当n = 4时，只需要循环两次就可以完成矩阵的填充，因为每次循环填充一圈，两圈就可以填满一个4 x 4的矩阵。
// 2. offset变量的作用是随着循环的进行，逐步缩小每一圈的范围。
//当填充第一圈时，offset为 1，此时对于每一行和每一列的遍历范围应该是从 0 到n - 1，也就是整个矩阵的边界。当填充第二圈时，offset变为 2，此时每一行和每一列的遍历范围应该是从 1 到n - 2，因为第一圈已经填充完毕，现在要填充的是内部的一圈。
// 四刷：
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int startX = 0;
        int startY = 0;
        int offset = 1;
        int i = 0;
        int j = 0;
        int loop = 1;
        int count = 1;
        vector<vector<int>> vec(n, vector<int>(n , 0));
        while (loop <= n / 2){
            for (j = startY; j < n - offset; j++){
                vec[i][j] = count++;
            }
            for ( i = startX; i < n - offset; i++){
                vec[i][j] = count++;
            }
            for (; j > startY; j--){
                vec[i][j] = count++;
            }
            for (; i > startX; i--){
                vec[i][j] = count++;
            }
            startX++;
            startY++;
            loop++;
            offset++;
        }
        if (n % 2 != 0){
            vec[n / 2][n / 2] = count++;
        }
        return vec;
    }
};   
```

#### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

![image-20241011160242472](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241011160242472.png)

```cc
// 一刷：左闭右闭的写法
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
       vector<int> vec;
       int l = 0, r = matrix[0].size() - 1, t = 0, b = matrix.size() - 1;
       while (true){
        for (int i = l; i <= r; i++) vec.push_back(matrix[t][i]);
        if(++t > b) break;
        for (int i = t; i <= b; i++) vec.push_back(matrix[i][r]);
        if(--r < l) break;
        for (int i = r; i >= l; i--){
            vec.push_back(matrix[b][i]);
        }
        if (t > --b) break;
        for (int i = b; i >= t; i--) vec.push_back(matrix[i][l]);
        if (++l > r) break;
       }

        return vec;
    }
};
```

### 前缀和

#### 58. 卡码网：区间和

[题目链接(opens new window)](https://kamacoder.com/problempage.php?pid=1070)

题目描述

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```text
5
1
2
3
4
5
0 1
1 3
```

输出示例

```text
3
9
```

数据范围：

0 < n <= 100000

```cc
#include<iostream>
#include<vector>
using namespace std;
int main(){
    int n, a, b;
    cin >> n;
    vector<int> sum(n);
    vector<int> vec(n);
    int presum = 0;
    for (int i = 0; i < n; i++){
        cin >> vec[i];
        presum += vec[i];
        sum[i] = presum;
    }
    int res = 0;
    while (cin >> a >> b){
        if (a == 0) res = sum[b];
        else res = sum[b] - sum[a - 1];
        cout << res << endl;
    }
}
```



#### 44. 卡码网：开发商购买土地（第五期模拟笔试）

###### 题目描述

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 

注意：区块不可再分。

###### 输入描述

第一行输入两个正整数，代表 n 和 m。 

接下来的 n 行，每行输出 m 个正整数。

###### 输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

###### 输入示例

```
3 3
1 2 3
2 1 3
1 2 3
```

###### 输出示例

```
0
```

###### 提示信息

如果将区域按照如下方式划分：

1 2 | 3
2 1 | 3
1 2 | 3 

两个子区域内土地总价值之间的最小差距可以达到 0。

数据范围：

1 <= n, m <= 100；
n 和 m 不同时为 1。

```cc
#include <iostream>
#include <vector>
#include <climits>

using namespace std;
int main(){
    int m, n;
    cin >> m >> n;
    vector<vector<int>> vec(m, vector<int>(n));
    int sum = 0;
    for (int i = 0; i < m; ++i){
        for (int j = 0; j < n; ++j){
            cin >> vec[i][j];
            sum += vec[i][j];
        }
    }
    int result = INT_MAX;
    int count = 0;
    for (int i = 0; i < m; ++i){
        for (int j = 0; j < n; ++j){
            count += vec[i][j];
            if (j == n - 1){
                result = min(result, abs(count - (sum - count)));
            }
        }
    }
    count = 0;
    for (int j = 0; j < n; j++){
        for (int i = 0; i < m; i++){
            count += vec[i][j];
            if (i == m - 1){
                result = min(result, abs(count - (sum - count)));
            }
        }
    }
    cout << result << endl;
}
```



# 链表

链表在内存中是**不连续分布**的，即散乱分布在内存中的某地址上，分配机制取决于**操作系统的内存管理**，通过指针域的指针链接在内存中各个节点

![image-20240528101545920](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240528101545920.png)



```java
// 链表定义
public class ListNode{
	int val;
	ListNode *next;
	public ListNode() {}
	public ListNode(int val) {this.val = val;}
	public ListNode(int val, ListNode next){
		this.val = val;
		this.next = next;
	}
}
```



## 习题

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```java

/* 	法1：虚拟头节点法
	一刷：欲删除结点的元素，先要知道上一个结点是什么，此为难点
    因此使用虚拟头节点时，需额外再定义一个pre指向dummy而不是head
  */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1, head);
        ListNode cur = head;
        ListNode pre = dummy;
        while (cur != null){
            if (cur.val == val){
                pre.next = cur.next;
            } else{
                pre = cur;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
}
/*	法2：原链表删除法
	需要注意既要定义pre又要定义cur
*/ 
class Solution{
    public ListNode removeElements(ListNode head, int val){
        while (head != null && head.val == val){
            head = head.next;
        }
        if (head == null) {
            return head;
        }
        ListNode cur = head.next;
        ListNode pre = head;
        while (cur != null){
            if (cur.val == val){
                pre.next = cur.next;
            } else{
                pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }
```

```cc
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 // 二刷：基本忘光了
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* cur = dummy;
        while (cur->next != nullptr){
            if (cur->next->val != val){
                cur = cur->next;
            } else{
                ListNode *tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }
        }
        head = dummy->next;
        delete dummy;
        return head;
    }
};
```



### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```java
/*	一刷：list是表，里面定义head和size模拟表的添加和删除
	注意index 是要< size而不是等于,size很方便便于使用for循环遍历
*/ 
// 二刷：增加和删除要注意头元素的情况！

class ListNode{
    int val;
    ListNode next;
    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
}
class MyLinkedList {
    ListNode head;
    int size;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    
    public int get(int index) {
        if (index < 0 || index >= size){
            return -1;
        }
        ListNode cur = head;
        for (int i = 0; i <= index; i++){
            cur = cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    public void addAtIndex(int index, int val) {
        if (index > size){
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        ListNode prev = head;
        for (int i = 0; i < index; i++){
            prev = prev.next;
        }
        ListNode toAdd = new ListNode(val);
        // 此处注意一定要先指向后者，不然会丢失
        toAdd.next = prev.next;
        prev.next = toAdd;

    }
    
    public void deleteAtIndex(int index) {
        if (index >= size || index < 0){
            return;
        }
        size--;
        if (index == 0){
            head = head.next;
            return;
        }
        ListNode cur = head;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
    }
}

```



```cc
// 三刷：忘光了
class MyLinkedList {
public:
struct LinkedNode{
    int val;
    LinkedNode *next;
    LinkedNode(int val): val(val), next(nullptr){}
};
    LinkedNode *head;
    int size;
    MyLinkedList() {
        size = 0;
        head = new LinkedNode(0);
    }
    
    int get(int index) {
        if (index < 0 || index >= size) return -1;
        LinkedNode *cur = head->next;
        while(index--){
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        LinkedNode *newNode = new LinkedNode(val);
        newNode->next = head->next;
        head->next = newNode;
        size++;
    }
    
    void addAtTail(int val) {
        LinkedNode * newNode = new LinkedNode(val);
        LinkedNode * cur = head;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index < 0) index = 0;
        LinkedNode *newNode = new LinkedNode(val);
        LinkedNode *cur = head;
        while (index--){
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        size++;
    }
    
    void deleteAtIndex(int index) {
        if (index >= size || index < 0) return;
        LinkedNode *cur = head;
        while(index--){
            cur = cur->next;
        }
        LinkedNode *tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        tmp = nullptr;
        size--;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```



### 206. 反转链表

```java
// 一刷：简简又单单的双指针
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode temp = null;
        ListNode cur = head;
        ListNode pre = null;
        while (cur != null){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
        
    }
}
```



### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)



给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

```cc
// 一刷：画图好难
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != nullptr && cur->next->next !=nullptr){
            ListNode* tmp = cur->next;
            ListNode *tmp2 = cur ->next->next->next;

            cur->next = cur->next->next;
            cur->next->next = tmp;
            tmp->next = tmp2;

            cur = cur->next->next;
        }
        ListNode* result = dummyHead->next;
        delete dummyHead;
        return result;
    }
};
```



# 哈希表

## 定义

- 哈希表（Hash Table），也叫散列表，是一种数据结构。它可以提供快速的插入、删除和查找操作。哈希表的基本原理是通过一个哈希函数（Hash Function）将数据的关键字（Key）映射到一个固定大小的数组（称为哈希表）中的一个位置，这个位置称为哈希地址（Hash Address）。
- 例如，假设有一个简单的哈希函数`h(key)=key % size`，其中`size`是哈希表的大小，`key`是要插入的数据的关键字。如果`size = 10`，对于关键字`7`，`h(7)=7 % 10 = 7`，那么数据就会被存储到哈希表的索引为 7 的位置。

 **什么时候使用哈希法**，**当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。**

![哈希表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104234805168.png)

- 为什么需要哈希表

  - 高效的查找速度
    - 在没有哈希表的情况下，如果要在一个数组中查找一个元素，可能需要遍历整个数组，时间复杂度为（其中`n`是数组的大小）。而使用哈希表，理想情况下，查找操作的时间复杂度可以接近。这是因为通过哈希函数可以直接定位到元素可能存储的位置。
    - 例如，在一个存储用户信息的系统中，每个用户有一个唯一的用户 ID。如果使用哈希表来存储用户信息，通过用户 ID 作为关键字，在查找用户信息时，只需要计算一次哈希函数，就可以快速定位到存储该用户信息的位置。

  - 方便的数据存储和管理
    - 哈希表可以方便地存储和管理各种类型的数据。无论是简单的整数、字符串，还是复杂的对象，只要能够定义合适的哈希函数，就可以将它们存储到哈希表中。
    - 比如，在一个编译器的符号表中，需要存储变量名和它们对应的属性（如类型、作用域等）。通过将变量名作为关键字，使用哈希表可以高效地存储和查找这些变量的信息。

  - 支持动态数据操作
    - 哈希表能够很好地支持数据的插入和删除操作。当插入一个新的数据时，通过哈希函数计算其存储位置并插入；当需要删除一个数据时，找到其存储位置并将该位置的数据删除。这些操作在平均情况下都能在接近常数时间内完成。
    - 例如，在一个实时的网络流量监测系统中，需要动态地插入和删除 IP 地址及其相关的流量信息。哈希表可以快速地完成这些操作，确保系统能够及时更新数据。

![image-20241003191948904](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20241003191948904.png)

## 习题

#### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 

字母异位词

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

 

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

```cpp
// 将字母值映射为索引值
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.length(); ++i){
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.length(); ++i){
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; ++i){
            if (record[i] != 0){
                return false;
            }
        }
        return true;
    }
};
```

#### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的* 交集 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。



 

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

![set哈希法](https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png)

```cpp
// 一刷
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1;
        unordered_set<int> set2(nums1.begin(), nums1.end());
        for (int num: nums2){
            //例如，假设有一个集合`unordered_set<int> set2 = {1, 2, 3, 4, 5}`，如果执行`if (set2.find(3)!= set2.end())`，因为集合中存在元素`3`，所以`find(3)`会返回一个指向元素`3`的迭代器，这个迭代器不等于`set2.end()`，条件为真。如果执行`if (set2.find(6)!= set2.end())`，由于集合中不存在元素`6`，`find(6)`会返回`set2.end()`，条件为假。
            if (set2.find(num) != set2.end()){
                set1.insert(num);
            }
        }
        return vector<int>(set1.begin(), set1.end());
    }
};
// 二刷：set重复insert也不会有新的元素
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        std::unordered_set<int> set1(nums1.begin(), nums1.end());
        std::unordered_set<int> set2;
        for (auto n:nums2){
            if(set1.find(n)!=set1.end()){
                set2.insert(n);
            }
        }
        return vector<int> (set2.begin(), set2.end());
        
    }
};
```

那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。

直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。

#### 202.快乐数

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

```cpp
// 一刷：1.学会分解位数
// 2.利用哈希表判断是不是第一次添加
class Solution {
public:
    int getSum(int num){
        int sum = 0;
        while (num){
            sum += (num % 10) * (num % 10);
            num /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = getSum(n);
            if (sum == 1){
                return true;
            }
            if (set.find(sum) != set.end()){
                return false;
            } else{
                set.insert(sum);
            }
            n = sum;
        }
    }
};
```

#### 1. 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

```cpp
// 一刷：unordered_map牛逼
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
      
        std::unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++){
            // 核心
            auto iter = map.find(target - nums[i]);
            if (iter != map.end()){
                // iter->second就是iter对应的value
                return {iter->second, i};
            }
            // 边找边存放
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
 
    }
};
// 一刷：unordered_map牛逼
// 二刷：要插入的一个是当前num对应的i（num此时还没insert进去）以及map[target - nums[i]]
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
      std::unordered_map<int, int> map;
      for (int i = 0; i < nums.size(); ++i){
        if (map.find(target - nums[i]) != map.end()){
            return {map[target - nums[i]], i};
        }
         map.insert(pair<int, int>(nums[i], i));
      }
      return {};
    }
};
```

#### 454. 四数相加II

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

 

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

```cpp
// 一刷：哈希表牛逼，把值做key，索引做value很常见
// 二刷：1.最好不要3层循环，会超时！时间复杂度o(n^3)
// 2. umap[a+b]++牛逼就牛逼在他的value值就是把所有的a+b相同的情况都考虑进去了
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        std::unordered_map<int, int> umap;
        for (int a: nums1){
            for (int b: nums2){
                    umap[a+b]++;
            }
        }
        int count = 0;
        for (int c: nums3){
        for (int d:nums4){
            if (umap.find(0 - c-d) != umap.end()){
                count += umap[0 - c-d];
            }
        }
        }
        return count;
    }
};
```

#### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

```cpp
// 一刷：1. 哈希表耗时，但好用；二刷可以试试数组
// 2. 多加一个 && umap[c] > 0能省事！
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<int, int> umap;
        for (char c: magazine){
            umap[c]++;
        }
        for (char c: ransomNote){
            if(umap.find(c) != umap.end() && umap[c] > 0){
                umap[c]--;
            } else{
                return false;
            }
        }

        return true;
    }
};
```

#### 15. 三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```cc
// 一刷：很晕，为什么要去重
// 二刷：对于去重还是不大了解，left要=i+1，while里面也要while(left < right)不然会越界
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

#### 18. 四数之和

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

 

```cc
// 一刷：只不过是多套了个循环而已
// 二刷：去重好麻烦。。。
#include <vector>
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        std::vector<std::vector<int>> result;
        for (int i = 0; i < nums.size(); i++){
            if (nums[i] > target && nums[i] >= 0){
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            for (int j  = i + 1; j < nums.size(); ++j){
                if (nums[i] + nums[j] >= 0 && nums[i] + nums[j] > target){
                    break;
                }
                if (j > i+1 && nums[j] == nums[j - 1]){
                    continue;
                }
                int left = j + 1;
                int right = nums.size() - 1;
                while (left < right){
                    if ((long)nums[i] + nums[j] + nums[left] + nums[right] < target){
                        left++;
                    } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] > target){
                        right--;
                    } else{
                        result.push_back(std::vector<int>{nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[right] == nums[right - 1]){
                            right--;
                        }
                        while (left < right && nums[left] == nums[left + 1]){
                            left++;
                        }
                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```

## 字符串

#### 344. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

```cc
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0; i < s.size() / 2; ++i){
            swap(s[i], s[s.size() - 1 - i]);
        }
    }
};
```

swap有两种实现方式

这里讲讲特殊的异或可以实现移形又换位

```
s[i] ^= s[j];
s[j] ^= s[i];
s[i] ^= s[j];
```

> 如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。
>
> 如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。

#### 541. 反转字符串II

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

 

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

 

```cc
// 一刷：1. 可以用库函数reverse
// 2. 剩余的k情况实际是一样的处理方法
// 二刷：要考虑边界条件判断i + k <= s.size()对应剩余字符小于 2k 但大于或等于 k 个
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0; i < s.size(); i+=2*k){
            if(i + k <= s.size()){
std::reverse(s.begin()+i, s.begin()+i+k);
            } else{
                std::reverse(s.begin()+i, s.end());
            }
            
        }
        return s;
    }
};
```



#### 卡玛网 替换数字

[卡码网题目链接(opens new window)](https://kamacoder.com/problempage.php?pid=1064)

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。



```cc
// 二刷：pass！
#include <iostream>
using namespace std;
int main() {
    string s;
    cin >> s;
    int count = 0;
    for (auto c:s){
        if (c >= '0' && c <='9'){
            count++;
        }
    }
    int old_index = s.size() -1 ;
    s.resize(s.size() + count * 5);
    int new_index = s.size() - 1;
    while (new_index > 0){
        if (s[old_index] >= '0' && s[old_index] <= '9'){
            s[new_index--] = 'r';
            s[new_index--] = 'e';
            s[new_index--] = 'b';
            s[new_index--] = 'm';
            s[new_index--] = 'u';
            s[new_index--] = 'n';
        } else{
            s[new_index--] = s[old_index];
        }
        old_index--;
    }
    cout << s << endl;
}
```



#### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

```cc
// 一刷：1. 移除多余空格蛮难
// 2. 拆成多个modules分析
// 二刷：1.移除多余空格在for里面使用while{i++}

class Solution {
public:
void removeSpace(string &s){
    int slow = 0;
    for (int i = 0; i < s.size(); ++i){
        if (s[i] != ' '){
           if (slow != 0) s[slow++] = ' ';
           while (i < s.size() && s[i] != ' '){
            s[slow++] = s[i++];
           }
        } 
    }
    s.resize(slow);
}
void reverse(string &s, int start, int end){
    for (int i = start, j = end; i < j; i++, j--){
        swap(s[i], s[j]);
    }
}
    string reverseWords(string s) {
        removeSpace(s);
        reverse(s, 0, s.size() - 1);
        int slow = 0;
        for (int i = 0; i <= s.size(); i++){
            if (s[i] ==' ' || i == s.size()){
                reverse(s, slow, i - 1);
                slow = i + 1;
            }
        }
        return s;
    }
};
```



#### 55. 右旋字符串（第八期模拟笔试）

题目描述

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入描述

输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。

输出描述

输出共一行，为进行了右旋转操作后的字符串。

输入示例

```
2
abcdefg
```

输出示例

```
fgabcde
```

提示信息

数据范围：
1 <= k < 10000,
1 <= s.length < 10000;

```cc
// 二刷：std里面的reverse是左闭右开的，只需传入两个iterator即可
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main(){
    int n;
    string s;
    cin >> n >> s;
    reverse( s.begin(), s.end());
    reverse( s.begin(), s.begin() + n);
    reverse( s.begin() + n, s.end());
    cout << s << endl;
}
```

## 双指针法

# 栈与队列

![栈与队列理论1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png)






#### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

 

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

```cc
// 一刷：懵，两个栈实现队列
// 二刷：注意先判断st2是否为空
using namespace std;
class MyQueue {
public:
    stack<int> st1;
    stack<int> st2;

    MyQueue() {

    }
    
    void push(int x) {
        st1.push(x);
    }
    
    int pop() {
        if (!st2.empty()){
        auto tmp = st2.top();
        st2.pop();
        return tmp;
        }
        while (!st1.empty()){
            st2.push(st1.top());
            st1.pop();
        }
        auto tmp = st2.top();
        st2.pop();
        return tmp;
    }
    
    int peek() {
        if (!st2.empty()){
        return st2.top();
        }
        while (!st1.empty()){
            st2.push(st1.top());
            st1.pop();
        }
        return st2.top();
    }
    
    bool empty() {
      return st1.empty() && st2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



#### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

 

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

 

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

 

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

```cc
// 二刷：que的front返回队头元素；back返回队尾元素
// 三刷：pass！
class MyStack {
public:
std::queue<int> que;
    MyStack() {

    }
    
    void push(int x) {
        que.push(x);
    }
    
    int pop() {
        auto size = que.size();
        size--;
        while (size--){
        que.push(que.front());
        que.pop();
        }
        auto tmp = que.front();
        que.pop();
        return tmp;
    }
    
    int top() {
        auto size = que.size();
        size--;
        while (size--){
        que.push(que.front());
        que.pop();
        }
        auto tmp = que.front();
        que.push(que.front());
        que.pop();       
        return tmp;
    }
    
    bool empty() {
        return que.empty();
    }
};


```

#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

**输入：**s = "()"

**输出：**true

**示例 2：**

**输入：**s = "()[]{}"

**输出：**true

**示例 3：**

**输入：**s = "(]"

**输出：**false

**示例 4：**

**输入：**s = "([])"

**输出：**true



**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

```cc

// 三刷：返回的是栈.empty()
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for (int i = 0; i < s.size(); i++){
            if (s[i] == '(') st.push(')');
            else if (s[i] == '[') st.push(']');
            else if (s[i] == '{') st.push('}');
            else if (st.empty() || s[i] != st.top()){
                return false;
            } else{
                st.pop();
            }
        }
        return st.empty();
    }
};
```

#### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

 

```cpp
// 二刷：string本身就是一个栈，有push_back pop_back front back
class Solution {
public:
    string removeDuplicates(string S) {
        string result;
        for (auto c : S){
            if (result.empty() || result.back() != c){
                result.push_back(c);
            } else{
                result.pop_back();
            }
        }
        return result;

        
    }
};
```



#### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

 

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

 

**提示：**

- `1 <= tokens.length <= 104`
- `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

 

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

```cc
// 二刷：pass！
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (auto c: tokens){
            if (c == "+" || c == "-" || c == "*" || c == "/"){
                auto num1 = st.top();
                st.pop();
                auto num2 = st.top();
                st.pop();
                if (c == "+"){
                    st.push(num2 + num1);
                } else if (c == "-"){
                    st.push(num2 - num1);
                } else if (c == "*"){
                    st.push(num2 * num1);
                } else if (c == "/"){
                    st.push(num2 / num1);
                }
                
            } else{
                st.push(stoi(c));
            }
        }
        auto tmp = st.top();
        st.pop();
        return tmp;
    }
};
```

#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

```cpp
// 一刷：暴力解法会超时
// 二刷：双向队列deque，有push_back push_front front
class Solution {
public:
    class MyQueue{
        public:
        deque<int> que;
        void push(int value){
            while (!que.empty() && value > que.back()){
                que.pop_back();
            }
            que.push_back(value);
        }
        void pop(int value){
            if (!que.empty() && value == que.front()){
                que.pop_front();
            }
        }
        int front(){
            return que.front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        MyQueue que;
        for (int i = 0; i < k; i++){
            que.push(nums[i]);
        }
        res.push_back(que.front());
        for (int i = k; i < nums.size(); i++){
            que.pop(nums[i - k]);
            que.push(nums[i]);
            res.push_back(que.front());
        }
        return res;
    }
};
```



#### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

```cc
// 二刷：不懂！
class Solution {
public:
class mycomparison{
    public:
            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
};
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); ++i){
            map[nums[i]]++;
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); ++it){
            pri_que.push(*it);
            if (pri_que.size() > k){
                pri_que.pop();
            }
        }
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--){
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;

    }
};
```

#### [71. 简化路径](https://leetcode.cn/problems/simplify-path/)

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为 **更加简洁的规范路径**。

在 Unix 风格的文件系统中规则如下：

- 一个点 `'.'` 表示当前目录本身。
- 此外，两个点 `'..'` 表示将目录切换到上一级（指向父目录）。
- 任意多个连续的斜杠（即，`'//'` 或 `'///'`）都被视为单个斜杠 `'/'`。
- 任何其他格式的点（例如，`'...'` 或 `'....'`）均被视为有效的文件/目录名称。

返回的 **简化路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

 

**示例 1：**

**输入：**path = "/home/"

**输出：**"/home"

**解释：**

应删除尾随斜杠。

**示例 2：**

**输入：**path = "/home//foo/"

**输出：**"/home/foo"

**解释：**

多个连续的斜杠被单个斜杠替换。

**示例 3：**

**输入：**path = "/home/user/Documents/../Pictures"

**输出：**"/home/user/Pictures"

**解释：**

两个点 `".."` 表示上一级目录（父目录）。

**示例 4：**

**输入：**path = "/../"

**输出：**"/"

**解释：**

不可能从根目录上升一级目录。

**示例 5：**

**输入：**path = "/.../a/../b/c/../d/./"

**输出：**"/.../b/d"

**解释：**

`"..."` 在这个问题中是一个合法的目录名。

 

**提示：**

- `1 <= path.length <= 3000`
- `path` 由英文字母，数字，`'.'`，`'/'` 或 `'_'` 组成。
- `path` 是一个有效的 Unix 风格绝对路径。

# 二叉树

- 满二叉树

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png)

- 完全二叉树

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png)
