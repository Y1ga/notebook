# 1 TCP/IP四层结构

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

## 1 应用层

最顶层不负责数据传输，只需要专注于为用户提供应用功能，是操作系统的**用户态**，应用层以下则是**内核态**

## 2 传输层

数据太大超过**MSS（TCP最大报文段长度，除去IP和TCP头部的纯净数据包大小）**会分成多个block，每一个block都用一个**tcp(transmission control protocol)段**标记

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png)

### TCP

TCP有流量控制、超时重传等功能，能保证数据包可靠地传输给对方

## 3 网络层

也不负责传输，**只负责寻址（导航**），告诉应该往哪里走，路由才是操作方向盘

### IP(Internet Protocol)

IP协议具有**寻址**和**路由**2个功能

#### 1 寻址

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

如果数据包超过**MTU（一般为1500字节）**就会再次切片

#### 2 路由

物理意义的传输

![IP地址的网络号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)

## 4 网络接口层

- 在IP头部加上MAC地址，并封装成数据帧发送到网络上，**物理实现是网卡**

- MAC 地址主要用于**单个设备**的识别和本地通信，而 IP 地址则在**路由器等网络设备**的层级上发挥着更大范围的网络寻址和路由功能。
- 也就是说路由可以连接多个设备，设备需要有网卡（MAC）才能网络传输

## example



键入网址->网页显示

### 1 URL解析

对输入网址进行解析，确定要访问的服务器和文件资源

![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

- 服务器：www.server.com
- 文件资源：/dir1/file1.html

如果 URL 中省略了部分目录和文件名，浏览器会访问服务器根目录下事先设置的默认文件，如 /index.html 或 /default.html 等。

### 2 生成HTTP清求信息

根据解析的URL，浏览器生成相应的HTTP请求信息如**GET或POST请求**，其中包含请求方法、URL、协议版本、头部字段以及可能的请求体数据等

![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

### 3 真实地址查询 DNS

DNS(Domain Name System，域名服务系统)服务器将域名映射的IP地址传给客户端，具体的

![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)

1. **客户端**->请求**本地DNS服务器**
2. 本地DNS服务器->请求**根DNS服务器**
3. 根域->发送.com顶级域名服务器地址给本地DNS服务器
4. 本地DNS服务器->请求**.com顶级域名服务器**
5. .com顶级域名服务器->发送server.com服务器地址给本地DNS服务器
6. 本地DNS服务器->请求**server.com域名服务器**
7. server.com域名服务器->发送**www.server.com的IP地址**给本地DNS服务器
8. 本地DNS服务器->发送www.server.com的IP地址给客户端

### 4 协议栈

应用程序（浏览器）通过调用socket库委托协议栈工作。

- 协议栈上半TCP/UDP负责收发数据的TCP和UDP协议，接收应用层的委托执行收发数据操作
- 协议栈下半IP负责控制网络包收发操作
  - IP还包括**ICMP（Internet Control Message Protocol，互联网控制报文协议）和ARP(Address Resolution Protocol，域名解析协议)**
  - ICMP：告知网络包传送过程中产生的**错误以及各种控制信息**
  - ARP：根据IP地址查询相应的Internet的**MAC地址**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

### 5 可靠传输-TCP

TCP报文头部格式

- 源端口号和目的端口号：起点和终点
- 序号：解决**包乱序**问题
- 确定序列：确认发出去对方是否收到，没有收到就重新发送，解决**丢包问题**
- 状态位：`SYN`是发起一个连接，`ACK`是回复，`RST`是重新连接，`FIN`是结束连接
- 窗口大小：TCP要做**流量控制**和**拥塞控制**，通信双方声明一个**窗口（缓存大小）**，标识自己能够的处理能力，别发送太快撑死，也发太慢饿死

![TCP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)

#### TCP的三次握手

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

1. 一开始都处于`CLOSED`状态，先是服务器主动监听某个端口，处于`LISTEN`状态
2. 握手1：客户端发送给服务器一个**请求连接报文段**，`SYN`标志位设置为1和初始序列号`SEQ`，客户端进入`SYN_SENT`状态
3. 握手2：服务器同意连接发送给客户端一个**确认报文文段**，`SYN`标志位设置为1，`ACK`标志位设置为1，`ACK`会为`SEQ`序列号+1表示接收到了客户端的连接请求；同时服务器还产生一个自己的初始序列号`SEQ`发送给客户端，进入`SYN_RECV`状态
4. 握手3：客户端收到服务器确认报文段后，再向服务器**发送确认报文段**，`ACK`设置为1，`ACK`为初始序列号`SEQ`+1，双方进入`ESTABLISHED`状态，表示TCP连接已成功建立

#### TCP报文生成

源端口号（浏览器监听的端口）随机生成，Web服务器监听端口（HTTP默认`80`，HTTP默认`443`）

![TCP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)

### 6 远程定位-IP

![IP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)

- 源地址IP：客户端输出的IP地址
- 目标地址IP：DNS服务器解析域名后的Web服务器IP

- 协议号：使用TCP传输，则IP的协议号填`06`

#### 源地址IP选取

Linux下使用`route -n`查看路由表

- 例如：目标Web服务器IP地址为`192.168.10.200` ，则会与第一条目的子网掩码`255.255.255.0`进行与运算，结果为`192.168.10.0`，与destination的IP地址`192.168.3.0`匹配不上，则与第二条目子网掩码进行与运算
- 第二条目匹配成功则中
- 若还是不成功，则第三条目接着匹配，这里子网掩码`0.0.0.0`表示**默认网关**，怎么样与操作结果都一样

![路由表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/15.jpg)

![IP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)

### 7 两点传输-MAC

![MAC 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

- 协议号：MAC只有2种协议类型：IP（`0800`）和ARP（`0806`）
- 发送方MAC地址：**本机网卡**MAC地址
- 接收方MAC地址：web服务器的**路由器**MAC地址

#### ARP

1. 发送方直到接收方的IP地址但不知道MAC地址，构建一个ARP请求报文，包括了发送方的IP地址和MAC地址和**接收方的IP地址**
2. 发送方将**ARP请求广播到本地网络**，目标IP匹配的会响应并构建**ARP应答报文**包括自己的IP地址和**MAC地址**，接收方将ARP应答报文发送给发送方
3. 发送方接收到后会接收方的**IP地址和MAC地址存储在ARP缓存中**

ARP:通过IP地址找MAC地址

![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/34.jpg)

Linux中可以使用`arp-a`查看ARP缓存内容

![ARP 缓存内容](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg)

![MAC 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)

### 8 出口-网卡

网卡驱动获取网络包之后，将其**复制到网卡内的缓存区**中，并在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**

- 起始帧分界符是用来表示包起始位置的标记，Internet中是一个特定的 8 位二进制序列（10101011）
- **帧校验序列（Frame Check Sequence，FCS）**用来检查包传输过程是否有损坏

最后网卡将**数字信号转为电信号**发送出去

### 9 送别者-交换机

电信号到达网线接口，交换机进行接收，将**电信号转为数字信号**，然后通过FCS校验错误，若无问题则放到缓冲区

- 交换机不核对接收方MAC，将**接收的所有包都存放在缓冲区**中，因此不具有MAC地址
- 网卡具有MAC地址，若是包的接收MAC地址不是则直接丢弃

包存入缓冲区后，通过交换机的MAC地址表查询接收方MAC地址对应的端口

![交换机的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)

- 如果找不到MAC对应的端口，则会发送到除了源端口以外的所有端口，发送多余的包并无大碍，因为发送完一次就会有相应的目标设备，这时就把新的MAC地址写上
- 如果接收方MAC地址是一个广播地址，则同样发到除源端口外的所有端口，广播地址有：
  - MAC地址的`FF:FF:FF:FF:FF:FF`
  - IP地址的`255.255.255.255`

### 10 出境大门-路由器

- 路由器是**三层网络设备，基于IP设计**，路由器的各个端口都有MAC地址和IP地址
- 交换机是**二层网络设备，基于Internet设计**，端口不具有MAC地址

#### 包接收

1. 通过包末尾的FCS进行错误校验，若没问题则检查MAC头部的**接收方MAC地址**是否于自己的MAC地址匹配
2. 若不匹配则丢弃；匹配则放到**接收缓冲区**

#### 查询路由表

1. 包接收以后会**去掉MAC头部**

2. 根据IP头进行**包的转发**，按照路由表判断转发对象，与IP定位模块同

   ![路由器转发](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg)

   同样执行**与子网掩码的位与操作**看看与destination匹不匹配，不匹配就继续与下个条目

#### 包发送

1. 如果**网关（gateway）**是一个IP地址，则这个IP地址就是要转发的目标地址，还未抵达终点，需要**继续进行路由器转发**
2. 如果**网关为空**，则IP头部中的接收方IP地址就是终点

3. 知道网关后就通过`ARP`**根据IP地址查询MAC地址**，并将查询结果作为接收方MAC地址；路由器也有**ARP缓存**，现在缓存中查询，找不到再**广播ARP查询请求**
4. 完成MAC头的包装，然后像网卡一样转换成电信号通过端口发送出去
5. 发送出去的网络包**通过交换机到达下一个路由器**，接收方地址就是**下个路由器地址**，交换机会根据这一地址将包传输到下一个地址
6. 源IP和目标IP始终不变，**一直变化的是MAC地址**，因为需要MAC地址**在Internet两个设备进行包传输**



### 11 服务器与客户端

1. 扒开数据包MAC头，查看**目标MAC地址**是否与自己的MAC地址匹配
2. 扒开IP头，发现**目标IP地址**符合，根据IP头协议直到自己上层是TCP
3. 扒开TCP头，里面有**序列号**，查看这个序列号是不是我想要的，如果是就**放入缓存并返回一个ACK**，不是就丢弃。TCP头部还有**端口号**，HTTP的服务器在监听这个端口号
4. HTTP服务器把要请求的页面封装在HTTP响应报文里，依次穿上TCP,IP,MAC头部发送给客户端
5. 客户端执行相同的扒皮操作

![网络分层模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg)

# 2 TCP

## 1 TCP基本认识

### 1 什么是TCP？

TCP**面向连接**、**可靠的**、**基于字节流**的传输层通信协议

- 面向连接：“一对一”才是连接
- 可靠的：无论网络链路出现怎么样的链路变化，TCP都可以保证一个报文一定到达接收端
- 字节流：

#### 什么是连接

用于保证**可靠性和流量控制维护**的某种状态信息，这些信息的组合，包括socket、序列号和窗口大小称为连接

![img](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230428466.png)

- socket：由**IP地址和端口号**组成
- 序列号：解决乱序问题
- 窗口大小：流量控制

### 2 TCP头格式

![TCP 头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

- 序列号：在建立连接时计算机生成的**随机数**作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该【数据字节数】的大小，解决**网络包乱序**问题
- 确认应答号：指**下一次期望接收到的数据的序列号**，发送端收到这个确认应答以后可以认为这个序列号以前的数据都被正常接收，解决**丢包**问题
- 控制位
  - ACK：确认应答字段，除了最初建立连接时的SYN包之外改为**必须设置为1**
  - RST：置为1时表示TCP连接**出现异常必须强制断开连接**
  - SYN：置为1时表示希望**建立连接**，并在其序列号字段进行**序列号初始值**的设定
  - FIN：置为1时表示今后不再有数据发送，**希望断开连接**。当通信结束希望断开连接时，通信双方主机可以**相互交换FIN位为1的TCP段**

#### 如何唯一确定一个TCP连接

源地址 + 源端口 + 目标地址 + 目标端口

![TCP 四元组](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230433082.png)

### 3 TCP最大连接数

=客户端IP数(ipv4，**2^32**) * 客户端端口数(**2^16**) = 2^48

理论是那么多，实际达不到，原因：

1. 内存限制：每个TCP连接都要占用内存，操作系统内存有限，内存占满就会发生OOM
2. 文件描述符限制：每个TCP连接都是一个文件，若文件描述符占满，发生Too many open files，Linux对可打开的文件描述符数量做了三方面的限制
   - **系统级**：当前系统可打开的最大数量`/proc/sys/fs/file-max`
   - **用户级**：指定用户可打开的数量，`/etc/security/limitis.conf`
   - **进程级**：单个进程可打开的最大数量，`/proc/sys/fs/nr_open`

### 4 TCP和UDP区别

#### UDP

用户数据报协议(UDP，User Datagram Protocol)，头部只有8个字节

![image-20240826103250076](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240826103250076.png)

1. 连接：

   - TCP面向连接，传输数据前要建立连接
   - UDP不需要连接

2. 服务对象

   - TCP是一对一的两点服务
   - UDP是**一对一、一对多、多对多**的交互通信

3. 可靠性

   - TCP的数据无差错、不丢失、不重复、按序到达
   - UDP是尽最大努力交付，不保证可靠交付数据，但却可以基于UDP实现可靠的传输协议例如QUIC协议

4. 拥塞控制、流量控制

   - TCP有**拥塞控制和流量控制**机制，保证数据传输安全性
   - UDP则没有，网络很堵也不影响UDP发送速率

5. 首部开销

   - TCP首部长度较长，没有选项就有**20字节**，有就更长了

     ![img](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png)

   - UDP首部只有**8字节，固定**不变

6. 传输方式

   - TCP是**流式传输，没有边界**，保证顺序和可靠
   - UDP是**一个包一个包发送，有边界**，可能丢包和乱序

7. 分片不同

   - TCP数据大小如果**大于MSS大小就会在传输层**进行分片，目标主机收到后同样在传输层组装TCP数据包，若中途丢失一个分片只需要传输丢失的这个分片
   - UDP数据大小如果**大于MTU大小则在网络层**进行分片，目标主机收到后在IP层组装完数据，接着再传给传输层

8. 应用场景

   - TCP：可靠性交付
     - FTP文件传输
     - HTTP/HTTPS
   - UDP：随时、简单、高效：
     - 包总量较少的通信，如DNS、SNMP
     - 视频、音频等多媒体通信
     - 广播通信



#### UDP和TCP可以用同一个端口吗

sure，传输层端口号是为了区分同一个主机上不同应用程序的数据包

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg)

TCP和IP各自的端口号相互独立，TCP有一个80端口，UDP也可以有一个80端口二者不冲突

## 2 TCP连接建立

### 1 TCP三次握手过程

- 第一次：客户端序列号`client_isn`随机初始化；SYN = 1；进入`SYN-SENT`状态

![第一个报文 —— SYN 报文](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230500953.png)

- 第二次：服务端序列号随机初始化`server_isn`；SYN = 1, ACK = 1；**确认应答号填入`client_isn + 1`**；进入`SYN-RCVD`状态

![第二个报文 —— SYN + ACK 报文](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230504118.png)

- 第三次：客户端ACK = 1；**确认应答号填入`server_isn + 1`**；进入ESTABLISHED状态；服务器收到后也进入ESTABLSHED状态

![第三个报文 —— ACK 报文](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230508297.png)

#### 如何在Linux查看TCP状态

`netstat -napt`

![TCP 连接状态查看](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230520683.png)

#### 为什么是三次握手才可以初始化socket、序列号和窗口大小并建立TCP连接

- 三次才可以**阻止重复历史连接的初始化**
- 三次才可以同步双发的初始序列号
- 三次才可以避免资源浪费

![三次握手避免历史连接](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png)

1. 客户端发送ISN=90，此时客户端宕机同时SYN报文被网络阻塞服务器没收到
2. 服务端重启，重新向服务器建立连接，发送ISN=100报文（新的报文，不是重传！**重传的SYN是一样的**）
3. 服务器先收到SYN=90，发送ACK和确认应答号=90+1给客户端，客户端发现不对发送RST给服务端中断
4. 服务端收到RST连接中止
5. 服务端收到SYN=100新报文，发送ACK和确认应答号=100+1给客户端，客户端发现没毛病发送ACK和确认应答号=客户端ISN+1并确定TCP连接

- 若是二次握手，则会建立太多的无效连接，浪费资源

- 若是四次握手，则完全没有必要

  ![四次握手与三次握手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png)

- 三次则刚好还可以确认双方的ISN

#### 为什么每次建立TCP连接初始化序列号都要求不一样

1. 防止历史报文被下一个相同四元组的连接接收（主要）
2. 为了安全性，防止黑客伪造相同序列号的TCP报文被对方接收

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E7%9B%B8%E5%90%8C.png)

1. 第一次建立TCP连接，`client_seq = 0`  ，之后发送`client_seq = 1`此时网络阻塞，同时服务器断电重启
2. 第二次建立TCP连接，`client_seq = 0`，恰好双方established，上次阻塞的`client_seq = 1`重传，服务端误以为是这次的数据，误接收了历史报文

#### ISN(Initial Serial Number，初始序列号)是如何生成的

ISN = M + F

- M是计时器，每4μs+1，转一圈要4.55小时
- F是Hash算法，根据源IP、目的IP、源端口、目的端口生成随机数值，一般用MD5

#### 第一次握手丢失，会发生什么

客户端发送后进入SYN_SENT状态，若收不到服务端的SYN-ACK报文触发**超时重传，重传报文序列号是一样的**

Linux中，最大重传次数由`/proc/sys/net/ipv4/tcp_syn_retries`内核参数控制，默认值是5

通常第一次超时是1s，第二次是2s，每次超时是上次2倍

如果大于最大重传次数，则客户端就断开连接

#### 第二次握手丢失，会发生什么

客户端以为自己的问题，会超时重传；**服务端也会超时重传SYN+ACK报文**

Linux中，服务端最大重传次数由`/proc/sys/net/ipv4/tcp_synack_retries`内核参数控制，默认值是5

#### 第三次握手丢失，会发生什么

客户端回一个ACK报文同时进入ESTABLISHED状态；服务端以为自己的问题，会超时重传

**ACK报文不会重传，ACK丢失了就由对方重传对应的报文，即客户端不会重传**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png)

#### 如何避免SYN攻击

![SYN 攻击](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230625853.png)

Linux内核维护2个队列：一个是半连接队列，也就是SYN队列；一个是全连接队列，也就是accept队列

![正常流程](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png)

SYN攻击会把半连接队列占满，导致后续的SYN报文被丢弃，有4种方法避免SYN攻击

##### 1 调大netdev_max_backlog

当**网卡接收数据包速度大于内核处理速度**时，会有一个队列保存这些数据包，控制队列最大值如下参数，可以适当调大该参数的值，例如设为10000

```sh
net.core.netdev_max_backlog = 10000
```

##### 2 增大TCP半连接队列

同时增大下面三个参数

- ent.ipv4.tcp_max_syn_backlog
- listen()函数中的backlog
- net.core.somaxconn

##### 3 开启net.ipv4.tcp_syncookies

- SYN队列满以后 接收SYN包不会丢弃，而是根据算法计算出一个cookie值
- 将cookie值放到第二次握手报文的序列号里，然后服务器第二次握手给客户端
- 服务端接收到客户端应答报文时检查ACK包的合法性，若合法则将对象放到accept队列
- 程序通过调用accept()接口，从accept队列取出连接

net.ipv4.tcp_syncookies参数有下面三个值

1. 0：关闭功能
2. 1：仅当SYN半连接队列放不下再启动
3. 2：无条件开启功能

```sh
# 设置为1
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
```

##### 4 减少SYN+ACK重传次数

```sh
echo 2 > /proc/sys/net/ipv4/tcp_synack_retries
```

## 3 TCP连接断开

### 1 TCP四次挥手

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

1. 客户端发送FIN=1的报文给服务端，进入`FIN_WAIT_1`状态
2. 服务端收到报文后，向客户端发送ACK报文，进入`CLOSED_WAIT`状态
3. 客户端接收ACK报文后，进入`FIN_WAIT_2`状态
4. 服务器等处理完数据后，向客户端发送FIN报文，进入`LAST_ACK`状态
5. 客户端收到FIN报文后，回一个ACK报文，进入`TIME_WAIT`状态（**主动关闭连接才有`TIME_WAIT`状态**）
6. 服务端收到ACK报文后，进入`CLOSE`状态，服务端完成连接的关闭
7. 从客户端**发送ACK后开始计时**，经过`2MSL`后，从`TIME_WAIT`进入`CLOSE`状态，客户端完成连接关闭

每个方向都需要一个FIN和ACK，称为四次挥手

关于`close`和`shutdown`：

- 客户端收到第二次挥手后进入`FIN_WAIT_2`状态，**调用socket库的`close()`函数**关闭连接，由于无法再发送和接收数据，所以`FIN_WAIT2`状态不持续太久，默认`tcp_fin_timeout =  60s`

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png)

- 若调用的是`shutdown`函数，**只指定了关闭发送方向，接受方向没有关闭**则主动关闭方还可以接收数据，若客户端没有收到第三次挥手则会一直死等下去，`tcp_fin_timeout`无法控制shutdown

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png)

#### 第一次挥手丢失

客户端进入`FIN_WAIT_1`状态，进行FIN的超时重传，最大重发次数由`tcp_orphan_retries`控制

达到最大重传次数时，再等待上次重传时间的2倍时还是没收到，则客户端自动断开进入`CLOSE`状态

#### 第二次挥手丢失

1. 服务端进入`CLOSED_WAIT`状态
2. 由于ACK报文不会超时重传，客户端以为是自己问题会一直超时重传，同第一次挥手丢失情况

#### 第三次挥手丢失

1. 服务端进入`LAST_ACK`状态，会一直超时重传FIN报文，直到达到最大超时重传数同时等待了2倍上次超时重传时间，直接进入`CLOSE`状态
2. 客户端本身处于`FIN_WAIT_2`状态，会等待`tcp_fin_timeout =  60s`后还未收到FIN报文直接关闭

#### 第四次挥手丢失

1. 客户端进入`TIME_WAIT`状态，由于ACK报文不会重传，客户端会持续**2MSL**后进入`CLOSE`状态
2. 如果途中再次收到第三次挥手，则会**重置2MSL定时器**
3. 服务端会超时重传，直到达到...并等待...后直接进入`CLOSE`状态

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1drawio.drawio.png)

#### 为什么TIME_WAIT等待的时间时2MSL

`MSL`(**Maximum Segment Lifetime，报文最大生存时间**)，是任何报文在网络上存在的最长时间

网络中来自发送方的数据包，当这些发送方的数据包被接收方处理后向对方发送响应，一来一回需要等待2倍的时间，**2MSL表示至少允许报文丢失一次**，若ACK丢失一次，则超时重发的FIN会在第2个MSL内到达

##### MSL与TTL的区别

TTL是IP数据包可以经过的最大路由数，每经过一个路由器此值就-1，值为0时数据就被丢弃，同时发送ICMP报文通知源主机

TTL值一般为64，Linux中**MSL为30s**，意味着经过64台路由器的时间不会超过30s，如果超过则认为报文已消失在网络中

#### 为什么需要TIME_WAIT状态

1. 防止历史连接的数据，被后面相同四元组的连接错误的接收
2. 保证被动关闭连接一方能正确的被关闭

#### TIME_WAIT过多有什么危害

1. 占用系统资源，比如文件描述符、内存资源、CPU资源、线程资源
2. 占用端口资源，一般可开启的端口为32768 ~ 61000、也可以通过`net.ipv4.ip_local_port_range`参数指定范围

##### 客户端TIME_WAIT过多

占满所有端口资源，就无法对**目的IP+目的端口一样的服务端**发起连接了，但是被使用的端口还可以继续**对另一个服务端**发起连接，因为内核在定位连接是**通过四元组（源IP+源端口+目的IP+目的端口）**定位，不会因为客户端的端口一样造成连接冲突

##### 服务端(主动发起关闭连接方)TIME_WAIT过多

- 服务端只监听一个端口，不会导致端口资源受限

- 由于一个四元组唯一确定一个TCP连接，因此理论上服务端可以建立很多连接，但是TCP连接过多会占用系统资源，例如文件描述符、内存资源、CPU资源、线程资源

#### 如何优化TIME_WAIT

##### 1 打开net.ipv4.tcp_tw_reuse和net.ipv4.tcp_timestamps选项

`tcp_tw_reuse`开启后，调用`connect()`函数时，内核会随机复用`TIME_WAIT`超过1s的连接给新连接复用

前提是打开对TCP时间戳的支持，是在**TCP头部的选项**里，一共8个字节表示时间戳，第一个4字节段表示保存发送数据包时间，第二个4字节段保存最近一次接受对方发送到达数据时间

##### 2 net.ipv4.tcp_max_tw_buckets

默认为18000，表示系统中处于`TIME_WAIT`连接超过这个值时，会将后面的`TIME_WAIT`连接状态重置，很暴力

##### 3 程序中使用SO_LINGER

**不推荐，会直接跳过TIEM_WAIT状态**

设置socket选项：`l_onoff`为非0，`l_linger`为0，调用close后会直接发送`RST`标志给客户端，直**接跳过四次挥手**

```cpp
struct linger so_linger;
so_linger.l_onoff =  1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger, sizeof(so_linger));
```

#### 服务器出现大量TIME_WAIT状态原因有哪些

**`TIME_WAIT`是主动断开连接方才有的状态**，什么场景服务端主动断开连接

1. HTTP**没有使用长连接**
2. HTTP长连接**超时**
3. HTTP长连接**请求数量达到上限**

##### 没有使用长连接

HTTP/1.1开始默认开启Keep-Alive，即默认开启长连接，不过要客户端和服务端两边都开启才行

一般来说不管哪一方禁用了HTTP Keep-Alive，都由服务端主动关闭连接

##### HTTP长连接超时

只要任意一端没有明确断开连接，就保持长连接状态，浏览器会定义一个定时器，若客户端在往后一个HTTP请求后60s内没有发起新的请求，定时器时间一到nginx就触发回调函数关闭连接，服务器出现`TIME_WAIT`状态的连接

![web 服务的 心跳机制](https://cdn.xiaolincoding.com//mysql/other/2d872f947dedd24800a1867dc4f8b9ce.png)

##### HTTP长连接请求数量达到上限

服务端会有参数`keepalive_requests`定义长连接上最大能处理的请求数量，超过最大限制时就主动关闭连接

参数默认是100，意味着每个HTTP长连接最多跑100次请求

#### 服务器出现大量CLOSE_WAIT状态原因

**`CLOSE_WAIT`是被动关闭方才有的状态**，如果被动方没有调用close函数关闭连接，就无法发出FIN报文，从而无法使得`CLOSE_WAIT`状态变为`LAST_ACK`状态，**出现大量`CLOSE_WAIT`说明服务端没有调用close函数关闭连接**

TCP服务端流程：

1. 创建服务端socket，bind绑定端口，listen监听端口
2. 服务端socket注册到epoll
3. epoll_wait等待连接到来，到来时调用accept获取已连接的socket
4. 将已连接的socket注册到epoll
5. epoll_wait等待事件发生
6. 对方连接关闭，我方调用close

- 漏了2，有新连接到来时服务端无法获取已连接的socket，自然没机会对socket调用close函数
- 漏了3，没有调用accept导致大量客户端主动断开连接
- 漏了4，导致后续收到FIN报文时，服务器无法感知这个事件，自然没机会调用close
- 漏了6，代码漏处理或者执行close之前代码卡在某一个逻辑发生死锁

出现大量CLOSE_WAIT通常是代码的问题，需要针对具体代码一步步排查和定位，分析服务端为什么没有调用close

#### 如果已建立连接，但是客户端突然出现故障

TCP存在保活机制，若一个时间段内没有任何连接相关的活动，每隔一个时间间隔发送一个探测报文，包含数据很少，若连续几个探测报文没有响应，则认为TCP连接死亡，将错误信息报给上层应用

- `net.ipv4.tcp_keepalive_time=7200`：保活时间是7200s，若2小数内没有任何连接就启动保活机制
- `net.ipv4.tcp_keepalive_intvl=75`：每次检测间隔75s
- `net.ipv4.tcp_keepalive_probes=9`：检测9次无响应，认为对方不可达的，中断本次连接

在Linux中至少经过2小数11分15秒才发现一个“死亡”连接

#### 如果已建立连接，但是服务端进程崩溃会发生什么

**TCP连接信息是内核维护的**，当服务端进程崩溃后，内核需要回收进程的所有TCP连接资源，于是**内核会发送第一次挥手FIN报文，后续的挥手过程也是在内核完成，不需要进程参与，所以即使服务端的进程退出还是能与客户端完成TCP4次挥手**

### 针对TCP如何socket编程

![基于 TCP 协议的客户端和服务端工作](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png)

1. 服务端和客户端初始化socket，获得文件描述符
2. 服务端调用`bind`，将socket绑定在指定的IP地址和端口
3. 服务端调用`listen`，进行监听
4. 服务端调用`accept`，等待客户端连接
5. 客户端调用`connect`，向服务端地址和端口发起连接请求
6. 服务端`accept`返回用于传输的socket文件描述符
7. 客户端调用`write`写入数据；服务端调用`read`读入数据
8. 客户端断开连接时，调用`close`，服务端`read`读取数据时会读取到EOF待处理完数据后调用`close`

服务端调用`accept`，连接成功后会返回一个**新的已完成连接的socket用于后续传输数据**，因此监听的socket和用来传数据的socket是两个socket：监听socket、已完成连接socket

#### listen时候backlog意义

- 半连接（SYN队列）：接受一个SYN连接后处于SYN_RCVD状态
- 全连接（Accept队列）：已完成3次握手过程，处于established状态

![ SYN 队列 与 Accpet 队列 ](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230542373.png)

`int listen(int socketfd, int backlog)`

- `socketfd`：socketfd文件描述符
- `backlog`：Linux2.2以前是SYN队列大小，之后是accept队列大小，上限值是内核参数`somaxconn`大小，因此accept队伍长度=min(backlog, somaxconn)

#### accept发生在三次握手的哪一步

![socket 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

**客户端connect成功发生在第二次握手，服务端accept成功返回在三次握手成功之后**

#### 没有accept能建立tcp连接吗

可以，**accept不参与TCP三次握手过程，accept只负责从TCP全连接队伍取出一个已经连接的socket，用户通过accept系统调用拿到了已建立连接的socket，就可以对socket进行读写操作**

#### 没有listen可以建立连接吗

可以，客户端可以自己连自己形成连接，也可以两个客户端同时向对方发出建立连接，这两种情况都没有服务端也就没有listen，就能建立TCP连接

![半连接队列与全连接队列](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5/3.jpg)

## 4 可靠性传输

### 4.1  重传机制

####  超时重传

- `RTT`(Round-Trip Time，往返时延) = 数据发送时刻到接收到确认的时刻的差值，即**包的往返时间**
- `RTO`(Retransmission Timeout，超时重传时间)

![RTT](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg?)

![超时时间较长与较短](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- RTO较大，重发就慢，效率低；
- RTO较小，没有丢就重发增加网络阻塞

因此**RTO应该略大于RTT**

![RFC6289 建议的 RTO 计算 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/9.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

![image-20240826211319693](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240826211319693.png)

若超时重发的数据又超时需要重传，则超时时间间隔**加倍**，说明网络环境差，不宜频繁反复发送

#### 快速重传

不以时间为驱动，而以数据驱动

![快速重传机制](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

1. Seq1送到，ACK回2
2. Seq2没到，Seq3,4,5都到，回复3个2
3. 知道了Seq2没收到，在定时器过期前重传丢失的2
4. 收到了Seq2，全部收到，回复6

缺陷：若Seq2,3,4都没到，该重传2还是2，3，4，5，6；前者的话后面还要再ACK回三遍3才知道3也漏了；后者浪费资源

#### SACK方法

SACK(Selective Acknowledgement)，选择性确定

![选择性确认](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

在TCP头部选项字段加一个SACK，将已收到的数据信息发送给发送方，这样就知道哪些数据收到，只重发丢失的数据

要支持`SACK`，需要双方都支持，在Linux下通过`net.ipv4.tcp_sack`参数打开

#### Duplicate SACK

1. 又称D-SACK，可以让发送方知道是发出去的包丢了还是接收回应的ACK包丢了
2. 可以知道是不是发送方的数据包被网络延迟了
3. 可以知道网络是不是把发送方的数据包给复制了

![ACK 丢包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

ACK4000说明4000之前的数据已经收到，但是SACK=3000-3500说明收到重复的3000-3500数据

![网络延时](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- 连收到3个ACK1000说明1000-1499的漏发了，触发快速重传
- **ACK3000但SACK=1000-1500说明收到重复数据了**，是之前的1000-1499网络延迟了

在Linux下通过`net.ipv4.tcp_dsack`参数打开

### 4.2 滑动窗口

**窗口大小是指无需等待确认应答，而可以继续发送数据的最大值**

假设窗口大小=3个TCP段，则发送方可以连续发送3个TCP段，若有ACK丢失可以通过下个确认应答确认

![用滑动窗口方式并行处理](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

ACK600丢了没关系，后面有ACK700进行**累计确认或累计应答**了

TCP头里有一个字段叫window，即窗口大小，是**接收端告诉发送端自己还有多少缓存区可以接收数据**，于是发送端可以根据这个接收端的出列能力来发送数据，而不会导致接收端处理不过来

- 发送方滑动窗口

![32 ~ 36 字节已确认](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/18.jpg)

当收到ACK后，窗口向右滑动5个字节，会空出来5个可发送的字节

![SND.WND、SND.UN、SND.NXT](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- SND.WND：发送方滑动窗口大小
- SND.UNA：绝对指针，指向**已发送但未收到ACK**的第一个字节的序列号
- SND.NXT：绝对指针，指向**未发送但在接收方处理范围内**的序列号
- **可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)**

![接收窗口](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg)

- RCV.WND：接收方滑动窗口大小
- RCV.NXT：绝对指针，指向接收方**未接收但在接受范围内**的第一个数据
- RCV.NXT + RCV.WND：指向未接收也不在接收范围内的第一个数据

### 4.3 流量控制

让发送方根据接收方的实际接受能力控制发送的数据量，即**动态控制滑动窗口的大小**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

上图假定滑动窗口大小固定，最终会发生**窗口关闭**

#### 窗口关闭

![窗口关闭潜在的危险](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

窗口关闭会造成双方相互等待形成**死锁**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

上方是实际情况，缓冲区来不及读完上一次传过来的数据，新的数据就又过来了，并且**缓冲区+新数据加起来超出了窗口大小造成丢包**，因此需要先收缩窗口过段时间再减少缓存

#### 糊涂窗口综合征

接收方太忙来不及取走窗口的数据，**窗口越缩越小**，腾出几个字节告诉发送方现在有几个字节的窗口，而发送方义无反顾地发送这几个字节，就是糊涂窗口综合征。因为**TCP+IP头就有20个字节，为了那几个字节的小数据**很浪费

![糊涂窗口综合症](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/26.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

解决：使用nagle算法，满足下面2个条件之1才可以发送数据

1. 窗口大小 >= MSS && 数据大小 >= MSS
2. 收到之前发送数据的ACK回包

上面两条件都不满足时，发送方一直囤积数据，直到满足上面的发送条件

### 4.4 拥塞控制

网络出现堵塞时，继续发送大量数据包导致时延、丢失，TCP就会重传数据，一重传网络负担更重带来更大的延迟和更多的丢包，进入恶性循环

为了避免发送方的数据填满整个网络，就有了拥塞控制，为了在**发送方调节所要发送数据的量**，定义了**拥塞窗口`（cwnd）`**的概念，发送窗口`swnd≈`接收窗口`rwnd`，加入拥塞窗口后发送窗口`swnd = min(cwnd, rwnd)`，拥塞窗口和接收窗口的最小值

网络没有拥塞`cwnd`就变大；有拥塞`cwnd`就变小，拥塞控制有4个算法

#### 慢启动

cwnd从1开始，每收到一个ACK就+1

![慢启动算法](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

慢启动门限`ssthresh`(slow start threshold)状态变量，大小是65535字节

- `cwnd < ssthresh`时，就是慢启动
- `cwnd >= ssthresh`时，就是拥塞避免算法

#### 拥塞避免算法

线性增加，每次增加`1/cwnd`

![拥塞避免](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

#### 拥塞发生

网络出现拥塞发生重传，会超时重传或者快速重传

- 发生超时重传时，`ssthresh`设为`cwnd/2`
- `cwnd`重置为1（恢复为`cwnd`初始值，此处假定初值为1）

![拥塞发送 —— 超时重传](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

处于网络阻塞，慢启动指数增加，太激进因此还有快速重传：**接收方发现丢一个中间包就发送3次前一个包的ACK**，于是发送端会快速重传不等超时重传

TCP认为这张情况不严重，因为大部分没丢，只丢了一小部分

- `cwnd = cwnd/2`，设为原来一半
- `ssthresh = cwnd`
- 进入快速恢复算法

#### 快速恢复

与快速重传搭配使用，还能收到3个ACK说明网络不那么糟糕，所以没必要像RT0超时那么强烈

- 拥塞窗口`cwnd = ssthresh + 3`（3的意思是确认有3个数据包收到了）
- 重传丢失的数据包
- 若再收到重复的ACK，则cwnd+1
- **若收到新数据的ACK，则把cwnd设置为第一步的ssthresh的值，因为ACK确认了新的数据说明从duplicate ack时的数据已经收到，恢复过程已经结束**，可以回到恢复以前的状态再次进入拥塞避免状态

理解：快速恢复是拥塞发生后慢启动的优化，因此首要目的是通过**降低cwnd来减缓拥塞**，出现cwnd从大变小的改变；其次，**crwnd+1是为了尽快将丢失的数据包发给目标**，解决拥塞的根本问题（3次相同ACK导致的快速重传） ，因此cwnd是逐渐增大的

![快速重传和快速恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

### 6 如何理解TCP是面向字节流协议

- UDP是**面向报文**的协议，操作系统不会对消息进行拆分，**每个UDP报文就是一个用户消息的边界**
- TCP的消息可能会被系统分组成多个TCP报文，两个消息的某个部分内容被分到同一个TCP报文时，接收方**不知道消息的边界就会出现TCP沾包问题**，应交给**应用层**来解决这个问题

#### 解决沾包

- 固定长度的消息
- 特殊字符作为边界
- 自定义消息结构

##### 固定消息长度

规定一个的消息长度是64字节，接收满64个字节就认为这个内容是一个完整且有效的消息，但不灵活很少用

##### 特殊字符作为边界

HTTP通过设置回车符、换行符作为HTTP报文协议边界，消息内容含有作为边界点的特殊字符要进行转义

![图片](https://cdn.xiaolincoding.com//mysql/other/a49a6bb8cd38ae1738d9c00aec68b444.png)

##### 自定义消息结构

使用4个字节的变量来表示数据长度，真正的数据在message_data里

```cpp
struct{
	uint32_t message_length;
	char message_data[];
}
```

### tcp_tw_reuse为什么默认是关闭的

#### 为什么有TIME_WAIT状态

可以理解成是一种容错，时间=2MSL

- 防止历史连接中的数据，被后面相同四元组的连接错误接收
- 保证被动关闭连接的一方，能被正确的关闭

##### 防止历史连接中的数据，被后面相同四元组的连接错误接收

若TIME_WAIT过短或没有，因网络阻塞延迟到达服务端的数据**会恰好被下一次相同四元组的连接错误接收**（假设序列号恰好在其接收端口）

让TIME_WAIT=2MSL，**保证两个方向上的数据包都在网络中自然消失**，再出现的数据包一定是新建立连接产生的

![图片](https://cdn.xiaolincoding.com//mysql/other/f1ba45cdb7d772ccd12dc604dee26c91.png)

##### 保证被动关闭连接的一方，能被正确的关闭

客户端第四次挥手后若直接CLOSE，万一ACK在网络中丢失了，服务端会重传，处于CLOSE状态的客户端接收到会返回一个**RST并解释为一个错误**，这个终止方式不可靠不优雅

为了防止这种情况，客户端要等待足够长的时间给服务端容错即2MSL恰好是一来一回的时间

![图片](https://cdn.xiaolincoding.com//mysql/other/8016c9f9b875649a5ab8bdd245c34729.png)

#### 什么是tcp_tw_reuse

客户端（主动关闭方）的TIME_WAIT状态过多时占满所有端口资源，这时要连接另外的服务器，根据四元原则是可以复用端口的

- `net.ipv4.tcp_tw_reuse`：开启后客户端（连接发起方）调用connect函数时，若内核选到的端口已被相同四元组的连接占用时，会判断是否处于`TIME_WAIT`状态；若处于TIME_WAIT并且持续时间>1s，就会重用这个连接正常使用端口
- `net.ipv4.tcp_tw_recycle`：**允许处于TIME_WAIT状态的连接快速回收，在NAT的网络下是不安全的**

要使得上面的参数生效，就要打开TCP时间戳即`net.ipv4.tcp_timestamps=1`，一是便于精确计算RTT，二是防止序列号回绕（PAWS）

序列号是一个32位的无符号整型，上限是**4GB**，超过4GB需要将序列号回绕进行重用。在一个速度足够快的网络传输大量数据，序列号回绕时间变短需要**面临之前延迟的报文抵达后序列号依然有效**的问题，因此需要有时间戳

![图片](https://cdn.xiaolincoding.com//mysql/other/bf004909d9e44c3bc740737ced6731a0.png)

时刻B有一个报文丢失并重传，序列号在E时回绕了，时刻F丢失的报文重传成功，这时有时间戳就知道它是重传的，防回绕序列号算法（PAWS）就会将其丢弃

PAWS要求连接双方维护最近一次收到的数据包的时间戳，每收到一个新增数据包都会读取时间戳跟最近的时间戳比较，若发现收到包的时间戳不是递增的说明是过期的就会直接丢弃这个数据包

但是**若收到的包是RST则不管过不过期都会接收**，为什么这么设计，因为一般认为有TIME_WAIT状态收到过期的RST包是不可能的

#### 为什么tcp_tw_reuse是默认关闭的

##### 1 防止缺少2MSL的缓存收到过期的RST包

若上一个连接的延迟RST包被下一个连接接收到，**收到历史的RST包导致强制关闭连接，因为没有了TIME_WAIT状态用于等延迟的包消失**

![img](https://cdn.xiaolincoding.com//mysql/other/0df2003d41ec0ef23844975a85cfb722.png)

##### 2 防止缺少2MSL的缓冲使被动关闭方不能正常关闭

第四次挥手ACK丢失但没了TIME_WAIT状态太短被快速地复用进入下一个连接，服务端还在超时重传FIN+ACK（这个不是确认收到SYN报文而是challenge ACK），客户端收到challenge 回一个RST直接断掉连接

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/tcp_tw_reuse%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%97%AE%E9%A2%98.drawio.png)



### 如何基于UDP协议实线可靠传输

![img](https://cdn.xiaolincoding.com//mysql/other/605d1026df934f20a5ee12f3c55aa6a7.png)

#### 如何实现可靠传输

多了3层头部，packet、quic frame、http3 frame

![img](https://cdn.xiaolincoding.com//mysql/other/ab3283383013b707d1420b6b4cb8517c.png)

#### packet header

相当于TCP的序列号

- Long Packet Header：用于首次建立连接
- Short Packet Header：用于日常传输数据![Packet Header](https://cdn.xiaolincoding.com//mysql/other/bcf3ccb6a15c4cdebe1cd0527fdd9a5e.png)

QUIC也是需要3次握手建立连接，目的为了**协商连接ID**，协商出连接ID后再传输只需固定住连接ID实现连接迁移功能。因此short packet header不再传输源连接ID，只需要目标连接ID

short packet header的packet number是每个报文**独一无二的编号，严格递增**

![img](https://cdn.xiaolincoding.com//mysql/other/635813465fbb449882da2e2bee39f24e.png)

##### 为什么这么设计

1. 用于精确计算**RTT**时间，从而更好计算RTO时间

2. 使QUIC支持**乱序确认**

   

   ![TCP 重传的歧义问题](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/tcp%E9%87%8D%E4%BC%A0%E6%AD%A7%E4%B9%89.jpeg)



![img](https://cdn.xiaolincoding.com//mysql/other/ca91985c9a94487a8a29db1249109717.png)

#### QUIC Frame Header

![img](https://cdn.xiaolincoding.com//mysql/other/6a94d41ef3d14cb6b7846e73da6c3104.png)

以stream类型的frame为例

![img](https://cdn.xiaolincoding.com//mysql/other/536298d2c54a43b699026bffe0f85010.png)

- stream id：类似于HTTP2的stream id，用于区分多个并发传输的HTTP消息
- offset：保证数据顺序性、可靠性
- length：frame数据长度

通过单项递增的`packet number`和**stream id + offset字段实现数据的有序性**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/Packet%E4%B8%A2%E5%A4%B1.jpeg)

#### 如何解决TCP队头阻塞

##### 什么是TCP队头阻塞

![接收窗口](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg)

1. 接收窗口就那么大，若收到第52字节以上则会丢弃数据；
2. 若第32字节数据没有收到，先收到33-51，则窗口也无法滑动，重传了32才会滑动，即**TCP必须按序处理数据**

##### HTTP/2的队头阻塞

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2%E9%98%BB%E5%A1%9E.jpeg)

HTTP2抽象出stream概念支持并发传输，1stream =1 request + 1 response

但stream是排在一条TCP上的，**共用一个滑动窗口，发生数据丢失阻塞所有HTTP请求**

##### 没有队头阻塞的QUIC

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg)

**每个stream都有独立的滑动窗口**

#### QUIC如何做流量控制

**流量控制：就是接收方告诉发送方滑动窗口的大小**

- stream级别的流量控制：控制每个stream里的独立滑动窗口大小
- connection级别的流量控制：**限制连接中所有stream加起来的字节数**，防止发送方超过连接的缓存容量

##### stream级别的流量控制

![img](https://cdn.xiaolincoding.com//mysql/other/f1070a6eccd24559904815297b07f789.png)

![img](https://cdn.xiaolincoding.com//mysql/other/77e9a7cf70da4a1b981f61e78db2ad56.png)

- 左边界 = 最大 - **已收到的最大偏移字节数**
- 右边界：当**已收到且被上层读取 > 1 / 2最大窗口**时，右边界滑动”已收到且被上层读取的字节数“
- 若中途丢包，则会导致已收到且被上层读取的数据无法增大，窗口无法滑动

![接收窗口触发的滑动](https://cdn.xiaolincoding.com//mysql/other/bbde0c66088f439b919a6d18b389aadb.png)

- 乱序确认：控制数据发送限制的是**最大绝对偏移字节量**，**接收方基于当前已提交的偏移量（连续已确认并向上层应用提交的数据包offset）和发送方协商出**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/%E4%B9%B1%E5%BA%8F%E7%A1%AE%E8%AE%A41.png)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/%E4%B9%B1%E5%BA%8F%E7%A1%AE%E8%AE%A42.png)

31、32、34先到达，30没到没法确认，**当前已提交的字节偏移量不变，发送方缓存区不变**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/%E4%B9%B1%E5%BA%8F%E7%A1%AE%E8%AE%A43.png)

30到达并确认，发送方缓存区收缩到阈值，接收方发送MAX_STREAM_DATA_FRAME**（协商缓存大小的特定帧）给发送方，请求增长最大绝对字节偏移量**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/%E4%B9%B1%E5%BA%8F%E7%A1%AE%E8%AE%A44.png)

协商完成后**最大绝对字节偏移量右移**，右边界变宽缓存区增大，同时33超时

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/%E4%B9%B1%E5%BA%8F%E7%A1%AE%E8%AE%A45.png)

发送方安排编号42超时重传

##### connection流量控制

![Connection 流量控制](https://cdn.xiaolincoding.com//mysql/other/839501cffa7146cbb8d992264594e61d.png)

**通过控制最大偏移字节数来控制所有stream可用的接收窗口大小之和**

#### QUIC如何改进拥塞控制

在应用层面实现TCP哪些慢启动、快速恢复等算法，还可以加入其他新的算法入CubicBytes、Reno等，而且因为是在**应用层所以不需要底层的硬件支持，只需要不同的软件应用支持即可**，灵活得多；TCP那些都是在内核实现的，要更新相当麻烦

#### QUIC如何实现更快的连接建立

QUIC自带TLS且是1.3版本的只需1个RTT就可以完成，因此QUIC握手可以连接信息+TLS信息一起发送，只需1RTT；再次连接时，**数据包可以和QUIC握手信息（连接信息+TLS信息）一起发送，0RTT**

![img](https://cdn.xiaolincoding.com//mysql/other/4cad213f5125432693e0e2a512c2d1a1.png)

#### QUIC如何迁移连接

QUIC不像TCP需要连接四元组，**仅通过连接ID标记通信的2个端点**；网络变化后，只要留有**上下文信息（连接ID、TLS密钥）**就可以无缝从WIFI切换到4G（IP发生变化），**复用原连接消除重连成本达到连接迁移**

### TCP和UDP可以同时绑定相同的窗口吗？

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png)

UDP没有listen、accept，但都有bind

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png)

可以，因为**端口号本质是为了区分同一个主机不同应用程序的数据包**，而TCP和UDP是在内核态就完全独立的软件模块。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg)

#### 多个TCP服务进程可以绑定同一个窗口吗？

- 如果2个TCP服务进程绑定的IP地址+端口都相同，则bind就会出错，”Address already in use“

- 如果TCPA绑定0.0.0.0：8080，TCPB绑定192.168.1.100：8080，bind也会出错因为0.0.0.0表示与主机所有IP地址都进行绑定

- 如果重启TCP，服务端还在`TIME_WAIT`，再次执行bind仍会返回”Address already in use“因为需要等待2MSL的时间才会完全关闭

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

- 如果对socket设置`SO_REUSEADDR`属性，能直接跳过CD，则就能避免重启后连接不上的问题；

- 如果对socket设置`SO_REUSEADDR`属性，就能避免TCPA绑定0.0.0.0：8080，TCPB绑定192.168.1.100：8080出错的问题，因为**只要IP地址不是完全相同，就允许绑定**

#### 多个客户端可以bind同一个端口吗？

如果IP地址+端口都一样则不可以bind；**若IP地址+端口有一个不一样就可以bind**

但客户端**端口没什么意义也也没有bind的意义**，使用`connect`就好了；但同个IP同个端口是可以连接多个服务端的

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/6.jpeg)

#### 客户端TIME_WAIT过多，无法与同一个服务器建立连接怎么办？

- `net.ipv4.tcp_tw_reuse`启动，解决处于`TIME_WAIT`超过1s的端口，但是比较危险
- 如果端口用完了，但是是不同的服务器，那么还是可以端口复用的
- 如果没开启reuse，端口资源耗尽还是没找到，那么connect就会返回错误

### 服务端没有listen，客户端发起连接建立，会发生什么？

服务端如果只bind了IP地址和端口，没有调用listen，客户端与服务端发起连接建立，服务端会回RST报文

![图片](https://cdn.xiaolincoding.com//mysql/other/a77921ffafbbff86d07983ca0db3e6e0.png)

#### 没有listen能建立TCP连接吗

可以，客户端可以自己与自己形成TCP连接，也可以两个客户端同时向对方发出请求建立连接，共同点是**都没有服务端参与即没有listen就建立连接**

#### 客户端有半连接队列吗

没有，**半连接队列和全连接队列是服务端执行listen的时候内核自动创建的**

**内核有个全局hash表，用于存放sock连接信息**；TCP自连接时，客户端connect方法时，**会将自己的连接信息放入这个全局hash表中**，然后将信息发出，**消息在经过回环地址重新回到TCP传输层时会根据IP地址+端口，再一次从全局hash中取出信息**，握手包一来一回建立连接 

### 没有accept，能建立TCP连接吗？

可以

#### 半连接队列和全连接队列

![半连接队列和全连接队列](https://cdn.xiaolincoding.com//mysql/other/36242c85809865fcd2da48594de15ebb.png)

- 半连接队列（SYN队列）：服务端收到**第一次握手**后，将`sock`加入到这个队列，队列内的`sock`都处于`SYN_RECV`状态
- 全连接队列（ACCEPT队列）：服务端收到**第三次握手**后，将半连接队列的`sock`取出，放到全连接队列中。队列里的`sock`都处于`ESTABLISHED`状态，这里面的连接都等着服务端执行accept后被取出。

因此，执行accept只是为了从全连接队列里取出一条连接

![半连接全连接队列的内部结构](https://cdn.xiaolincoding.com//mysql/other/6f964fb09d6971dab1762a45dfa30b3b.png)

- 全连接队列是一个链表
- 半连接队列是一个哈希表

#### 为什么半连接队列要设计成哈希表

- 全连接队列本质是个链表，线性结构，服务端取出连接时**根本不关心具体哪个连接，直接从队列头取出**，算法复杂度O(1)
- 半连接队列里的都是不完整的连接，等着第三次握手到来，有一个第三次握手来了需要找特定的IP地址+端口，**防止遍历麻烦因而设计成哈希表**，使复杂度回到O(1)

#### 全连接队列满了这么办

**全连接队列满了收到客户端第三次握手的ACK会默认丢弃这个ACK**

- `tcp_abort_on_overflow`设置为0，全连接队列满了以后会丢弃这个第三次握手ACK包，**并且开启定时器重传第二次握手的SYN+ACK，若重传超过一定限制次数就把半连接队列里的连接删除**

  

![tcp_abort_on_overflow为0](https://cdn.xiaolincoding.com//mysql/other/874f2fb7108020fd4dcfa021f377ec66.png)

- `tcp_abort_on_overflow`设置为1，**全连接队列满了以后直接发RST给客户端，效果上看就是连接断了**
- 服务端未`listen`时，客户端尝试去连接，服务端也会回一个`RST`，因此此时**客户端分不清端口未监听还是全连接队列满了**

![tcp_abort_on_overflow为1](https://cdn.xiaolincoding.com//mysql/other/6a01c5df74748870a69921da89825d9c.png)

#### 半连接队列满了怎么办

**一般是丢弃，一般半连接生存时间很短存活于第一次和第三次握手之间**，若半连接队列满了说明服务端疯狂收到第一次握手请求，大概收到了SYN FLOOD攻击

![syn攻击](https://cdn.xiaolincoding.com//mysql/other/d894de5374a12bd5d75d86d4a718d186.png)

怎么处理呢？

```sh
cat /proc/sys/net/ipv4/tcp_syncookies
```

将`tcp_syncookies`设置为1时，客户端发来第一次握手SYN服务端**不会将其放入半连接队列而是直接生成一个cookies**，**这个cookies跟着第二次握手发回客户端**。**客户端在发第三次握手时带上这个cookies，服务端验证它是当初发出去的哪个就建立连接放入全连接队列中**

![tcp_syncookies=1](https://cdn.xiaolincoding.com//mysql/other/d696b8b345526533bde8fa990e205c32.png)

#### cookies存放在哪里

没有cookies队列防止攻击，是根据通信双方IP地址和端口、时间戳、MSS等信息进行实时计算的，保存在TCP包报头的`seq`里

![tcp报头_seq的位置](https://cdn.xiaolincoding.com//mysql/other/6d280b0946a73ea6185653cbcfcc489f.png)

第三次握手时就会通过seq还原出通信双方的IP地址、端口、时间戳、MSS

#### 为什么cookies不代替半连接队列

编码解码cookies很耗CPU，若攻击者构造大量的第三次握手包（ACK包）同时带上各种瞎编的cookie信息进行`ACK攻击`，服务端接收到还要解码最后发现不对丢弃，**导致CPU榨干服务器瘫痪**

![ack攻击](https://cdn.xiaolincoding.com//mysql/other/15a0a5f7fe15ee2bc5e07492eda5a8ea.gif)

### 用了TCP协议，数据一定不会丢吗？

不一定，**TCP只保证从源传输层到目的传输层的稳定传输**，之后的要看应用层发挥了

![网络发包收包全景图](https://cdn.xiaolincoding.com//mysql/other/28e4d6b004530fbf75fe346d181baa81.png)

#### 建立连接时丢包

服务端有半连接队列和全连接队列，是队列就有长度，若满了则新来的包就会被丢弃

![image-20240905123516240](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905123516240.png)

#### 流量控制丢包

网卡内部有**排队规则即流量控制机制**

![qdisc丢包](https://cdn.xiaolincoding.com//mysql/other/6f2821018be08a2f27561155e8085de4.png)

当发送数据过快，流控队列长度不够大时就会出现丢包现象

![image-20240905123823077](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905123823077.png)

#### 网卡丢包

ringbuffer缓冲区过小，发送数据过快导致缓冲区溢出产生丢包

![image-20240905123933200](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905123933200.png)

![image-20240905124003910](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905124003910.png)

#### 网卡性能不足

网卡作为硬件传输速度有上限

```
ehttool 网卡名如（ens33）
```

![image-20240905124158117](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905124158117.png)

千兆网卡1000Mb = 1000 M bits / 8 = 125 MBytes /s 

两者加起来=12-13w字节

![image-20240905124416777](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905124416777.png)

#### 接收缓冲区丢包

使用`TCP socket`编程时内核会分配一个发送缓冲区和一个接收缓冲区

![tcp_sendmsg逻辑](https://cdn.xiaolincoding.com//mysql/other/9cd22437777205662048c73cc5855add.png)

发送数据包执行`send`时不是马上发出而是**将数据拷贝到内核发送缓冲区**就完事返回，什么时候发数据和发多少**由内核做决定**

![image-20240905124731296](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905124731296.png)

阻塞调用，等就嗯等！

![send阻塞](https://cdn.xiaolincoding.com//mysql/other/7312e536393463dcf0d57aeb07f28ed5.gif)

非阻塞调用，则立刻返回一个`EAGAIN`错误信息意思是`try again`

![send非阻塞](https://cdn.xiaolincoding.com//mysql/other/f378a299ca60c490ee5437e1143916c8.gif)

接收缓冲区比较受，满了就将接收窗口为0即**零窗口**，且通过数据包里的`win=0`告诉发送端”别发了“。若发送端还再发，就会丢包

![recv_buffer丢包](https://cdn.xiaolincoding.com//mysql/other/2df66c2e1d9f1245813e8d1de7482e0c.png)

![image-20240905125041591](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905125041591.png)

#### 两端之外的网络丢包

两端之外的路由器、交换机等可能发生丢包

##### ping、mtr查看是不是中间链路丢了包

![image-20240905125320190](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905125320190.png)

![image-20240905125331861](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240905125331861.png)





#### 用了TCP一定不丢包吗

![四层网络协议](https://cdn.xiaolincoding.com//mysql/other/c6794dd51c8780f12e4022fc964ebb0a.png)

只保证A的传输层到B的传输层不丢，**数据到了接收端的传输层后能不能到应用层TCP不管**

举例：输入一条消息从聊天框发出，走到传输层TCP协议的发送缓冲区，不管中间丢没丢最后通过重传保证发到了对方的传输层TCP接收缓冲区，**接收端回复`ACK`，发送端收到`ACK`后就将自己发送缓冲区消息扔掉，TCP任务结束**

但微信任务还没结束

**微信需要将数据从TCP数据接收缓存区读出来**，在读出来的这一刻手机由于内存不足等各种原因软件崩溃闪退，发送端以为自己发的消息到对方了实际接收端没有收到这条消息，于是消息丢了

#### 发生丢包怎么办

1. 丢包很常见不可避免，就用TCP保证传输层没事儿应用层先不管

2. 引入第三端服务器保证应用层消息可靠

   ![聊天软件三端通信](https://cdn.xiaolincoding.com//mysql/other/d53659df39d64db4780d2816bd8314d1.png)

   - 如果只是两端通信，有1000个好友就要建立1000个连接，若加入服务端只需要跟服务器建立1个连接，聊天软件消耗资源越少，手机也越省电
   - 安全问题：两端通信，接收端别有用心就造成信息泄露
   - 软件版本问题：两端版本不一致很大概率不兼容

### TCP四次挥手，可以变成三次吗

![在这里插入图片描述](https://cdn.xiaolincoding.com//mysql/other/52f35dcbe24a4ca7abb23f292837c707.png)

![在这里插入图片描述](https://cdn.xiaolincoding.com//mysql/other/18635e15653a4affbdab2c9bf72d599e.png)

1. 客户端主动调用关闭连接函数，发送FIN报文，进入`FIN_WAIT_1`状态
2. 服务端收到FIN报文，**内核回复ACK进入`CLOSE_WAIT`状态**，收到FIN报文时TCP协议为**`FIN`包插入一个文件结束符`EOF`到接收缓冲区**，服务端应用程序通过`read`调用感知这个`FIN`包，**这个`EOF`放在已排队等候的其他已接收数据之后，因此要继续read接收缓冲区已接收的数据**

3. 服务端read数据直到读到`EOF`，`read`就会返回0，**服务端应用程序如果有数据要发送的话，就发完数据后调用关闭连接的函数**，如果服务端应用程序没有数据要发送直接关闭连接的函数，服务端发一个FIN包，FIN报文代表服务端**不再发送数据**处于`LAST_ACK`状态
4. 客户端接收到服务端`FIN`包，发送ACK确认包给服务端，客户端进入`TIME_WAIT`状态
5. 服务端收到ACK确认后进入CLOSE状态
6. 客户端经过2MSL时间之后进入CLOSE状态

#### 为什么要挥手4次

服务端收到客户端的FIN报文时**马上回ACK的是内核**，服务端可能**还有数据要处理，不能马上发送FIN报文**没法直接进入`LAST_ACK`状态，而是**将发送`FIN`报文的控制权交给服务端应用程序**

由于**FIN发送控制权在服务端不在内核**，因此ACK和FIN一般分开发送



#### 粗暴关闭 vs 优雅关闭

- `close`：socket关闭发送方向和读取方向，使socket不再有发送和接收数据的能力。**若多线程共用一个socket，有一个进程调用了close只是让socket引用计数-1**，不会导致socket不可用**同时不发出FIN报文**，还是可以正常读写socket直到引用计数变为0，才发出`FIN`报文
- `shutdown`：指定socket只关闭发送方向而不关闭读取方向，socket不再有发送数据的能力，但是还有接收数据的能力。若多线程共用一个socket，则会直接粗暴使该socket不可用，然后发出FIN报文，若别的进程企图该socket，会受到影响

如果客户端用`close`函数来关闭连接，则四次挥手过程中若收到服务端发送的数据，由于**客户端不再具有发送和接收数据的能力，因此客户端内核会回RST报文给服务端**，然后由内核释放连接，这时不会经历完整的四次握手，调用close是粗暴的关闭

![在这里插入图片描述](https://cdn.xiaolincoding.com//mysql/other/3b5f1897d2d74028aaf4d552fbce1a74.png)

- 如果是读操作，则返回`RST`错误，常见的connection reset by peer
- 如果是写操作，则产生`SIGPIPE`信号，应用层代码可以捕获并处理信号，若不处理则默认情况下进程会终止，异常退出



![优雅关闭.drawio.png](https://cdn.xiaolincoding.com//mysql/other/71f5646ec58849e5921adc08bb6789d4.png)

- shutdown函数可以指定只关闭发送方向而不关闭读取方向，即使TCP四次挥手过程中收到服务端发送的数据，客户端也可以正常读取到数据，然后经历完整的TCP四次挥手

- shutdown函数**也可以只关闭读取方向，不关闭发送方向**，但这时候**不会发送FIN报文因为发送FIN报文意味着我方不再发送任何数据**，若shutdown指定不关闭发送方向意味着socket还有发送数据能力，因此内核不会发送FIN

#### 什么情况出现三次挥手

![在这里插入图片描述](https://cdn.xiaolincoding.com//mysql/other/d7b349efa4f94453943b433b704a4ca8.png)

当被动关闭方在TCP挥手过程中，**没有数据要发送且开启了TCP延迟确认（默认会开启）机制**，那么第二和第三次挥手会合并传输，这样就出现了三次挥手

##### TCP延迟确认机制

发送没有携带数据的ACK效率很低，只有40个字节的IP头和TCP头，却没有携带数据报文，因此衍生出了**TCP延迟确认**。

- 有响应数据要发送时，ACK随着响应数据一起发送给对方
- **没有响应数据要发送时，ACK延迟一会等待是否有响应数据一起发送**
- 若在延迟等待发送ACK期间，对方第二个数据报文到了，这时也立刻发送ACK

![img](https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png)

延迟等待的时间是在Linux内核定义的

![img](https://cdn.xiaolincoding.com//mysql/other/ae241915337a4d2c9cb2f7ab91e6661d.png)

HZ与系统的时钟频率有关

![img](https://cdn.xiaolincoding.com//mysql/other/7a67bd4dc2894335b974e38674ba90b4.png)

- 最大延迟确认时间200ms
- 最小延迟确认时间40ms

![image-20240906193206899](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240906193206899.png)

#### TCP序列号和确认号是如何变化的

- 序列号 = 上一次**发送的序列号**+ len（数据长度）；特殊情况，上一次是SYN或FIN，改为上一次+1
- 确认号 = 上一次**收到的报文序列号** + len（数据长度）；特殊情况，上一次是SYN或FIN，改为上一次+1

*![image-20240906221220301](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240906221220301.png)**

# 3. IP

## 基础认识

### IP地址分类

![IP 地址分类](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/7.jpg)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/8.jpg)

最大主机数计算= 2^位 - 2，有2个IP是特殊的分布是主机号全1和全0地址

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/10.jpg)

- 全1：指定某个网络下的所有主机，用于广播
- 全0：指定某个网络本身

#### 广播

- **局域网内的广播叫本地广播**，例如广播地址为192.168.48.128/24的情况下**广播地址是192.168.0.255**,因为这个广播地址包会被路由器屏蔽，因此不会到达192.168.48.0/24以外的其他链路上
- **在不同网络之间的广播叫直接广播**，例如网络地址为192.168.0.0/24的主机**向192.168.1.255/24（广播地址）的目标地址**发送IP包，收到这个包的路由器，将数据**转发给192.168.1.0/24网络本身**，从而使得**所有192.168.1.1~192.168.1.254**的主机都接收到这个包（**直接广播有安全问题，多数情况路由器上设置为不转发**）

![本地广播与直接广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/11.jpg)

#### D、E类地址

D类地址和E类地址都**没有主机号**，不可以用于主机IP，**D类常用于多播**，E类是预留分类暂时无用

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/12.jpg)

#### 多播

多播用于**将包发送给特定组内的所有主机**

![单播、广播、多播通信](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/13.jpg)

D类地址：前四位1110是多播地址，剩下28位是多播的组编号，224.0.0.0~239.255.255.255都是多播可用范围

- 224.0.0.0~224.0.0.255：预留的组播地址，只用于**局域网，路由器不转发**
- 224.0.1.0~238.255.255.255：用户可用的组播地址，可以用于**Internet**
- 239.0.0.0~239.255.255.255：**本地管理组播地址，供内部网内部使用**，特定的本地范围生效

#### IP分类优点

简单明了、选路简单

![IP 分类判断](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/14.jpg)****

#### IP分类缺点

1. 同一网络下没有地址层次，众生平等的主机号
2. A、B、C类主机号分配不平衡，254太少了、65534又太多了

### 无分类地址CIDR

- 舍弃掉IP分类，使用`a.b.c.d/x`，x范围是0~32表示网络号
- 也可以用子网掩码，顾名思义掩盖掉主机号，IP号与子网掩码作位与就得到网络号，与`/x`是一个意思



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/15.jpg)

#### 为什么要分离网络号和主机号

两台计算机通讯，首先要判断**是否处于同一个广播域**，若网络地址相同直接由路由器转发到目标主机就行了

![IP地址的网络号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)

#### 子网划分

子网掩码除了划分网络号和主机号，还可以划分**子网网络和子网主机号**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg)



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/19.jpg)

- IP:192.168.1.0 

- 子网掩码：255.255.255.192，已知192.168.1是C类地址，可用主机为8位，**192说明子网掩码偷了2位划给了子网网号，这样就能起到很好的分层效果**，把256个再分成4个64

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/20.jpg)

划分后的4个子网：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/21.jpg)

### 共有IP和私有IP

A、B、C类中会划分共有和私有IP，不同共有IP下的私有IP可以重复

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/22.jpg)

#### 公有IP由谁管理

![image-20240829105412268](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240829105412268.png)

### IP地址与路由控制

IP地址的**网络地址由路由进行控制**，路由控制表记录着网络地址与下一步应该发送路由器的地址，主机和路由器上都有各自的路由表

![IP 地址与路由控制](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/25.jpg)

1. 源地址：`10.1.1.30/24`，目的地址：`10.1.2.10/24`，主机A路由表没找到与`10.1.2.10`相同的网络地址便转发到默认路由（路由1）
2. 路由1根据路由表进行匹配，发现匹配到了就发给了`10.1.0.2`路由2
3. 路由2匹配路由表发现`10.1.2.0/24`就在自家，便从接口发送出去经过交换机把IP数据包转发到了目标主机

#### 环回地址

**环回地址是指同一台计算机上的程序之间网络通信所使用的默认地址**，一般默认为**`127.0.0.1`作为环回地址，localhost作为主机名，使用这个地址数据包不会流向网络**

### IP分片与重组

每种数据链路层的最大传输单元`MTU`都不一要，Internet是1500Bytes，FDDI是4352

IP数据包>MTU时就会分片，重组发生在应用层

![分片与重组](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/26.jpg)

TCP传输中引入`MSS`由TCP分片，且MSS<MTU；**对UDP尽量不要传>1个MTU的数据报文**

### IPv6基本认识

- IPv4：32位，2^32 ≈ 42亿，2011年已经分完
- IPv6：128位，16个字节 = 32个16进制，每16位为一组每组用`:`分隔开；出现连续的0用`：：`隔开，一个IP地址只允许出现两个连续的冒号

![IPv6 地址表示方法](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/27.jpg)

![Pv6 地址缺省表示方](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/28.jpg)

#### IPv6优点

- **可自动配置，即使没有DHCP服务器也可以实现自动分配IP地址**
- 包头包首使用**固定的40字节，去掉包头校验和简化首部结构**，**减轻路由器负荷大大提高传输性能**
- 有应用伪造IP地址的网络安全功能以及防线路窃听功能，大大提升安全性

#### IPv6地址结构

- 单播地址：**一对一**通信
- 组播地址：**一对多**通信
- 任播地址：通信最近的节点，由路由协议决定
- 没有广播地址

![IPv6地址结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/29.jpg)

#### IPv6单播地址类型

分为三类单播地址

1. **IPv6独有：同一链路单播通信，不经过路由器只经过交换机可以使用链路本地单播地址**
2. 内网内单播通信：可以使用**唯一本地地址**，相当于IPv4的私有IP
3. 互联网通信，可以使用**全局单播地址**，相当于IPv4的公有IP

![ IPv6 中的单播通信](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg)

#### IPv6首部对比IPv4首部

![IPv4 首部与 IPv6 首部的差异](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/31.jpg)

- 取消首部校验和字段：因为**数据链路层和传输层都会校验**，因此直接取消IP校验
- 取消分片/重新组装相关字段：**不允许在中间路由器进行分片与重组浪费时间**，只能在应用层即主机大大提高路由器转发速度
- 取消选项字段：**使IPv6首部为固定长度的40字节**，**选项字段可能出现在IPv6中的下一个首部指出的位置**

## IP协议相关技术

### ARP

1. 发送方直到接收方的IP地址但不知道MAC地址，构建一个ARP请求报文，包括了发送方的IP地址和MAC地址和**接收方的IP地址**
2. 发送方将**ARP请求广播到本地网络**，目标IP匹配的会响应并构建**ARP应答报文**包括自己的IP地址和**MAC地址**，接收方将ARP应答报文发送给发送方
3. 发送方接收到后会接收方的**IP地址和MAC地址存储在ARP缓存中**

ARP:通过IP地址找MAC地址

![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/34.jpg)

Linux中可以使用`arp-a`查看ARP缓存内容

#### RARP

**已知MAC地址找IP地址**，需要架一台RARP服务器，在服务器上注册设备的MAC地址和IP地址再将设备接入网络中

![RARP](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/35.jpg)

### DHCP

DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)

DISCOVER -> OFFER -> REQUEST -> ACK

1. 客户端发起DHCP`发现报文（DHCP DISCOVER）`的IP数据报，由于客户端没有IP地址也不知道DHCP服务器的地址，因此用**UDP广播通信，使用广播目的地址是255.255.255.255（端口67），使用0.0.0.0（端口68）作为源IP地址**，DHCP客户端将此IP数据报传递给链路层，链路层将帧广播到所有的网络设备
2. DHCP服务器收到DHCP发现报文时，用DHCP`提供报文（DHCP OFFER）`的客户端做出响应，报文仍然**使用IP广播地址255.255.255.255，报文信息携带服务器可供租约的IP地址、子网掩码、默认网关、DNS服务器以及地址租用期**
3. 客户端**收到一个或多个服务器的DHCP提供报文后，从中选择一个服务器**，并向选择的服务器发送`DHCP请求报文（DHCP REQUEST）`进行响应，回显配置的参数
4. 服务端用`DHCP ACK`报文对`DHCP REQUEST`进行响应，应答所要求的参数

![DHCP 工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/36.jpg)

租约的DHCP IP地址快到期后，客户端向服务端发送DHCP请求报文：

- 服务器如果同意继续租用，则用`DHCP ACK`报文进行应答，客户端延长租期
- 服务器若不同意继续租用，则用`DHCP NACK`报文，客户端停止使用租约的地址

**DHCP交互中，全部都是用UDP广播通信**

- 如果使用的是广播，DHCP服务器与客户端不在同一个局域网时，路由器不会转发广播包那岂不是每个网络都要配一个DHCP服务器？

为了解决这个问题，**出现了DHCP中继代理**，可以对不同网段的IP地址分配也可以由一个DHCP服务器统一进行管理。

- DHCP中继代理通常部署在路由器或三层交换机上，它可以接收来自客户端的 DHCP 广播请求，并将其转换为**单播**数据包转发给其他网络中的 DHCP 服务器。
- 当 DHCP 服务器收到中继代理转发的请求后，会为客户端分配 IP 地址等网络参数，并将响应数据包发送回中继代理。中继代理再将响应转换为**广播或单播**数据包发送给客户端。

因此DHCP服务器即使不在同一个链路上也可以实现统一分配和管理地址

![ DHCP 中继代理](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg)

### NAT

NAT（Network Address Translation，网络地址转换），**将私网IP转换为公网IP**，这样就能访问Internet了



![NAT](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/38.jpg)

但是并不能解决IPv4不够用的问题，本质是一比一转换

#### NAPT

NAPT（Network Address Port Translation，网络地址端口转换）将**IP地址+端口一起转换，这样就能白嫖端口号多出来的额外位数**，解决了IPv4不够用的问题

![NAPT](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/39.jpg)

两个私有IP端口都为1025的都转为相同的公网IP`120.229.175.121`，但是端口号不同

#### NAPT缺点

1. **外部无法主动与NAT内部服务器建立连接**，因为NAPT转换表没有转换记录
2. 转换表的生成与转换操作都产生**性能开销**
3. 通信过程中，过于依赖NAPT转换表，**NAT路由器重启了所有的TCP连接都将被重置**

#### 解决NAPT问题

1. 使用IPv6
2. NAT穿透技术：能让客户端主动从NAT设备获取公有IP地址，然后自己建立端口映射条目，用这个条目与外界通信，就不需要NAT设备进行转换

### ICMP

ICMP(Internet Control Message Protocol，互联网控制报文协议)，用于**确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置**

![ICMP 目标不可达消息](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/40.jpg)

主机A->主机B发送的数据包达不到，路由器2就会向主机A发送一个ICMP目标不可达数据包说明发包失败。**ICMP使用IP进行发包**，因此会经过路由1转发给主机A，收到ICMP包的主机分解ICMP的首部和数据域

#### ICMP包头

ICMP报文封装在IP包中，工作在网络层，是IP的助手

![ICMP 报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/5.jpg)



#### ICMP类型

- **查询报文**类型：用于诊断的查询消息
- **差错报文**类型：通知出错原因的错误信息

![常见的 ICMP 类型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg)

#### 查询报文类型

会送消息用于通信的主机或路由器之间判断所发送的数据包是否已成功到达对端

 ![ICMP 回送消息](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/7.jpg)

- 回送请求（ICMP Echo **Request** Message，类型`8`）：**向对端主机发送**回送请求消息
- 回送应答（ICMP Echo **Reply** Message，类型`0`）：**接收对端主机**发送的回送应答消息

![ICMP 回送请求和回送应答报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/8.jpg)



比原生的ICMP多了两个字段

- 标识符：区分哪个应用程序发送的ICMP包，如用**进程`PID`作标识符**
- 序号：从`0`开始，每发送一次新的回送请求就加`1`，用来确认网络包是否有丢失
- 选项数据：`ping`存放发送请求的时间值，来计算往返时间说明路程长短

#### 差错报文类型

1. 目标不可达消息：类型`3`
2. 原点抑制消息：类型`4`
3. 重定向消息：类型`5`
4. 超时消息：类型`11`

##### 1 目标不可达消息

- 端口不可达：找到了网络+主机但对端主机没有进程监听8080端口，则ICMP协议以端口不可达告知主机
- 需分片但设置不了分片：发送端主机发送IP数据报时将IP首部分片禁止标志位置1，**途中路由器遇到超过MTU大小的数据包不会进行分片直接抛弃**

![目标不可达类型的常见代码号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/9.jpg)

##### 2 原点抑制消息（ICMP Source Quench Message）

缓和低速广域线路的网络拥堵情况，**路由器向低速线路发送数据时其发送队列缓存变为0而无法发出去**时，向IP包源地址发送ICMP原点抑制消息，收到这个消息的主机借此了解某个线路的某一处发生拥堵的情况，**增大IP包传输间隔减少网络拥堵**。

**但会引起不公平网络通信一般不使用**

##### 3 重定向消息（ICMP Redirect Message）

若路由器发送端主机使用了**不是最优的路径**发送数据，就发送一个ICMP重定向消息，这个消息包含了**最合适的路由信息和源数据**，下次就不用绕远路了

##### 4 超时消息（ICMP Time Exceeded Message）

IP包有一个`TTL`(Time To Live，生命周期)，值每经过一个路由器就减1，**减到0包就丢弃**，此时路由器发送一个ICMP超时消息给发送端主机，通知包已丢弃。

设置TTL是防止路由器遇到问题**发生循环状况时，避免IP包被无休止地被转发**

![ICMP 时间超过消息](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/11.jpg)

### IGMP

IGMP(Internet Group Management Protocol，网络组管理协议)，工作在**主机（组播成员）和最后一条路由之间，用于确认主机是在组播的同一组里**

**组播没有主机号和端口只有28位IP地址，属于D类地址，可以大大减少数据流量因为是一对多只需发一次**

- 例如，在一个视频会议应用中，多个主机可能希望接收来自同一个视频源的多播流量。这些主机可以通过 IGMP 向本地路由器表明它们希望加入特定的多播组，以便接收视频会议的数据流。

![组播模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/42.jpg)

- IGMP 有三个主要版本：IGMPv1、IGMPv2 和 IGMPv3。每个版本都在功能和效率上有所改进。

- IGMPv1 是最基本的版本，支持**主机加入和离开多播组**的功能。IGMPv2 增加了一些功能，如**离开组的明确通知和查询机制的改进**。IGMPv3 则进一步**增强了对多播源的选择和过滤功能，允许主机指定它希望接收来自哪些特定源的多播流量**。

#### 常规查询与响应工作机制

![ IGMP 常规查询与响应工作机制](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/43.jpg)

1. 路由器周期发送目的地址224.0.0.1（表示同一网段内的所有主机和路由器）IGMP常规查询报文
2. 主机1和主机3收到查询，启动报告延迟计时器，计时器时间随机0-10s，超时后主机发送IGMP成员关系报告报文（源IP地址位自己主机IP地址，目的地址为轮播地址）。定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己就不发送了
3. 路由器收到主机的成员关系报文后，**在IGMP路由表加入该组播组**，后续网络一旦该组播地址的数据到达路由器，就把数据包转发出去

#### 离开组播组工作机制

![ IGMPv2 离开组播组工作机制 情况1](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/44.jpg)

1. 主机1要离开组播组224.1.1.1，发送IGMPv2离组报文，报文目的地址是224.0.0.2（表示发向网段内所有路由器）
2. 路由器收到报文后，以1s为间隔连续发送IGMP从特定组查询报（共计发送2个），**确认该网络是否还有224.1.1.1组的其他成员**
3. 主机3仍是组224.1.1.1的成员，因此立即响应这个特定组查询，路由器知道该网络还有该组播组成员，继续向网络转发224.1.1.1的组播数据包

- 没有该组播组的情况：

![ IGMPv2 离开组播组工作机制 情况2](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/45.jpg)

1. 主机1离开并发送IGMP离组报文
2. 路由器收到后，以1s为间隔连续发送IGMP从特定组查询报（共计发送2个），发向没有其他成员了
3. 一定时间后，路由器直到没有组播成员了，停止转发组播地址的数据包

### ping--查询报文类型的使用

ping是**应用层**的命令，底层利用了**ICMP**的`echo request（类型8`）和`echo response（类型0）`

**虽然ICMP和IP都是网络层协议，但ICMP利用了IP协议进行消息的传输**

![主机 A ping 主机 B](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/12.jpg)

源主机构建一个(ICMP Echo Request Message)数据包，包内包含多个字段最重要的有2个

1. 类型：对于request消息字段为`8`
2. 序号：**区分**连续ping时发出的多个数据包

![主机 A 的 ICMP 回送请求报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/13.jpg)

然后与IP包头一起封装交给IP层

![主机 A 的 IP 层数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/14.jpg)

接下来需要加入`MAC`头，在本地ARP映射表找出IP为`192.168.1.2`对应的MAC地址；若无就发送ARP协议查询MAC地址，获得MAC地址后由数据链路层**构建数据帧并附加一些控制信息**，依据Internet介质访问规则，将他们传送出去

![主机 A 的 MAC 层数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/15.jpg)

主机B收到数据帧后，先检查目的MAC地址看看与本机是否相符，然后检查数据帧将IP数据包从帧提取出来，交给本机IP层，IP层检查后将有用信息提取给ICMP协议。

主机B会构建一个ICMP回送响应消息（ICMP Echo Response Message）数据包，回送响应数据包类型字段为`0`，序号为接收的请求数据包的序号，然后发给A

规定时间内，源主机没有收到ICMP应答包，说明目标主机不可达；若收到，说明目标主机可达。此时源主机检查，**用当前时刻减去该数据包最初从源主机发出的时刻，就是ICMP数据包的时间延迟**

![主机 A ping 主机 B 期间发送的事情](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/17.png)

这只是局域网内的情况，若跨网段则会涉及网关的转发、路由器的转发等等

但对于ICMP的头讲，没影响，**影响的只是根据目标IP地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网需要换MAC头里面的MAC地址**

### traceroute-差错报文类型的使用

#### 作用1：追踪去往目的地时沿途经过的路由器

**故意设置特殊的TTL，追踪去往目的地时沿途经过的路由器**

例如，**将TTL设置为1**，遇到第一个路由就牺牲了返回ICMP差错报文网络包，类型是时间超时，TTL设置为2，第一个路由器过了，遇到第二个路由器也牺牲了同时返回ICMP差错报文数据包如此反复直到到达目的主机，**这样就能拿到所有的路由器IP**

但也有路由器不会返回这个ICMP，对有的公网地址是看不到中间经过的路由的

- 发送方如何知道发出的UDP包到达目的主机？

traceroute发送UDP包时，目的端口会填一个不可能的端口号：`33434`，对于下个探针都会增加一个，目的主机收到UDP包后返回ICMP差错报文消息，类型是**端口不可达**（类型3中的3）

#### 作用2：故意设置不分片，确认路径的MTU

在非Internet的MTU值不知道，因此需要试探得到

![MTU 路径发现（UDP的情况下）](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/18.jpg)

1. 发送IP数据报时，将IP包首部分片禁止标志位置1
2. 通过ICMP的不可达消息将数据链路上MTU值一起给发送主机，不可达消息类型为**需要进行分片但设置了不分片位**（类型3中的4）
3. 发送端每次收到ICMP差错报文就减少包的大小，定位一个合适的MTU值

### 断网了，还能ping通127.0.0.1吗

yes!

![image-20240830114652424](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240830114652424.png)

#### 什么是127.0.0.1

**127开头的都属于回环地址**，`127.0.0.1`是众多回环地址的一个

![图片](https://cdn.xiaolincoding.com//mysql/other/fa904fbcf66cc7abf510a8dc16f867fa.png)

**ipv6的回环地址是`::1`**，为什么只有2个`:`因为**ipv6只允许出现一次两个连续的冒号**

#### TCP发数据和PING的区别

![image-20240830115801785](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240830115801785.png)

Linux里万物皆文件，要**发消息的目的地也是个文件**

##### TCP

1. TCP传输中创建`socket`的方式是`socket(AF_INET, SOCK_STREAM, 0)`，**`AF_INET`表示使用IPv4的`host:port`的方式解析待会输入的网络地址**，**`SOCK_STREAM`是指使用面向字节流的TCP协议，工作在传输层**
2. 创建好socket后便可以将传输的数据写到这个文件里，调**用socket的`sendto`接口过程中进程会从用户态进入到内核态**，最后调用到`sock_sendmsg`方法
3. 进入传输层后，带上TCP头，网络层带上IP头，链路层带上MAC头等系列操作后，进入网卡的发送队列ring buffer，顺着网卡发出去

##### ping

1. 与TCP大致相似，差异的地方在于创建`socket`的时候使用的是`socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)`，**`SOCK_RAW`是原始套接字，工作在网络层**，因此**很适合构建ICMP(网络层协议)**。
2. ping在内核态最后也是调用到`sock_sendmsg`方法，进入到网络层后加上ICMP和IP头再加上MAC头顺着网卡发出，本质与TCP没有太大差别

#### 为什么断网了还是能ping 127.0.0.1

因为发向目标IP是回环地址时，在数据链路层网卡就会选择**本地网卡（”假“网卡）**，不像**真网卡有个`ring buffer`，假网卡会把数据推到一个叫`input_pkt_queue`的链表中，这个链表所有网卡共享，上面挂着发给本机的各种消息。消息发送到这个链表后，会再触发一个软中断**

![图片](https://cdn.xiaolincoding.com//mysql/other/c1019a8be584b27c4fc8b8abda9d3cf1.png)

专门处理软中断的工具人`ksoftirqd（内核线程）`，在收到软中断后立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序

**ping回环地址和通过TCP等各种协议发送数据到回环地址都是走这条路径**，整条路经从发到收，都没有经过真网卡。”回环“：理解为消息发出到这个地址上不会出网络，在本机打个转又回来了

#### ping 回环地址和本机地址区别

没有区别，都是走的lo0本地回环地址，不会进入物理网络接口

![image-20240830121903441](C:\Users\z1002\AppData\Roaming\Typora\typora-user-images\image-20240830121903441.png)

#### 127.0.0.1 和 localhost 和 0.0.0.0区别

1. localhost不是地址，而是**域名**跟`google.com`是一种类型的，只不过会解析为`127.0.0.1`，可以在`/etc/hosts`下修改
2. `0.0.0.0`在ipv4中是无效的目标地址，启动服务器时会listen一个IP和端口，等待客户端连接。**若listen的是本机的`0.0.0.0`，表示本机的所有ipv4地址**